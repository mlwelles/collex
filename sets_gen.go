// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/noho-digital/genny

package collex

import "github.com/noho-digital/mapset"

// reset these in an init in the dest package if you dont want the defaults
var __InterfaceSetReceiverAutoConvertComparisonInterfaceSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyInterfaceSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyInterfaceSet or InterfaceSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __InterfaceSetReceiverAutoConvertComparisonInterfaceSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that InterfaceSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() InterfaceSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...Interface) bool

	// Returns if the given item is not in the set
	NotContains(i Interface) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...Interface) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...Interface) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...Interface) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyInterfaceSet) InterfaceSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyInterfaceSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyInterfaceSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyInterfaceSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyInterfaceSet) InterfaceSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyInterfaceSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyInterfaceSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyInterfaceSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyInterfaceSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyInterfaceSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(Interface) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyInterfaceSet) InterfaceSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyInterfaceSet) InterfaceSet
	// Returns the members of the set as a slice.
	ToSlice() []Interface

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item Interface) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item Interface) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyInterfaceSet) InterfaceSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() InterfaceSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewInterfaceSet() and NewInterfaceSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeInterfaceSet(0 and NewThreadUnsafeInterfaceSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type InterfaceSet interface {
	ReadOnlyInterfaceSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i Interface) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...Interface) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i Interface)

	// Pop removes and returns an arbitrary item from the set.
	Pop() Interface
}

type mapsetInterfaceSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetInterfaceSet) NotContains(i Interface) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetInterfaceSet) NotContainsAny(tt ...Interface) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetInterfaceSet) Nil() bool {
	return s == nil
}

func (s *mapsetInterfaceSet) NotNil() bool {
	return s != nil
}

func (s *mapsetInterfaceSet) IsDisjoint(other ReadOnlyInterfaceSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetInterfaceSet) Intersects(o ReadOnlyInterfaceSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetInterfaceSet) ContainsAny(items ...Interface) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetInterfaceSet) ContainsAll(i ...Interface) bool {
	return s.Contains(i...)
}

func (s *mapsetInterfaceSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetInterfaceSet) Add(i Interface) bool {
	return s.ms.Add(i)
}

func (s *mapsetInterfaceSet) AddAll(il ...Interface) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetInterfaceSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetInterfaceSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetInterfaceSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetInterfaceSet) Clone() InterfaceSet {
	if s == nil {
		return nil
	}
	return &mapsetInterfaceSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) Contains(t ...Interface) bool {
	if s == nil {
		return false
	}
	i := __convertInterfaceSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetInterfaceSet) Difference(other ReadOnlyInterfaceSet) InterfaceSet {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return &mapsetInterfaceSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) Equal(other ReadOnlyInterfaceSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInterfaceSet) NotEqual(other ReadOnlyInterfaceSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInterfaceSet) Intersect(other ReadOnlyInterfaceSet) InterfaceSet {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetInterfaceSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) IsProperSubset(other ReadOnlyInterfaceSet) bool {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetInterfaceSet) IsProperSuperset(other ReadOnlyInterfaceSet) bool {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetInterfaceSet) IsSubset(other ReadOnlyInterfaceSet) bool {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetInterfaceSet) IsSuperset(other ReadOnlyInterfaceSet) bool {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetInterfaceSet) Each(f func(Interface) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(Interface)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetInterfaceSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetInterfaceSet) Remove(i Interface) {
	s.ms.Remove(i)
}

func (s *mapsetInterfaceSet) String() string {
	return s.ms.String()
}

func (s *mapsetInterfaceSet) SymmetricDifference(other ReadOnlyInterfaceSet) InterfaceSet {
	return &mapsetInterfaceSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) Union(other ReadOnlyInterfaceSet) InterfaceSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
		return &mapsetInterfaceSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyInterfaceSetMatchingInterface(other))
	default:
		return s.Union(__emptyInterfaceSetMatchingInterface(s))
	}
}

func (s *mapsetInterfaceSet) Pop() Interface {
	var def Interface
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInterface(i)
}

func (s *mapsetInterfaceSet) PowerSet() InterfaceSet {
	return &mapsetInterfaceSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) CartesianProduct(other ReadOnlyInterfaceSet) InterfaceSet {
	other = __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other)
	return &mapsetInterfaceSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInterfaceSet) ToSlice() []Interface {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToInterfaceSlice(s.ms.ToSlice())
}

func (s *mapsetInterfaceSet) NotEmptyAndContains(item Interface) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetInterfaceSet) NotEmptyAndNotContains(item Interface) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetInterfaceSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetInterfaceSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetInterfaceSet) AddItems(items ...Interface) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewInterfaceSet(items ...Interface) InterfaceSet {
	return newMapsetInterfaceSet(items...)
}

func newMapsetInterfaceSet(items ...Interface) *mapsetInterfaceSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetInterfaceSet{ms: ms, isThreadSafe: true}
}

// NewInterfaceSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewInterfaceSetFromSlice(s []Interface) InterfaceSet {
	i := __convertInterfaceSliceToInterfaceSlice(s)
	return &mapsetInterfaceSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeInterfaceSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeInterfaceSet(i ...Interface) InterfaceSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetInterfaceSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeInterfaceSetFromSlice(s []Interface) InterfaceSet {
	i := __convertInterfaceSliceToInterfaceSlice(s)
	return &mapsetInterfaceSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeInterfaceSet(other ReadOnlyInterfaceSet) ReadOnlyInterfaceSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewInterfaceSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeInterfaceSet(other ReadOnlyInterfaceSet) ReadOnlyInterfaceSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeInterfaceSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeInterfaceSetMatchingCopyIfEnabled(s, other ReadOnlyInterfaceSet) ReadOnlyInterfaceSet {
	if !__InterfaceSetReceiverAutoConvertComparisonInterfaceSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeInterfaceSet(other)
	}

	return __ensureThreadUnsafeInterfaceSet(other)
}

func __convertInterfaceSliceToInterfaceSlice(typeSlice []Interface) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInterface(item interface{}) Interface {
	t, ok := item.(Interface)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToInterfaceSlice(interfaceSlice []interface{}) []Interface {
	typeSlice := make([]Interface, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInterface(item)
	}
	return typeSlice
}

func __emptyInterfaceSetMatchingInterface(s ReadOnlyInterfaceSet) ReadOnlyInterfaceSet {
	if s.IsThreadSafe() {
		return __emptyInterfaceSet
	} else {
		return __emptyThreadUnsafeInterfaceSet
	}
}

var __emptyInterfaceSet = NewInterfaceSet()
var __emptyThreadUnsafeInterfaceSet = NewThreadUnsafeInterfaceSet()

// reset these in an init in the dest package if you dont want the defaults
var __ByteSetReceiverAutoConvertComparisonByteSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyByteSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyByteSet or ByteSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __ByteSetReceiverAutoConvertComparisonByteSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that ByteSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() ByteSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...byte) bool

	// Returns if the given item is not in the set
	NotContains(i byte) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...byte) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...byte) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...byte) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyByteSet) ByteSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyByteSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyByteSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyByteSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyByteSet) ByteSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyByteSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyByteSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyByteSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyByteSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyByteSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(byte) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyByteSet) ByteSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyByteSet) ByteSet
	// Returns the members of the set as a slice.
	ToSlice() []byte

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item byte) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item byte) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyByteSet) ByteSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() ByteSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewByteSet() and NewByteSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeByteSet(0 and NewThreadUnsafeByteSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type ByteSet interface {
	ReadOnlyByteSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i byte) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...byte) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i byte)

	// Pop removes and returns an arbitrary item from the set.
	Pop() byte
}

type mapsetByteSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetByteSet) NotContains(i byte) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetByteSet) NotContainsAny(tt ...byte) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetByteSet) Nil() bool {
	return s == nil
}

func (s *mapsetByteSet) NotNil() bool {
	return s != nil
}

func (s *mapsetByteSet) IsDisjoint(other ReadOnlyByteSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetByteSet) Intersects(o ReadOnlyByteSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetByteSet) ContainsAny(items ...byte) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetByteSet) ContainsAll(i ...byte) bool {
	return s.Contains(i...)
}

func (s *mapsetByteSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetByteSet) Add(i byte) bool {
	return s.ms.Add(i)
}

func (s *mapsetByteSet) AddAll(il ...byte) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetByteSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetByteSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetByteSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetByteSet) Clone() ByteSet {
	if s == nil {
		return nil
	}
	return &mapsetByteSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) Contains(t ...byte) bool {
	if s == nil {
		return false
	}
	i := __convertByteSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetByteSet) Difference(other ReadOnlyByteSet) ByteSet {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return &mapsetByteSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) Equal(other ReadOnlyByteSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetByteSet) NotEqual(other ReadOnlyByteSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetByteSet) Intersect(other ReadOnlyByteSet) ByteSet {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetByteSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) IsProperSubset(other ReadOnlyByteSet) bool {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetByteSet) IsProperSuperset(other ReadOnlyByteSet) bool {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetByteSet) IsSubset(other ReadOnlyByteSet) bool {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetByteSet) IsSuperset(other ReadOnlyByteSet) bool {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetByteSet) Each(f func(byte) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(byte)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetByteSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetByteSet) Remove(i byte) {
	s.ms.Remove(i)
}

func (s *mapsetByteSet) String() string {
	return s.ms.String()
}

func (s *mapsetByteSet) SymmetricDifference(other ReadOnlyByteSet) ByteSet {
	return &mapsetByteSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) Union(other ReadOnlyByteSet) ByteSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
		return &mapsetByteSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyByteSetMatchingByte(other))
	default:
		return s.Union(__emptyByteSetMatchingByte(s))
	}
}

func (s *mapsetByteSet) Pop() byte {
	var def byte
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToByte(i)
}

func (s *mapsetByteSet) PowerSet() ByteSet {
	return &mapsetByteSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) CartesianProduct(other ReadOnlyByteSet) ByteSet {
	other = __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other)
	return &mapsetByteSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetByteSet) ToSlice() []byte {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToByteSlice(s.ms.ToSlice())
}

func (s *mapsetByteSet) NotEmptyAndContains(item byte) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetByteSet) NotEmptyAndNotContains(item byte) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetByteSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetByteSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetByteSet) AddItems(items ...byte) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewByteSet(items ...byte) ByteSet {
	return newMapsetByteSet(items...)
}

func newMapsetByteSet(items ...byte) *mapsetByteSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetByteSet{ms: ms, isThreadSafe: true}
}

// NewByteSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewByteSetFromSlice(s []byte) ByteSet {
	i := __convertByteSliceToInterfaceSlice(s)
	return &mapsetByteSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeByteSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeByteSet(i ...byte) ByteSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetByteSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeByteSetFromSlice(s []byte) ByteSet {
	i := __convertByteSliceToInterfaceSlice(s)
	return &mapsetByteSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeByteSet(other ReadOnlyByteSet) ReadOnlyByteSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewByteSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeByteSet(other ReadOnlyByteSet) ReadOnlyByteSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeByteSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeByteSetMatchingCopyIfEnabled(s, other ReadOnlyByteSet) ReadOnlyByteSet {
	if !__ByteSetReceiverAutoConvertComparisonByteSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeByteSet(other)
	}

	return __ensureThreadUnsafeByteSet(other)
}

func __convertByteSliceToInterfaceSlice(typeSlice []byte) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToByte(item interface{}) byte {
	t, ok := item.(byte)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToByteSlice(interfaceSlice []interface{}) []byte {
	typeSlice := make([]byte, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToByte(item)
	}
	return typeSlice
}

func __emptyByteSetMatchingByte(s ReadOnlyByteSet) ReadOnlyByteSet {
	if s.IsThreadSafe() {
		return __emptyByteSet
	} else {
		return __emptyThreadUnsafeByteSet
	}
}

var __emptyByteSet = NewByteSet()
var __emptyThreadUnsafeByteSet = NewThreadUnsafeByteSet()

// reset these in an init in the dest package if you dont want the defaults
var __RuneSetReceiverAutoConvertComparisonRuneSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyRuneSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyRuneSet or RuneSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __RuneSetReceiverAutoConvertComparisonRuneSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that RuneSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() RuneSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...rune) bool

	// Returns if the given item is not in the set
	NotContains(i rune) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...rune) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...rune) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...rune) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyRuneSet) RuneSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyRuneSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyRuneSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyRuneSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyRuneSet) RuneSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyRuneSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyRuneSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyRuneSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyRuneSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyRuneSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(rune) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyRuneSet) RuneSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyRuneSet) RuneSet
	// Returns the members of the set as a slice.
	ToSlice() []rune

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item rune) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item rune) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyRuneSet) RuneSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() RuneSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewRuneSet() and NewRuneSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeRuneSet(0 and NewThreadUnsafeRuneSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type RuneSet interface {
	ReadOnlyRuneSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i rune) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...rune) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i rune)

	// Pop removes and returns an arbitrary item from the set.
	Pop() rune
}

type mapsetRuneSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetRuneSet) NotContains(i rune) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetRuneSet) NotContainsAny(tt ...rune) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetRuneSet) Nil() bool {
	return s == nil
}

func (s *mapsetRuneSet) NotNil() bool {
	return s != nil
}

func (s *mapsetRuneSet) IsDisjoint(other ReadOnlyRuneSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetRuneSet) Intersects(o ReadOnlyRuneSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetRuneSet) ContainsAny(items ...rune) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetRuneSet) ContainsAll(i ...rune) bool {
	return s.Contains(i...)
}

func (s *mapsetRuneSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetRuneSet) Add(i rune) bool {
	return s.ms.Add(i)
}

func (s *mapsetRuneSet) AddAll(il ...rune) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetRuneSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetRuneSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetRuneSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetRuneSet) Clone() RuneSet {
	if s == nil {
		return nil
	}
	return &mapsetRuneSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) Contains(t ...rune) bool {
	if s == nil {
		return false
	}
	i := __convertRuneSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetRuneSet) Difference(other ReadOnlyRuneSet) RuneSet {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return &mapsetRuneSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) Equal(other ReadOnlyRuneSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetRuneSet) NotEqual(other ReadOnlyRuneSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetRuneSet) Intersect(other ReadOnlyRuneSet) RuneSet {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetRuneSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) IsProperSubset(other ReadOnlyRuneSet) bool {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetRuneSet) IsProperSuperset(other ReadOnlyRuneSet) bool {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetRuneSet) IsSubset(other ReadOnlyRuneSet) bool {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetRuneSet) IsSuperset(other ReadOnlyRuneSet) bool {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetRuneSet) Each(f func(rune) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(rune)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetRuneSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetRuneSet) Remove(i rune) {
	s.ms.Remove(i)
}

func (s *mapsetRuneSet) String() string {
	return s.ms.String()
}

func (s *mapsetRuneSet) SymmetricDifference(other ReadOnlyRuneSet) RuneSet {
	return &mapsetRuneSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) Union(other ReadOnlyRuneSet) RuneSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
		return &mapsetRuneSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyRuneSetMatchingRune(other))
	default:
		return s.Union(__emptyRuneSetMatchingRune(s))
	}
}

func (s *mapsetRuneSet) Pop() rune {
	var def rune
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToRune(i)
}

func (s *mapsetRuneSet) PowerSet() RuneSet {
	return &mapsetRuneSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) CartesianProduct(other ReadOnlyRuneSet) RuneSet {
	other = __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other)
	return &mapsetRuneSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetRuneSet) ToSlice() []rune {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToRuneSlice(s.ms.ToSlice())
}

func (s *mapsetRuneSet) NotEmptyAndContains(item rune) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetRuneSet) NotEmptyAndNotContains(item rune) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetRuneSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetRuneSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetRuneSet) AddItems(items ...rune) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewRuneSet(items ...rune) RuneSet {
	return newMapsetRuneSet(items...)
}

func newMapsetRuneSet(items ...rune) *mapsetRuneSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetRuneSet{ms: ms, isThreadSafe: true}
}

// NewRuneSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewRuneSetFromSlice(s []rune) RuneSet {
	i := __convertRuneSliceToInterfaceSlice(s)
	return &mapsetRuneSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeRuneSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeRuneSet(i ...rune) RuneSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetRuneSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeRuneSetFromSlice(s []rune) RuneSet {
	i := __convertRuneSliceToInterfaceSlice(s)
	return &mapsetRuneSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeRuneSet(other ReadOnlyRuneSet) ReadOnlyRuneSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewRuneSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeRuneSet(other ReadOnlyRuneSet) ReadOnlyRuneSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeRuneSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeRuneSetMatchingCopyIfEnabled(s, other ReadOnlyRuneSet) ReadOnlyRuneSet {
	if !__RuneSetReceiverAutoConvertComparisonRuneSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeRuneSet(other)
	}

	return __ensureThreadUnsafeRuneSet(other)
}

func __convertRuneSliceToInterfaceSlice(typeSlice []rune) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToRune(item interface{}) rune {
	t, ok := item.(rune)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToRuneSlice(interfaceSlice []interface{}) []rune {
	typeSlice := make([]rune, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToRune(item)
	}
	return typeSlice
}

func __emptyRuneSetMatchingRune(s ReadOnlyRuneSet) ReadOnlyRuneSet {
	if s.IsThreadSafe() {
		return __emptyRuneSet
	} else {
		return __emptyThreadUnsafeRuneSet
	}
}

var __emptyRuneSet = NewRuneSet()
var __emptyThreadUnsafeRuneSet = NewThreadUnsafeRuneSet()

// reset these in an init in the dest package if you dont want the defaults
var __UintptrSetReceiverAutoConvertComparisonUintptrSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUintptrSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUintptrSet or UintptrSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __UintptrSetReceiverAutoConvertComparisonUintptrSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that UintptrSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() UintptrSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uintptr) bool

	// Returns if the given item is not in the set
	NotContains(i uintptr) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uintptr) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uintptr) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uintptr) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUintptrSet) UintptrSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUintptrSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUintptrSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUintptrSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUintptrSet) UintptrSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUintptrSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUintptrSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUintptrSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUintptrSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUintptrSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uintptr) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUintptrSet) UintptrSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUintptrSet) UintptrSet
	// Returns the members of the set as a slice.
	ToSlice() []uintptr

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uintptr) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uintptr) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUintptrSet) UintptrSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() UintptrSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUintptrSet() and NewUintptrSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUintptrSet(0 and NewThreadUnsafeUintptrSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type UintptrSet interface {
	ReadOnlyUintptrSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uintptr) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uintptr) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uintptr)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uintptr
}

type mapsetUintptrSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUintptrSet) NotContains(i uintptr) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUintptrSet) NotContainsAny(tt ...uintptr) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUintptrSet) Nil() bool {
	return s == nil
}

func (s *mapsetUintptrSet) NotNil() bool {
	return s != nil
}

func (s *mapsetUintptrSet) IsDisjoint(other ReadOnlyUintptrSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUintptrSet) Intersects(o ReadOnlyUintptrSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUintptrSet) ContainsAny(items ...uintptr) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUintptrSet) ContainsAll(i ...uintptr) bool {
	return s.Contains(i...)
}

func (s *mapsetUintptrSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUintptrSet) Add(i uintptr) bool {
	return s.ms.Add(i)
}

func (s *mapsetUintptrSet) AddAll(il ...uintptr) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUintptrSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUintptrSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUintptrSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetUintptrSet) Clone() UintptrSet {
	if s == nil {
		return nil
	}
	return &mapsetUintptrSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) Contains(t ...uintptr) bool {
	if s == nil {
		return false
	}
	i := __convertUintptrSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUintptrSet) Difference(other ReadOnlyUintptrSet) UintptrSet {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return &mapsetUintptrSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) Equal(other ReadOnlyUintptrSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUintptrSet) NotEqual(other ReadOnlyUintptrSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUintptrSet) Intersect(other ReadOnlyUintptrSet) UintptrSet {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUintptrSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) IsProperSubset(other ReadOnlyUintptrSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUintptrSet) IsProperSuperset(other ReadOnlyUintptrSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUintptrSet) IsSubset(other ReadOnlyUintptrSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUintptrSet) IsSuperset(other ReadOnlyUintptrSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUintptrSet) Each(f func(uintptr) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uintptr)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUintptrSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUintptrSet) Remove(i uintptr) {
	s.ms.Remove(i)
}

func (s *mapsetUintptrSet) String() string {
	return s.ms.String()
}

func (s *mapsetUintptrSet) SymmetricDifference(other ReadOnlyUintptrSet) UintptrSet {
	return &mapsetUintptrSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) Union(other ReadOnlyUintptrSet) UintptrSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
		return &mapsetUintptrSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUintptrSetMatchingUintptr(other))
	default:
		return s.Union(__emptyUintptrSetMatchingUintptr(s))
	}
}

func (s *mapsetUintptrSet) Pop() uintptr {
	var def uintptr
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUintptr(i)
}

func (s *mapsetUintptrSet) PowerSet() UintptrSet {
	return &mapsetUintptrSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) CartesianProduct(other ReadOnlyUintptrSet) UintptrSet {
	other = __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other)
	return &mapsetUintptrSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintptrSet) ToSlice() []uintptr {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUintptrSlice(s.ms.ToSlice())
}

func (s *mapsetUintptrSet) NotEmptyAndContains(item uintptr) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUintptrSet) NotEmptyAndNotContains(item uintptr) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUintptrSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUintptrSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUintptrSet) AddItems(items ...uintptr) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUintptrSet(items ...uintptr) UintptrSet {
	return newMapsetUintptrSet(items...)
}

func newMapsetUintptrSet(items ...uintptr) *mapsetUintptrSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUintptrSet{ms: ms, isThreadSafe: true}
}

// NewUintptrSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUintptrSetFromSlice(s []uintptr) UintptrSet {
	i := __convertUintptrSliceToInterfaceSlice(s)
	return &mapsetUintptrSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUintptrSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUintptrSet(i ...uintptr) UintptrSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUintptrSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUintptrSetFromSlice(s []uintptr) UintptrSet {
	i := __convertUintptrSliceToInterfaceSlice(s)
	return &mapsetUintptrSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUintptrSet(other ReadOnlyUintptrSet) ReadOnlyUintptrSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewUintptrSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUintptrSet(other ReadOnlyUintptrSet) ReadOnlyUintptrSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUintptrSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUintptrSetMatchingCopyIfEnabled(s, other ReadOnlyUintptrSet) ReadOnlyUintptrSet {
	if !__UintptrSetReceiverAutoConvertComparisonUintptrSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUintptrSet(other)
	}

	return __ensureThreadUnsafeUintptrSet(other)
}

func __convertUintptrSliceToInterfaceSlice(typeSlice []uintptr) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUintptr(item interface{}) uintptr {
	t, ok := item.(uintptr)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUintptrSlice(interfaceSlice []interface{}) []uintptr {
	typeSlice := make([]uintptr, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUintptr(item)
	}
	return typeSlice
}

func __emptyUintptrSetMatchingUintptr(s ReadOnlyUintptrSet) ReadOnlyUintptrSet {
	if s.IsThreadSafe() {
		return __emptyUintptrSet
	} else {
		return __emptyThreadUnsafeUintptrSet
	}
}

var __emptyUintptrSet = NewUintptrSet()
var __emptyThreadUnsafeUintptrSet = NewThreadUnsafeUintptrSet()

// reset these in an init in the dest package if you dont want the defaults
var __BoolSetReceiverAutoConvertComparisonBoolSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyBoolSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyBoolSet or BoolSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __BoolSetReceiverAutoConvertComparisonBoolSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that BoolSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() BoolSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...bool) bool

	// Returns if the given item is not in the set
	NotContains(i bool) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...bool) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...bool) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...bool) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyBoolSet) BoolSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyBoolSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyBoolSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyBoolSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyBoolSet) BoolSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyBoolSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyBoolSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyBoolSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyBoolSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyBoolSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(bool) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyBoolSet) BoolSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyBoolSet) BoolSet
	// Returns the members of the set as a slice.
	ToSlice() []bool

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item bool) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item bool) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyBoolSet) BoolSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() BoolSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewBoolSet() and NewBoolSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeBoolSet(0 and NewThreadUnsafeBoolSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type BoolSet interface {
	ReadOnlyBoolSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i bool) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...bool) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i bool)

	// Pop removes and returns an arbitrary item from the set.
	Pop() bool
}

type mapsetBoolSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetBoolSet) NotContains(i bool) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetBoolSet) NotContainsAny(tt ...bool) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetBoolSet) Nil() bool {
	return s == nil
}

func (s *mapsetBoolSet) NotNil() bool {
	return s != nil
}

func (s *mapsetBoolSet) IsDisjoint(other ReadOnlyBoolSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetBoolSet) Intersects(o ReadOnlyBoolSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetBoolSet) ContainsAny(items ...bool) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetBoolSet) ContainsAll(i ...bool) bool {
	return s.Contains(i...)
}

func (s *mapsetBoolSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetBoolSet) Add(i bool) bool {
	return s.ms.Add(i)
}

func (s *mapsetBoolSet) AddAll(il ...bool) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetBoolSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetBoolSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetBoolSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetBoolSet) Clone() BoolSet {
	if s == nil {
		return nil
	}
	return &mapsetBoolSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) Contains(t ...bool) bool {
	if s == nil {
		return false
	}
	i := __convertBoolSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetBoolSet) Difference(other ReadOnlyBoolSet) BoolSet {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return &mapsetBoolSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) Equal(other ReadOnlyBoolSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetBoolSet) NotEqual(other ReadOnlyBoolSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetBoolSet) Intersect(other ReadOnlyBoolSet) BoolSet {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetBoolSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) IsProperSubset(other ReadOnlyBoolSet) bool {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetBoolSet) IsProperSuperset(other ReadOnlyBoolSet) bool {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetBoolSet) IsSubset(other ReadOnlyBoolSet) bool {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetBoolSet) IsSuperset(other ReadOnlyBoolSet) bool {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetBoolSet) Each(f func(bool) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(bool)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetBoolSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetBoolSet) Remove(i bool) {
	s.ms.Remove(i)
}

func (s *mapsetBoolSet) String() string {
	return s.ms.String()
}

func (s *mapsetBoolSet) SymmetricDifference(other ReadOnlyBoolSet) BoolSet {
	return &mapsetBoolSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) Union(other ReadOnlyBoolSet) BoolSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
		return &mapsetBoolSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyBoolSetMatchingBool(other))
	default:
		return s.Union(__emptyBoolSetMatchingBool(s))
	}
}

func (s *mapsetBoolSet) Pop() bool {
	var def bool
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToBool(i)
}

func (s *mapsetBoolSet) PowerSet() BoolSet {
	return &mapsetBoolSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) CartesianProduct(other ReadOnlyBoolSet) BoolSet {
	other = __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other)
	return &mapsetBoolSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetBoolSet) ToSlice() []bool {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToBoolSlice(s.ms.ToSlice())
}

func (s *mapsetBoolSet) NotEmptyAndContains(item bool) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetBoolSet) NotEmptyAndNotContains(item bool) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetBoolSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetBoolSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetBoolSet) AddItems(items ...bool) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewBoolSet(items ...bool) BoolSet {
	return newMapsetBoolSet(items...)
}

func newMapsetBoolSet(items ...bool) *mapsetBoolSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetBoolSet{ms: ms, isThreadSafe: true}
}

// NewBoolSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewBoolSetFromSlice(s []bool) BoolSet {
	i := __convertBoolSliceToInterfaceSlice(s)
	return &mapsetBoolSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeBoolSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeBoolSet(i ...bool) BoolSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetBoolSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeBoolSetFromSlice(s []bool) BoolSet {
	i := __convertBoolSliceToInterfaceSlice(s)
	return &mapsetBoolSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeBoolSet(other ReadOnlyBoolSet) ReadOnlyBoolSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewBoolSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeBoolSet(other ReadOnlyBoolSet) ReadOnlyBoolSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeBoolSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeBoolSetMatchingCopyIfEnabled(s, other ReadOnlyBoolSet) ReadOnlyBoolSet {
	if !__BoolSetReceiverAutoConvertComparisonBoolSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeBoolSet(other)
	}

	return __ensureThreadUnsafeBoolSet(other)
}

func __convertBoolSliceToInterfaceSlice(typeSlice []bool) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToBool(item interface{}) bool {
	t, ok := item.(bool)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToBoolSlice(interfaceSlice []interface{}) []bool {
	typeSlice := make([]bool, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToBool(item)
	}
	return typeSlice
}

func __emptyBoolSetMatchingBool(s ReadOnlyBoolSet) ReadOnlyBoolSet {
	if s.IsThreadSafe() {
		return __emptyBoolSet
	} else {
		return __emptyThreadUnsafeBoolSet
	}
}

var __emptyBoolSet = NewBoolSet()
var __emptyThreadUnsafeBoolSet = NewThreadUnsafeBoolSet()

// reset these in an init in the dest package if you dont want the defaults
var __UintSetReceiverAutoConvertComparisonUintSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUintSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUintSet or UintSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __UintSetReceiverAutoConvertComparisonUintSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that UintSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() UintSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uint) bool

	// Returns if the given item is not in the set
	NotContains(i uint) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uint) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uint) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uint) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUintSet) UintSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUintSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUintSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUintSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUintSet) UintSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUintSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUintSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUintSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUintSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUintSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uint) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUintSet) UintSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUintSet) UintSet
	// Returns the members of the set as a slice.
	ToSlice() []uint

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uint) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uint) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUintSet) UintSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() UintSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUintSet() and NewUintSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUintSet(0 and NewThreadUnsafeUintSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type UintSet interface {
	ReadOnlyUintSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uint) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uint) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uint)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uint
}

type mapsetUintSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUintSet) NotContains(i uint) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUintSet) NotContainsAny(tt ...uint) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUintSet) Nil() bool {
	return s == nil
}

func (s *mapsetUintSet) NotNil() bool {
	return s != nil
}

func (s *mapsetUintSet) IsDisjoint(other ReadOnlyUintSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUintSet) Intersects(o ReadOnlyUintSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUintSet) ContainsAny(items ...uint) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUintSet) ContainsAll(i ...uint) bool {
	return s.Contains(i...)
}

func (s *mapsetUintSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUintSet) Add(i uint) bool {
	return s.ms.Add(i)
}

func (s *mapsetUintSet) AddAll(il ...uint) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUintSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUintSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUintSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetUintSet) Clone() UintSet {
	if s == nil {
		return nil
	}
	return &mapsetUintSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) Contains(t ...uint) bool {
	if s == nil {
		return false
	}
	i := __convertUintSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUintSet) Difference(other ReadOnlyUintSet) UintSet {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return &mapsetUintSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) Equal(other ReadOnlyUintSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUintSet) NotEqual(other ReadOnlyUintSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUintSet) Intersect(other ReadOnlyUintSet) UintSet {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUintSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) IsProperSubset(other ReadOnlyUintSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUintSet) IsProperSuperset(other ReadOnlyUintSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUintSet) IsSubset(other ReadOnlyUintSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUintSet) IsSuperset(other ReadOnlyUintSet) bool {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUintSet) Each(f func(uint) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uint)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUintSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUintSet) Remove(i uint) {
	s.ms.Remove(i)
}

func (s *mapsetUintSet) String() string {
	return s.ms.String()
}

func (s *mapsetUintSet) SymmetricDifference(other ReadOnlyUintSet) UintSet {
	return &mapsetUintSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) Union(other ReadOnlyUintSet) UintSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
		return &mapsetUintSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUintSetMatchingUint(other))
	default:
		return s.Union(__emptyUintSetMatchingUint(s))
	}
}

func (s *mapsetUintSet) Pop() uint {
	var def uint
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUint(i)
}

func (s *mapsetUintSet) PowerSet() UintSet {
	return &mapsetUintSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) CartesianProduct(other ReadOnlyUintSet) UintSet {
	other = __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other)
	return &mapsetUintSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUintSet) ToSlice() []uint {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUintSlice(s.ms.ToSlice())
}

func (s *mapsetUintSet) NotEmptyAndContains(item uint) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUintSet) NotEmptyAndNotContains(item uint) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUintSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUintSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUintSet) AddItems(items ...uint) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUintSet(items ...uint) UintSet {
	return newMapsetUintSet(items...)
}

func newMapsetUintSet(items ...uint) *mapsetUintSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUintSet{ms: ms, isThreadSafe: true}
}

// NewUintSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUintSetFromSlice(s []uint) UintSet {
	i := __convertUintSliceToInterfaceSlice(s)
	return &mapsetUintSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUintSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUintSet(i ...uint) UintSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUintSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUintSetFromSlice(s []uint) UintSet {
	i := __convertUintSliceToInterfaceSlice(s)
	return &mapsetUintSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUintSet(other ReadOnlyUintSet) ReadOnlyUintSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewUintSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUintSet(other ReadOnlyUintSet) ReadOnlyUintSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUintSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUintSetMatchingCopyIfEnabled(s, other ReadOnlyUintSet) ReadOnlyUintSet {
	if !__UintSetReceiverAutoConvertComparisonUintSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUintSet(other)
	}

	return __ensureThreadUnsafeUintSet(other)
}

func __convertUintSliceToInterfaceSlice(typeSlice []uint) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUint(item interface{}) uint {
	t, ok := item.(uint)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUintSlice(interfaceSlice []interface{}) []uint {
	typeSlice := make([]uint, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUint(item)
	}
	return typeSlice
}

func __emptyUintSetMatchingUint(s ReadOnlyUintSet) ReadOnlyUintSet {
	if s.IsThreadSafe() {
		return __emptyUintSet
	} else {
		return __emptyThreadUnsafeUintSet
	}
}

var __emptyUintSet = NewUintSet()
var __emptyThreadUnsafeUintSet = NewThreadUnsafeUintSet()

// reset these in an init in the dest package if you dont want the defaults
var __Uint8SetReceiverAutoConvertComparisonUint8SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUint8Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUint8Set or Uint8Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Uint8SetReceiverAutoConvertComparisonUint8SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Uint8Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Uint8Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uint8) bool

	// Returns if the given item is not in the set
	NotContains(i uint8) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uint8) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uint8) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uint8) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUint8Set) Uint8Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUint8Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUint8Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUint8Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUint8Set) Uint8Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUint8Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUint8Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUint8Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUint8Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUint8Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uint8) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUint8Set) Uint8Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUint8Set) Uint8Set
	// Returns the members of the set as a slice.
	ToSlice() []uint8

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uint8) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uint8) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUint8Set) Uint8Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Uint8Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUint8Set() and NewUint8SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUint8Set(0 and NewThreadUnsafeUint8SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Uint8Set interface {
	ReadOnlyUint8Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uint8) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uint8) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uint8)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uint8
}

type mapsetUint8Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUint8Set) NotContains(i uint8) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUint8Set) NotContainsAny(tt ...uint8) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUint8Set) Nil() bool {
	return s == nil
}

func (s *mapsetUint8Set) NotNil() bool {
	return s != nil
}

func (s *mapsetUint8Set) IsDisjoint(other ReadOnlyUint8Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUint8Set) Intersects(o ReadOnlyUint8Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUint8Set) ContainsAny(items ...uint8) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUint8Set) ContainsAll(i ...uint8) bool {
	return s.Contains(i...)
}

func (s *mapsetUint8Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUint8Set) Add(i uint8) bool {
	return s.ms.Add(i)
}

func (s *mapsetUint8Set) AddAll(il ...uint8) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUint8Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint8Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint8Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetUint8Set) Clone() Uint8Set {
	if s == nil {
		return nil
	}
	return &mapsetUint8Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) Contains(t ...uint8) bool {
	if s == nil {
		return false
	}
	i := __convertUint8SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUint8Set) Difference(other ReadOnlyUint8Set) Uint8Set {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint8Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) Equal(other ReadOnlyUint8Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint8Set) NotEqual(other ReadOnlyUint8Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint8Set) Intersect(other ReadOnlyUint8Set) Uint8Set {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUint8Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) IsProperSubset(other ReadOnlyUint8Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUint8Set) IsProperSuperset(other ReadOnlyUint8Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUint8Set) IsSubset(other ReadOnlyUint8Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUint8Set) IsSuperset(other ReadOnlyUint8Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUint8Set) Each(f func(uint8) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uint8)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUint8Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUint8Set) Remove(i uint8) {
	s.ms.Remove(i)
}

func (s *mapsetUint8Set) String() string {
	return s.ms.String()
}

func (s *mapsetUint8Set) SymmetricDifference(other ReadOnlyUint8Set) Uint8Set {
	return &mapsetUint8Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) Union(other ReadOnlyUint8Set) Uint8Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
		return &mapsetUint8Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUint8SetMatchingUint8(other))
	default:
		return s.Union(__emptyUint8SetMatchingUint8(s))
	}
}

func (s *mapsetUint8Set) Pop() uint8 {
	var def uint8
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUint8(i)
}

func (s *mapsetUint8Set) PowerSet() Uint8Set {
	return &mapsetUint8Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) CartesianProduct(other ReadOnlyUint8Set) Uint8Set {
	other = __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint8Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint8Set) ToSlice() []uint8 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUint8Slice(s.ms.ToSlice())
}

func (s *mapsetUint8Set) NotEmptyAndContains(item uint8) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUint8Set) NotEmptyAndNotContains(item uint8) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUint8Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUint8Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUint8Set) AddItems(items ...uint8) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUint8Set(items ...uint8) Uint8Set {
	return newMapsetUint8Set(items...)
}

func newMapsetUint8Set(items ...uint8) *mapsetUint8Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUint8Set{ms: ms, isThreadSafe: true}
}

// NewUint8SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUint8SetFromSlice(s []uint8) Uint8Set {
	i := __convertUint8SliceToInterfaceSlice(s)
	return &mapsetUint8Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUint8Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUint8Set(i ...uint8) Uint8Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUint8Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUint8SetFromSlice(s []uint8) Uint8Set {
	i := __convertUint8SliceToInterfaceSlice(s)
	return &mapsetUint8Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUint8Set(other ReadOnlyUint8Set) ReadOnlyUint8Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewUint8SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUint8Set(other ReadOnlyUint8Set) ReadOnlyUint8Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUint8SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUint8SetMatchingCopyIfEnabled(s, other ReadOnlyUint8Set) ReadOnlyUint8Set {
	if !__Uint8SetReceiverAutoConvertComparisonUint8SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUint8Set(other)
	}

	return __ensureThreadUnsafeUint8Set(other)
}

func __convertUint8SliceToInterfaceSlice(typeSlice []uint8) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUint8(item interface{}) uint8 {
	t, ok := item.(uint8)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUint8Slice(interfaceSlice []interface{}) []uint8 {
	typeSlice := make([]uint8, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUint8(item)
	}
	return typeSlice
}

func __emptyUint8SetMatchingUint8(s ReadOnlyUint8Set) ReadOnlyUint8Set {
	if s.IsThreadSafe() {
		return __emptyUint8Set
	} else {
		return __emptyThreadUnsafeUint8Set
	}
}

var __emptyUint8Set = NewUint8Set()
var __emptyThreadUnsafeUint8Set = NewThreadUnsafeUint8Set()

// reset these in an init in the dest package if you dont want the defaults
var __Uint16SetReceiverAutoConvertComparisonUint16SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUint16Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUint16Set or Uint16Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Uint16SetReceiverAutoConvertComparisonUint16SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Uint16Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Uint16Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uint16) bool

	// Returns if the given item is not in the set
	NotContains(i uint16) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uint16) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uint16) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uint16) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUint16Set) Uint16Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUint16Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUint16Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUint16Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUint16Set) Uint16Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUint16Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUint16Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUint16Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUint16Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUint16Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uint16) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUint16Set) Uint16Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUint16Set) Uint16Set
	// Returns the members of the set as a slice.
	ToSlice() []uint16

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uint16) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uint16) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUint16Set) Uint16Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Uint16Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUint16Set() and NewUint16SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUint16Set(0 and NewThreadUnsafeUint16SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Uint16Set interface {
	ReadOnlyUint16Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uint16) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uint16) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uint16)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uint16
}

type mapsetUint16Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUint16Set) NotContains(i uint16) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUint16Set) NotContainsAny(tt ...uint16) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUint16Set) Nil() bool {
	return s == nil
}

func (s *mapsetUint16Set) NotNil() bool {
	return s != nil
}

func (s *mapsetUint16Set) IsDisjoint(other ReadOnlyUint16Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUint16Set) Intersects(o ReadOnlyUint16Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUint16Set) ContainsAny(items ...uint16) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUint16Set) ContainsAll(i ...uint16) bool {
	return s.Contains(i...)
}

func (s *mapsetUint16Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUint16Set) Add(i uint16) bool {
	return s.ms.Add(i)
}

func (s *mapsetUint16Set) AddAll(il ...uint16) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUint16Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint16Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint16Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetUint16Set) Clone() Uint16Set {
	if s == nil {
		return nil
	}
	return &mapsetUint16Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) Contains(t ...uint16) bool {
	if s == nil {
		return false
	}
	i := __convertUint16SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUint16Set) Difference(other ReadOnlyUint16Set) Uint16Set {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint16Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) Equal(other ReadOnlyUint16Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint16Set) NotEqual(other ReadOnlyUint16Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint16Set) Intersect(other ReadOnlyUint16Set) Uint16Set {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUint16Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) IsProperSubset(other ReadOnlyUint16Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUint16Set) IsProperSuperset(other ReadOnlyUint16Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUint16Set) IsSubset(other ReadOnlyUint16Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUint16Set) IsSuperset(other ReadOnlyUint16Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUint16Set) Each(f func(uint16) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uint16)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUint16Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUint16Set) Remove(i uint16) {
	s.ms.Remove(i)
}

func (s *mapsetUint16Set) String() string {
	return s.ms.String()
}

func (s *mapsetUint16Set) SymmetricDifference(other ReadOnlyUint16Set) Uint16Set {
	return &mapsetUint16Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) Union(other ReadOnlyUint16Set) Uint16Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
		return &mapsetUint16Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUint16SetMatchingUint16(other))
	default:
		return s.Union(__emptyUint16SetMatchingUint16(s))
	}
}

func (s *mapsetUint16Set) Pop() uint16 {
	var def uint16
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUint16(i)
}

func (s *mapsetUint16Set) PowerSet() Uint16Set {
	return &mapsetUint16Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) CartesianProduct(other ReadOnlyUint16Set) Uint16Set {
	other = __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint16Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint16Set) ToSlice() []uint16 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUint16Slice(s.ms.ToSlice())
}

func (s *mapsetUint16Set) NotEmptyAndContains(item uint16) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUint16Set) NotEmptyAndNotContains(item uint16) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUint16Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUint16Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUint16Set) AddItems(items ...uint16) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUint16Set(items ...uint16) Uint16Set {
	return newMapsetUint16Set(items...)
}

func newMapsetUint16Set(items ...uint16) *mapsetUint16Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUint16Set{ms: ms, isThreadSafe: true}
}

// NewUint16SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUint16SetFromSlice(s []uint16) Uint16Set {
	i := __convertUint16SliceToInterfaceSlice(s)
	return &mapsetUint16Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUint16Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUint16Set(i ...uint16) Uint16Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUint16Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUint16SetFromSlice(s []uint16) Uint16Set {
	i := __convertUint16SliceToInterfaceSlice(s)
	return &mapsetUint16Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUint16Set(other ReadOnlyUint16Set) ReadOnlyUint16Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewUint16SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUint16Set(other ReadOnlyUint16Set) ReadOnlyUint16Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUint16SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUint16SetMatchingCopyIfEnabled(s, other ReadOnlyUint16Set) ReadOnlyUint16Set {
	if !__Uint16SetReceiverAutoConvertComparisonUint16SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUint16Set(other)
	}

	return __ensureThreadUnsafeUint16Set(other)
}

func __convertUint16SliceToInterfaceSlice(typeSlice []uint16) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUint16(item interface{}) uint16 {
	t, ok := item.(uint16)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUint16Slice(interfaceSlice []interface{}) []uint16 {
	typeSlice := make([]uint16, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUint16(item)
	}
	return typeSlice
}

func __emptyUint16SetMatchingUint16(s ReadOnlyUint16Set) ReadOnlyUint16Set {
	if s.IsThreadSafe() {
		return __emptyUint16Set
	} else {
		return __emptyThreadUnsafeUint16Set
	}
}

var __emptyUint16Set = NewUint16Set()
var __emptyThreadUnsafeUint16Set = NewThreadUnsafeUint16Set()

// reset these in an init in the dest package if you dont want the defaults
var __Uint32SetReceiverAutoConvertComparisonUint32SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUint32Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUint32Set or Uint32Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Uint32SetReceiverAutoConvertComparisonUint32SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Uint32Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Uint32Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uint32) bool

	// Returns if the given item is not in the set
	NotContains(i uint32) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uint32) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uint32) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uint32) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUint32Set) Uint32Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUint32Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUint32Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUint32Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUint32Set) Uint32Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUint32Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUint32Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUint32Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUint32Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUint32Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uint32) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUint32Set) Uint32Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUint32Set) Uint32Set
	// Returns the members of the set as a slice.
	ToSlice() []uint32

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uint32) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uint32) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUint32Set) Uint32Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Uint32Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUint32Set() and NewUint32SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUint32Set(0 and NewThreadUnsafeUint32SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Uint32Set interface {
	ReadOnlyUint32Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uint32) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uint32) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uint32)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uint32
}

type mapsetUint32Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUint32Set) NotContains(i uint32) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUint32Set) NotContainsAny(tt ...uint32) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUint32Set) Nil() bool {
	return s == nil
}

func (s *mapsetUint32Set) NotNil() bool {
	return s != nil
}

func (s *mapsetUint32Set) IsDisjoint(other ReadOnlyUint32Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUint32Set) Intersects(o ReadOnlyUint32Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUint32Set) ContainsAny(items ...uint32) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUint32Set) ContainsAll(i ...uint32) bool {
	return s.Contains(i...)
}

func (s *mapsetUint32Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUint32Set) Add(i uint32) bool {
	return s.ms.Add(i)
}

func (s *mapsetUint32Set) AddAll(il ...uint32) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUint32Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint32Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint32Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetUint32Set) Clone() Uint32Set {
	if s == nil {
		return nil
	}
	return &mapsetUint32Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) Contains(t ...uint32) bool {
	if s == nil {
		return false
	}
	i := __convertUint32SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUint32Set) Difference(other ReadOnlyUint32Set) Uint32Set {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint32Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) Equal(other ReadOnlyUint32Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint32Set) NotEqual(other ReadOnlyUint32Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint32Set) Intersect(other ReadOnlyUint32Set) Uint32Set {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUint32Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) IsProperSubset(other ReadOnlyUint32Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUint32Set) IsProperSuperset(other ReadOnlyUint32Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUint32Set) IsSubset(other ReadOnlyUint32Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUint32Set) IsSuperset(other ReadOnlyUint32Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUint32Set) Each(f func(uint32) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uint32)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUint32Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUint32Set) Remove(i uint32) {
	s.ms.Remove(i)
}

func (s *mapsetUint32Set) String() string {
	return s.ms.String()
}

func (s *mapsetUint32Set) SymmetricDifference(other ReadOnlyUint32Set) Uint32Set {
	return &mapsetUint32Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) Union(other ReadOnlyUint32Set) Uint32Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
		return &mapsetUint32Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUint32SetMatchingUint32(other))
	default:
		return s.Union(__emptyUint32SetMatchingUint32(s))
	}
}

func (s *mapsetUint32Set) Pop() uint32 {
	var def uint32
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUint32(i)
}

func (s *mapsetUint32Set) PowerSet() Uint32Set {
	return &mapsetUint32Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) CartesianProduct(other ReadOnlyUint32Set) Uint32Set {
	other = __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint32Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint32Set) ToSlice() []uint32 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUint32Slice(s.ms.ToSlice())
}

func (s *mapsetUint32Set) NotEmptyAndContains(item uint32) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUint32Set) NotEmptyAndNotContains(item uint32) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUint32Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUint32Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUint32Set) AddItems(items ...uint32) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUint32Set(items ...uint32) Uint32Set {
	return newMapsetUint32Set(items...)
}

func newMapsetUint32Set(items ...uint32) *mapsetUint32Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUint32Set{ms: ms, isThreadSafe: true}
}

// NewUint32SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUint32SetFromSlice(s []uint32) Uint32Set {
	i := __convertUint32SliceToInterfaceSlice(s)
	return &mapsetUint32Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUint32Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUint32Set(i ...uint32) Uint32Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUint32Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUint32SetFromSlice(s []uint32) Uint32Set {
	i := __convertUint32SliceToInterfaceSlice(s)
	return &mapsetUint32Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUint32Set(other ReadOnlyUint32Set) ReadOnlyUint32Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewUint32SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUint32Set(other ReadOnlyUint32Set) ReadOnlyUint32Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUint32SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUint32SetMatchingCopyIfEnabled(s, other ReadOnlyUint32Set) ReadOnlyUint32Set {
	if !__Uint32SetReceiverAutoConvertComparisonUint32SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUint32Set(other)
	}

	return __ensureThreadUnsafeUint32Set(other)
}

func __convertUint32SliceToInterfaceSlice(typeSlice []uint32) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUint32(item interface{}) uint32 {
	t, ok := item.(uint32)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUint32Slice(interfaceSlice []interface{}) []uint32 {
	typeSlice := make([]uint32, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUint32(item)
	}
	return typeSlice
}

func __emptyUint32SetMatchingUint32(s ReadOnlyUint32Set) ReadOnlyUint32Set {
	if s.IsThreadSafe() {
		return __emptyUint32Set
	} else {
		return __emptyThreadUnsafeUint32Set
	}
}

var __emptyUint32Set = NewUint32Set()
var __emptyThreadUnsafeUint32Set = NewThreadUnsafeUint32Set()

// reset these in an init in the dest package if you dont want the defaults
var __Uint64SetReceiverAutoConvertComparisonUint64SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyUint64Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyUint64Set or Uint64Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Uint64SetReceiverAutoConvertComparisonUint64SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Uint64Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Uint64Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...uint64) bool

	// Returns if the given item is not in the set
	NotContains(i uint64) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...uint64) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...uint64) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...uint64) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyUint64Set) Uint64Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyUint64Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyUint64Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyUint64Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyUint64Set) Uint64Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyUint64Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyUint64Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyUint64Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyUint64Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyUint64Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(uint64) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyUint64Set) Uint64Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyUint64Set) Uint64Set
	// Returns the members of the set as a slice.
	ToSlice() []uint64

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item uint64) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item uint64) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyUint64Set) Uint64Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Uint64Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewUint64Set() and NewUint64SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeUint64Set(0 and NewThreadUnsafeUint64SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Uint64Set interface {
	ReadOnlyUint64Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i uint64) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...uint64) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i uint64)

	// Pop removes and returns an arbitrary item from the set.
	Pop() uint64
}

type mapsetUint64Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetUint64Set) NotContains(i uint64) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetUint64Set) NotContainsAny(tt ...uint64) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetUint64Set) Nil() bool {
	return s == nil
}

func (s *mapsetUint64Set) NotNil() bool {
	return s != nil
}

func (s *mapsetUint64Set) IsDisjoint(other ReadOnlyUint64Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetUint64Set) Intersects(o ReadOnlyUint64Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetUint64Set) ContainsAny(items ...uint64) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetUint64Set) ContainsAll(i ...uint64) bool {
	return s.Contains(i...)
}

func (s *mapsetUint64Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetUint64Set) Add(i uint64) bool {
	return s.ms.Add(i)
}

func (s *mapsetUint64Set) AddAll(il ...uint64) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetUint64Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint64Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetUint64Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetUint64Set) Clone() Uint64Set {
	if s == nil {
		return nil
	}
	return &mapsetUint64Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) Contains(t ...uint64) bool {
	if s == nil {
		return false
	}
	i := __convertUint64SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetUint64Set) Difference(other ReadOnlyUint64Set) Uint64Set {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint64Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) Equal(other ReadOnlyUint64Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint64Set) NotEqual(other ReadOnlyUint64Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetUint64Set) Intersect(other ReadOnlyUint64Set) Uint64Set {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetUint64Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) IsProperSubset(other ReadOnlyUint64Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetUint64Set) IsProperSuperset(other ReadOnlyUint64Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetUint64Set) IsSubset(other ReadOnlyUint64Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetUint64Set) IsSuperset(other ReadOnlyUint64Set) bool {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetUint64Set) Each(f func(uint64) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(uint64)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetUint64Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetUint64Set) Remove(i uint64) {
	s.ms.Remove(i)
}

func (s *mapsetUint64Set) String() string {
	return s.ms.String()
}

func (s *mapsetUint64Set) SymmetricDifference(other ReadOnlyUint64Set) Uint64Set {
	return &mapsetUint64Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) Union(other ReadOnlyUint64Set) Uint64Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
		return &mapsetUint64Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyUint64SetMatchingUint64(other))
	default:
		return s.Union(__emptyUint64SetMatchingUint64(s))
	}
}

func (s *mapsetUint64Set) Pop() uint64 {
	var def uint64
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToUint64(i)
}

func (s *mapsetUint64Set) PowerSet() Uint64Set {
	return &mapsetUint64Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) CartesianProduct(other ReadOnlyUint64Set) Uint64Set {
	other = __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other)
	return &mapsetUint64Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetUint64Set) ToSlice() []uint64 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToUint64Slice(s.ms.ToSlice())
}

func (s *mapsetUint64Set) NotEmptyAndContains(item uint64) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetUint64Set) NotEmptyAndNotContains(item uint64) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetUint64Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetUint64Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetUint64Set) AddItems(items ...uint64) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewUint64Set(items ...uint64) Uint64Set {
	return newMapsetUint64Set(items...)
}

func newMapsetUint64Set(items ...uint64) *mapsetUint64Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetUint64Set{ms: ms, isThreadSafe: true}
}

// NewUint64SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewUint64SetFromSlice(s []uint64) Uint64Set {
	i := __convertUint64SliceToInterfaceSlice(s)
	return &mapsetUint64Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeUint64Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeUint64Set(i ...uint64) Uint64Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetUint64Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeUint64SetFromSlice(s []uint64) Uint64Set {
	i := __convertUint64SliceToInterfaceSlice(s)
	return &mapsetUint64Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeUint64Set(other ReadOnlyUint64Set) ReadOnlyUint64Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewUint64SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeUint64Set(other ReadOnlyUint64Set) ReadOnlyUint64Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeUint64SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeUint64SetMatchingCopyIfEnabled(s, other ReadOnlyUint64Set) ReadOnlyUint64Set {
	if !__Uint64SetReceiverAutoConvertComparisonUint64SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeUint64Set(other)
	}

	return __ensureThreadUnsafeUint64Set(other)
}

func __convertUint64SliceToInterfaceSlice(typeSlice []uint64) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToUint64(item interface{}) uint64 {
	t, ok := item.(uint64)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToUint64Slice(interfaceSlice []interface{}) []uint64 {
	typeSlice := make([]uint64, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToUint64(item)
	}
	return typeSlice
}

func __emptyUint64SetMatchingUint64(s ReadOnlyUint64Set) ReadOnlyUint64Set {
	if s.IsThreadSafe() {
		return __emptyUint64Set
	} else {
		return __emptyThreadUnsafeUint64Set
	}
}

var __emptyUint64Set = NewUint64Set()
var __emptyThreadUnsafeUint64Set = NewThreadUnsafeUint64Set()

// reset these in an init in the dest package if you dont want the defaults
var __IntSetReceiverAutoConvertComparisonIntSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyIntSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyIntSet or IntSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __IntSetReceiverAutoConvertComparisonIntSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that IntSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() IntSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...int) bool

	// Returns if the given item is not in the set
	NotContains(i int) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...int) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...int) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...int) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyIntSet) IntSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyIntSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyIntSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyIntSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyIntSet) IntSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyIntSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyIntSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyIntSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyIntSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyIntSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(int) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyIntSet) IntSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyIntSet) IntSet
	// Returns the members of the set as a slice.
	ToSlice() []int

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item int) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item int) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyIntSet) IntSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() IntSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewIntSet() and NewIntSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeIntSet(0 and NewThreadUnsafeIntSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type IntSet interface {
	ReadOnlyIntSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i int) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...int) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i int)

	// Pop removes and returns an arbitrary item from the set.
	Pop() int
}

type mapsetIntSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetIntSet) NotContains(i int) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetIntSet) NotContainsAny(tt ...int) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetIntSet) Nil() bool {
	return s == nil
}

func (s *mapsetIntSet) NotNil() bool {
	return s != nil
}

func (s *mapsetIntSet) IsDisjoint(other ReadOnlyIntSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetIntSet) Intersects(o ReadOnlyIntSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetIntSet) ContainsAny(items ...int) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetIntSet) ContainsAll(i ...int) bool {
	return s.Contains(i...)
}

func (s *mapsetIntSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetIntSet) Add(i int) bool {
	return s.ms.Add(i)
}

func (s *mapsetIntSet) AddAll(il ...int) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetIntSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetIntSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetIntSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetIntSet) Clone() IntSet {
	if s == nil {
		return nil
	}
	return &mapsetIntSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) Contains(t ...int) bool {
	if s == nil {
		return false
	}
	i := __convertIntSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetIntSet) Difference(other ReadOnlyIntSet) IntSet {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return &mapsetIntSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) Equal(other ReadOnlyIntSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetIntSet) NotEqual(other ReadOnlyIntSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetIntSet) Intersect(other ReadOnlyIntSet) IntSet {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetIntSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) IsProperSubset(other ReadOnlyIntSet) bool {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetIntSet) IsProperSuperset(other ReadOnlyIntSet) bool {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetIntSet) IsSubset(other ReadOnlyIntSet) bool {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetIntSet) IsSuperset(other ReadOnlyIntSet) bool {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetIntSet) Each(f func(int) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(int)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetIntSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetIntSet) Remove(i int) {
	s.ms.Remove(i)
}

func (s *mapsetIntSet) String() string {
	return s.ms.String()
}

func (s *mapsetIntSet) SymmetricDifference(other ReadOnlyIntSet) IntSet {
	return &mapsetIntSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) Union(other ReadOnlyIntSet) IntSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
		return &mapsetIntSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyIntSetMatchingInt(other))
	default:
		return s.Union(__emptyIntSetMatchingInt(s))
	}
}

func (s *mapsetIntSet) Pop() int {
	var def int
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInt(i)
}

func (s *mapsetIntSet) PowerSet() IntSet {
	return &mapsetIntSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) CartesianProduct(other ReadOnlyIntSet) IntSet {
	other = __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other)
	return &mapsetIntSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetIntSet) ToSlice() []int {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToIntSlice(s.ms.ToSlice())
}

func (s *mapsetIntSet) NotEmptyAndContains(item int) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetIntSet) NotEmptyAndNotContains(item int) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetIntSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetIntSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetIntSet) AddItems(items ...int) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewIntSet(items ...int) IntSet {
	return newMapsetIntSet(items...)
}

func newMapsetIntSet(items ...int) *mapsetIntSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetIntSet{ms: ms, isThreadSafe: true}
}

// NewIntSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewIntSetFromSlice(s []int) IntSet {
	i := __convertIntSliceToInterfaceSlice(s)
	return &mapsetIntSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeIntSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeIntSet(i ...int) IntSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetIntSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeIntSetFromSlice(s []int) IntSet {
	i := __convertIntSliceToInterfaceSlice(s)
	return &mapsetIntSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeIntSet(other ReadOnlyIntSet) ReadOnlyIntSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewIntSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeIntSet(other ReadOnlyIntSet) ReadOnlyIntSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeIntSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeIntSetMatchingCopyIfEnabled(s, other ReadOnlyIntSet) ReadOnlyIntSet {
	if !__IntSetReceiverAutoConvertComparisonIntSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeIntSet(other)
	}

	return __ensureThreadUnsafeIntSet(other)
}

func __convertIntSliceToInterfaceSlice(typeSlice []int) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInt(item interface{}) int {
	t, ok := item.(int)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToIntSlice(interfaceSlice []interface{}) []int {
	typeSlice := make([]int, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInt(item)
	}
	return typeSlice
}

func __emptyIntSetMatchingInt(s ReadOnlyIntSet) ReadOnlyIntSet {
	if s.IsThreadSafe() {
		return __emptyIntSet
	} else {
		return __emptyThreadUnsafeIntSet
	}
}

var __emptyIntSet = NewIntSet()
var __emptyThreadUnsafeIntSet = NewThreadUnsafeIntSet()

// reset these in an init in the dest package if you dont want the defaults
var __Int8SetReceiverAutoConvertComparisonInt8SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyInt8Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyInt8Set or Int8Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Int8SetReceiverAutoConvertComparisonInt8SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Int8Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Int8Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...int8) bool

	// Returns if the given item is not in the set
	NotContains(i int8) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...int8) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...int8) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...int8) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyInt8Set) Int8Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyInt8Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyInt8Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyInt8Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyInt8Set) Int8Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyInt8Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyInt8Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyInt8Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyInt8Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyInt8Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(int8) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyInt8Set) Int8Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyInt8Set) Int8Set
	// Returns the members of the set as a slice.
	ToSlice() []int8

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item int8) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item int8) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyInt8Set) Int8Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Int8Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewInt8Set() and NewInt8SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeInt8Set(0 and NewThreadUnsafeInt8SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Int8Set interface {
	ReadOnlyInt8Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i int8) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...int8) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i int8)

	// Pop removes and returns an arbitrary item from the set.
	Pop() int8
}

type mapsetInt8Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetInt8Set) NotContains(i int8) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetInt8Set) NotContainsAny(tt ...int8) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetInt8Set) Nil() bool {
	return s == nil
}

func (s *mapsetInt8Set) NotNil() bool {
	return s != nil
}

func (s *mapsetInt8Set) IsDisjoint(other ReadOnlyInt8Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetInt8Set) Intersects(o ReadOnlyInt8Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetInt8Set) ContainsAny(items ...int8) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetInt8Set) ContainsAll(i ...int8) bool {
	return s.Contains(i...)
}

func (s *mapsetInt8Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetInt8Set) Add(i int8) bool {
	return s.ms.Add(i)
}

func (s *mapsetInt8Set) AddAll(il ...int8) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetInt8Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt8Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt8Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetInt8Set) Clone() Int8Set {
	if s == nil {
		return nil
	}
	return &mapsetInt8Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) Contains(t ...int8) bool {
	if s == nil {
		return false
	}
	i := __convertInt8SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetInt8Set) Difference(other ReadOnlyInt8Set) Int8Set {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt8Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) Equal(other ReadOnlyInt8Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt8Set) NotEqual(other ReadOnlyInt8Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt8Set) Intersect(other ReadOnlyInt8Set) Int8Set {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetInt8Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) IsProperSubset(other ReadOnlyInt8Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetInt8Set) IsProperSuperset(other ReadOnlyInt8Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetInt8Set) IsSubset(other ReadOnlyInt8Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetInt8Set) IsSuperset(other ReadOnlyInt8Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetInt8Set) Each(f func(int8) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(int8)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetInt8Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetInt8Set) Remove(i int8) {
	s.ms.Remove(i)
}

func (s *mapsetInt8Set) String() string {
	return s.ms.String()
}

func (s *mapsetInt8Set) SymmetricDifference(other ReadOnlyInt8Set) Int8Set {
	return &mapsetInt8Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) Union(other ReadOnlyInt8Set) Int8Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
		return &mapsetInt8Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyInt8SetMatchingInt8(other))
	default:
		return s.Union(__emptyInt8SetMatchingInt8(s))
	}
}

func (s *mapsetInt8Set) Pop() int8 {
	var def int8
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInt8(i)
}

func (s *mapsetInt8Set) PowerSet() Int8Set {
	return &mapsetInt8Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) CartesianProduct(other ReadOnlyInt8Set) Int8Set {
	other = __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt8Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt8Set) ToSlice() []int8 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToInt8Slice(s.ms.ToSlice())
}

func (s *mapsetInt8Set) NotEmptyAndContains(item int8) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetInt8Set) NotEmptyAndNotContains(item int8) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetInt8Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetInt8Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetInt8Set) AddItems(items ...int8) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewInt8Set(items ...int8) Int8Set {
	return newMapsetInt8Set(items...)
}

func newMapsetInt8Set(items ...int8) *mapsetInt8Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetInt8Set{ms: ms, isThreadSafe: true}
}

// NewInt8SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewInt8SetFromSlice(s []int8) Int8Set {
	i := __convertInt8SliceToInterfaceSlice(s)
	return &mapsetInt8Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeInt8Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeInt8Set(i ...int8) Int8Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetInt8Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeInt8SetFromSlice(s []int8) Int8Set {
	i := __convertInt8SliceToInterfaceSlice(s)
	return &mapsetInt8Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeInt8Set(other ReadOnlyInt8Set) ReadOnlyInt8Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewInt8SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeInt8Set(other ReadOnlyInt8Set) ReadOnlyInt8Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeInt8SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeInt8SetMatchingCopyIfEnabled(s, other ReadOnlyInt8Set) ReadOnlyInt8Set {
	if !__Int8SetReceiverAutoConvertComparisonInt8SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeInt8Set(other)
	}

	return __ensureThreadUnsafeInt8Set(other)
}

func __convertInt8SliceToInterfaceSlice(typeSlice []int8) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInt8(item interface{}) int8 {
	t, ok := item.(int8)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToInt8Slice(interfaceSlice []interface{}) []int8 {
	typeSlice := make([]int8, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInt8(item)
	}
	return typeSlice
}

func __emptyInt8SetMatchingInt8(s ReadOnlyInt8Set) ReadOnlyInt8Set {
	if s.IsThreadSafe() {
		return __emptyInt8Set
	} else {
		return __emptyThreadUnsafeInt8Set
	}
}

var __emptyInt8Set = NewInt8Set()
var __emptyThreadUnsafeInt8Set = NewThreadUnsafeInt8Set()

// reset these in an init in the dest package if you dont want the defaults
var __Int16SetReceiverAutoConvertComparisonInt16SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyInt16Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyInt16Set or Int16Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Int16SetReceiverAutoConvertComparisonInt16SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Int16Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Int16Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...int16) bool

	// Returns if the given item is not in the set
	NotContains(i int16) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...int16) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...int16) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...int16) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyInt16Set) Int16Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyInt16Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyInt16Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyInt16Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyInt16Set) Int16Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyInt16Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyInt16Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyInt16Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyInt16Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyInt16Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(int16) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyInt16Set) Int16Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyInt16Set) Int16Set
	// Returns the members of the set as a slice.
	ToSlice() []int16

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item int16) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item int16) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyInt16Set) Int16Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Int16Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewInt16Set() and NewInt16SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeInt16Set(0 and NewThreadUnsafeInt16SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Int16Set interface {
	ReadOnlyInt16Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i int16) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...int16) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i int16)

	// Pop removes and returns an arbitrary item from the set.
	Pop() int16
}

type mapsetInt16Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetInt16Set) NotContains(i int16) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetInt16Set) NotContainsAny(tt ...int16) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetInt16Set) Nil() bool {
	return s == nil
}

func (s *mapsetInt16Set) NotNil() bool {
	return s != nil
}

func (s *mapsetInt16Set) IsDisjoint(other ReadOnlyInt16Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetInt16Set) Intersects(o ReadOnlyInt16Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetInt16Set) ContainsAny(items ...int16) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetInt16Set) ContainsAll(i ...int16) bool {
	return s.Contains(i...)
}

func (s *mapsetInt16Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetInt16Set) Add(i int16) bool {
	return s.ms.Add(i)
}

func (s *mapsetInt16Set) AddAll(il ...int16) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetInt16Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt16Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt16Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetInt16Set) Clone() Int16Set {
	if s == nil {
		return nil
	}
	return &mapsetInt16Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) Contains(t ...int16) bool {
	if s == nil {
		return false
	}
	i := __convertInt16SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetInt16Set) Difference(other ReadOnlyInt16Set) Int16Set {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt16Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) Equal(other ReadOnlyInt16Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt16Set) NotEqual(other ReadOnlyInt16Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt16Set) Intersect(other ReadOnlyInt16Set) Int16Set {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetInt16Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) IsProperSubset(other ReadOnlyInt16Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetInt16Set) IsProperSuperset(other ReadOnlyInt16Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetInt16Set) IsSubset(other ReadOnlyInt16Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetInt16Set) IsSuperset(other ReadOnlyInt16Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetInt16Set) Each(f func(int16) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(int16)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetInt16Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetInt16Set) Remove(i int16) {
	s.ms.Remove(i)
}

func (s *mapsetInt16Set) String() string {
	return s.ms.String()
}

func (s *mapsetInt16Set) SymmetricDifference(other ReadOnlyInt16Set) Int16Set {
	return &mapsetInt16Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) Union(other ReadOnlyInt16Set) Int16Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
		return &mapsetInt16Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyInt16SetMatchingInt16(other))
	default:
		return s.Union(__emptyInt16SetMatchingInt16(s))
	}
}

func (s *mapsetInt16Set) Pop() int16 {
	var def int16
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInt16(i)
}

func (s *mapsetInt16Set) PowerSet() Int16Set {
	return &mapsetInt16Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) CartesianProduct(other ReadOnlyInt16Set) Int16Set {
	other = __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt16Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt16Set) ToSlice() []int16 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToInt16Slice(s.ms.ToSlice())
}

func (s *mapsetInt16Set) NotEmptyAndContains(item int16) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetInt16Set) NotEmptyAndNotContains(item int16) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetInt16Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetInt16Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetInt16Set) AddItems(items ...int16) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewInt16Set(items ...int16) Int16Set {
	return newMapsetInt16Set(items...)
}

func newMapsetInt16Set(items ...int16) *mapsetInt16Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetInt16Set{ms: ms, isThreadSafe: true}
}

// NewInt16SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewInt16SetFromSlice(s []int16) Int16Set {
	i := __convertInt16SliceToInterfaceSlice(s)
	return &mapsetInt16Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeInt16Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeInt16Set(i ...int16) Int16Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetInt16Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeInt16SetFromSlice(s []int16) Int16Set {
	i := __convertInt16SliceToInterfaceSlice(s)
	return &mapsetInt16Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeInt16Set(other ReadOnlyInt16Set) ReadOnlyInt16Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewInt16SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeInt16Set(other ReadOnlyInt16Set) ReadOnlyInt16Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeInt16SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeInt16SetMatchingCopyIfEnabled(s, other ReadOnlyInt16Set) ReadOnlyInt16Set {
	if !__Int16SetReceiverAutoConvertComparisonInt16SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeInt16Set(other)
	}

	return __ensureThreadUnsafeInt16Set(other)
}

func __convertInt16SliceToInterfaceSlice(typeSlice []int16) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInt16(item interface{}) int16 {
	t, ok := item.(int16)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToInt16Slice(interfaceSlice []interface{}) []int16 {
	typeSlice := make([]int16, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInt16(item)
	}
	return typeSlice
}

func __emptyInt16SetMatchingInt16(s ReadOnlyInt16Set) ReadOnlyInt16Set {
	if s.IsThreadSafe() {
		return __emptyInt16Set
	} else {
		return __emptyThreadUnsafeInt16Set
	}
}

var __emptyInt16Set = NewInt16Set()
var __emptyThreadUnsafeInt16Set = NewThreadUnsafeInt16Set()

// reset these in an init in the dest package if you dont want the defaults
var __Int32SetReceiverAutoConvertComparisonInt32SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyInt32Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyInt32Set or Int32Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Int32SetReceiverAutoConvertComparisonInt32SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Int32Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Int32Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...int32) bool

	// Returns if the given item is not in the set
	NotContains(i int32) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...int32) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...int32) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...int32) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyInt32Set) Int32Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyInt32Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyInt32Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyInt32Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyInt32Set) Int32Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyInt32Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyInt32Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyInt32Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyInt32Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyInt32Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(int32) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyInt32Set) Int32Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyInt32Set) Int32Set
	// Returns the members of the set as a slice.
	ToSlice() []int32

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item int32) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item int32) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyInt32Set) Int32Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Int32Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewInt32Set() and NewInt32SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeInt32Set(0 and NewThreadUnsafeInt32SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Int32Set interface {
	ReadOnlyInt32Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i int32) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...int32) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i int32)

	// Pop removes and returns an arbitrary item from the set.
	Pop() int32
}

type mapsetInt32Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetInt32Set) NotContains(i int32) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetInt32Set) NotContainsAny(tt ...int32) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetInt32Set) Nil() bool {
	return s == nil
}

func (s *mapsetInt32Set) NotNil() bool {
	return s != nil
}

func (s *mapsetInt32Set) IsDisjoint(other ReadOnlyInt32Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetInt32Set) Intersects(o ReadOnlyInt32Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetInt32Set) ContainsAny(items ...int32) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetInt32Set) ContainsAll(i ...int32) bool {
	return s.Contains(i...)
}

func (s *mapsetInt32Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetInt32Set) Add(i int32) bool {
	return s.ms.Add(i)
}

func (s *mapsetInt32Set) AddAll(il ...int32) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetInt32Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt32Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt32Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetInt32Set) Clone() Int32Set {
	if s == nil {
		return nil
	}
	return &mapsetInt32Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) Contains(t ...int32) bool {
	if s == nil {
		return false
	}
	i := __convertInt32SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetInt32Set) Difference(other ReadOnlyInt32Set) Int32Set {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt32Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) Equal(other ReadOnlyInt32Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt32Set) NotEqual(other ReadOnlyInt32Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt32Set) Intersect(other ReadOnlyInt32Set) Int32Set {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetInt32Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) IsProperSubset(other ReadOnlyInt32Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetInt32Set) IsProperSuperset(other ReadOnlyInt32Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetInt32Set) IsSubset(other ReadOnlyInt32Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetInt32Set) IsSuperset(other ReadOnlyInt32Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetInt32Set) Each(f func(int32) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(int32)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetInt32Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetInt32Set) Remove(i int32) {
	s.ms.Remove(i)
}

func (s *mapsetInt32Set) String() string {
	return s.ms.String()
}

func (s *mapsetInt32Set) SymmetricDifference(other ReadOnlyInt32Set) Int32Set {
	return &mapsetInt32Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) Union(other ReadOnlyInt32Set) Int32Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
		return &mapsetInt32Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyInt32SetMatchingInt32(other))
	default:
		return s.Union(__emptyInt32SetMatchingInt32(s))
	}
}

func (s *mapsetInt32Set) Pop() int32 {
	var def int32
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInt32(i)
}

func (s *mapsetInt32Set) PowerSet() Int32Set {
	return &mapsetInt32Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) CartesianProduct(other ReadOnlyInt32Set) Int32Set {
	other = __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt32Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt32Set) ToSlice() []int32 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToInt32Slice(s.ms.ToSlice())
}

func (s *mapsetInt32Set) NotEmptyAndContains(item int32) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetInt32Set) NotEmptyAndNotContains(item int32) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetInt32Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetInt32Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetInt32Set) AddItems(items ...int32) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewInt32Set(items ...int32) Int32Set {
	return newMapsetInt32Set(items...)
}

func newMapsetInt32Set(items ...int32) *mapsetInt32Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetInt32Set{ms: ms, isThreadSafe: true}
}

// NewInt32SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewInt32SetFromSlice(s []int32) Int32Set {
	i := __convertInt32SliceToInterfaceSlice(s)
	return &mapsetInt32Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeInt32Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeInt32Set(i ...int32) Int32Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetInt32Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeInt32SetFromSlice(s []int32) Int32Set {
	i := __convertInt32SliceToInterfaceSlice(s)
	return &mapsetInt32Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeInt32Set(other ReadOnlyInt32Set) ReadOnlyInt32Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewInt32SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeInt32Set(other ReadOnlyInt32Set) ReadOnlyInt32Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeInt32SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeInt32SetMatchingCopyIfEnabled(s, other ReadOnlyInt32Set) ReadOnlyInt32Set {
	if !__Int32SetReceiverAutoConvertComparisonInt32SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeInt32Set(other)
	}

	return __ensureThreadUnsafeInt32Set(other)
}

func __convertInt32SliceToInterfaceSlice(typeSlice []int32) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInt32(item interface{}) int32 {
	t, ok := item.(int32)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToInt32Slice(interfaceSlice []interface{}) []int32 {
	typeSlice := make([]int32, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInt32(item)
	}
	return typeSlice
}

func __emptyInt32SetMatchingInt32(s ReadOnlyInt32Set) ReadOnlyInt32Set {
	if s.IsThreadSafe() {
		return __emptyInt32Set
	} else {
		return __emptyThreadUnsafeInt32Set
	}
}

var __emptyInt32Set = NewInt32Set()
var __emptyThreadUnsafeInt32Set = NewThreadUnsafeInt32Set()

// reset these in an init in the dest package if you dont want the defaults
var __Int64SetReceiverAutoConvertComparisonInt64SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyInt64Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyInt64Set or Int64Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Int64SetReceiverAutoConvertComparisonInt64SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Int64Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Int64Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...int64) bool

	// Returns if the given item is not in the set
	NotContains(i int64) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...int64) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...int64) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...int64) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyInt64Set) Int64Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyInt64Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyInt64Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyInt64Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyInt64Set) Int64Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyInt64Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyInt64Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyInt64Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyInt64Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyInt64Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(int64) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyInt64Set) Int64Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyInt64Set) Int64Set
	// Returns the members of the set as a slice.
	ToSlice() []int64

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item int64) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item int64) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyInt64Set) Int64Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Int64Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewInt64Set() and NewInt64SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeInt64Set(0 and NewThreadUnsafeInt64SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Int64Set interface {
	ReadOnlyInt64Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i int64) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...int64) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i int64)

	// Pop removes and returns an arbitrary item from the set.
	Pop() int64
}

type mapsetInt64Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetInt64Set) NotContains(i int64) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetInt64Set) NotContainsAny(tt ...int64) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetInt64Set) Nil() bool {
	return s == nil
}

func (s *mapsetInt64Set) NotNil() bool {
	return s != nil
}

func (s *mapsetInt64Set) IsDisjoint(other ReadOnlyInt64Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetInt64Set) Intersects(o ReadOnlyInt64Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetInt64Set) ContainsAny(items ...int64) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetInt64Set) ContainsAll(i ...int64) bool {
	return s.Contains(i...)
}

func (s *mapsetInt64Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetInt64Set) Add(i int64) bool {
	return s.ms.Add(i)
}

func (s *mapsetInt64Set) AddAll(il ...int64) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetInt64Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt64Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetInt64Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetInt64Set) Clone() Int64Set {
	if s == nil {
		return nil
	}
	return &mapsetInt64Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) Contains(t ...int64) bool {
	if s == nil {
		return false
	}
	i := __convertInt64SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetInt64Set) Difference(other ReadOnlyInt64Set) Int64Set {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt64Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) Equal(other ReadOnlyInt64Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt64Set) NotEqual(other ReadOnlyInt64Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetInt64Set) Intersect(other ReadOnlyInt64Set) Int64Set {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetInt64Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) IsProperSubset(other ReadOnlyInt64Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetInt64Set) IsProperSuperset(other ReadOnlyInt64Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetInt64Set) IsSubset(other ReadOnlyInt64Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetInt64Set) IsSuperset(other ReadOnlyInt64Set) bool {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetInt64Set) Each(f func(int64) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(int64)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetInt64Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetInt64Set) Remove(i int64) {
	s.ms.Remove(i)
}

func (s *mapsetInt64Set) String() string {
	return s.ms.String()
}

func (s *mapsetInt64Set) SymmetricDifference(other ReadOnlyInt64Set) Int64Set {
	return &mapsetInt64Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) Union(other ReadOnlyInt64Set) Int64Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
		return &mapsetInt64Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyInt64SetMatchingInt64(other))
	default:
		return s.Union(__emptyInt64SetMatchingInt64(s))
	}
}

func (s *mapsetInt64Set) Pop() int64 {
	var def int64
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToInt64(i)
}

func (s *mapsetInt64Set) PowerSet() Int64Set {
	return &mapsetInt64Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) CartesianProduct(other ReadOnlyInt64Set) Int64Set {
	other = __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other)
	return &mapsetInt64Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetInt64Set) ToSlice() []int64 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToInt64Slice(s.ms.ToSlice())
}

func (s *mapsetInt64Set) NotEmptyAndContains(item int64) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetInt64Set) NotEmptyAndNotContains(item int64) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetInt64Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetInt64Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetInt64Set) AddItems(items ...int64) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewInt64Set(items ...int64) Int64Set {
	return newMapsetInt64Set(items...)
}

func newMapsetInt64Set(items ...int64) *mapsetInt64Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetInt64Set{ms: ms, isThreadSafe: true}
}

// NewInt64SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewInt64SetFromSlice(s []int64) Int64Set {
	i := __convertInt64SliceToInterfaceSlice(s)
	return &mapsetInt64Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeInt64Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeInt64Set(i ...int64) Int64Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetInt64Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeInt64SetFromSlice(s []int64) Int64Set {
	i := __convertInt64SliceToInterfaceSlice(s)
	return &mapsetInt64Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeInt64Set(other ReadOnlyInt64Set) ReadOnlyInt64Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewInt64SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeInt64Set(other ReadOnlyInt64Set) ReadOnlyInt64Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeInt64SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeInt64SetMatchingCopyIfEnabled(s, other ReadOnlyInt64Set) ReadOnlyInt64Set {
	if !__Int64SetReceiverAutoConvertComparisonInt64SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeInt64Set(other)
	}

	return __ensureThreadUnsafeInt64Set(other)
}

func __convertInt64SliceToInterfaceSlice(typeSlice []int64) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToInt64(item interface{}) int64 {
	t, ok := item.(int64)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToInt64Slice(interfaceSlice []interface{}) []int64 {
	typeSlice := make([]int64, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToInt64(item)
	}
	return typeSlice
}

func __emptyInt64SetMatchingInt64(s ReadOnlyInt64Set) ReadOnlyInt64Set {
	if s.IsThreadSafe() {
		return __emptyInt64Set
	} else {
		return __emptyThreadUnsafeInt64Set
	}
}

var __emptyInt64Set = NewInt64Set()
var __emptyThreadUnsafeInt64Set = NewThreadUnsafeInt64Set()

// reset these in an init in the dest package if you dont want the defaults
var __Float32SetReceiverAutoConvertComparisonFloat32SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyFloat32Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyFloat32Set or Float32Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Float32SetReceiverAutoConvertComparisonFloat32SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Float32Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Float32Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...float32) bool

	// Returns if the given item is not in the set
	NotContains(i float32) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...float32) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...float32) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...float32) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyFloat32Set) Float32Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyFloat32Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyFloat32Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyFloat32Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyFloat32Set) Float32Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyFloat32Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyFloat32Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyFloat32Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyFloat32Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyFloat32Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(float32) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyFloat32Set) Float32Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyFloat32Set) Float32Set
	// Returns the members of the set as a slice.
	ToSlice() []float32

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item float32) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item float32) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyFloat32Set) Float32Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Float32Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewFloat32Set() and NewFloat32SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeFloat32Set(0 and NewThreadUnsafeFloat32SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Float32Set interface {
	ReadOnlyFloat32Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i float32) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...float32) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i float32)

	// Pop removes and returns an arbitrary item from the set.
	Pop() float32
}

type mapsetFloat32Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetFloat32Set) NotContains(i float32) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetFloat32Set) NotContainsAny(tt ...float32) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetFloat32Set) Nil() bool {
	return s == nil
}

func (s *mapsetFloat32Set) NotNil() bool {
	return s != nil
}

func (s *mapsetFloat32Set) IsDisjoint(other ReadOnlyFloat32Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetFloat32Set) Intersects(o ReadOnlyFloat32Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetFloat32Set) ContainsAny(items ...float32) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetFloat32Set) ContainsAll(i ...float32) bool {
	return s.Contains(i...)
}

func (s *mapsetFloat32Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetFloat32Set) Add(i float32) bool {
	return s.ms.Add(i)
}

func (s *mapsetFloat32Set) AddAll(il ...float32) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetFloat32Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetFloat32Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetFloat32Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetFloat32Set) Clone() Float32Set {
	if s == nil {
		return nil
	}
	return &mapsetFloat32Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) Contains(t ...float32) bool {
	if s == nil {
		return false
	}
	i := __convertFloat32SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetFloat32Set) Difference(other ReadOnlyFloat32Set) Float32Set {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return &mapsetFloat32Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) Equal(other ReadOnlyFloat32Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetFloat32Set) NotEqual(other ReadOnlyFloat32Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetFloat32Set) Intersect(other ReadOnlyFloat32Set) Float32Set {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetFloat32Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) IsProperSubset(other ReadOnlyFloat32Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetFloat32Set) IsProperSuperset(other ReadOnlyFloat32Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetFloat32Set) IsSubset(other ReadOnlyFloat32Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetFloat32Set) IsSuperset(other ReadOnlyFloat32Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetFloat32Set) Each(f func(float32) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(float32)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetFloat32Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetFloat32Set) Remove(i float32) {
	s.ms.Remove(i)
}

func (s *mapsetFloat32Set) String() string {
	return s.ms.String()
}

func (s *mapsetFloat32Set) SymmetricDifference(other ReadOnlyFloat32Set) Float32Set {
	return &mapsetFloat32Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) Union(other ReadOnlyFloat32Set) Float32Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
		return &mapsetFloat32Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyFloat32SetMatchingFloat32(other))
	default:
		return s.Union(__emptyFloat32SetMatchingFloat32(s))
	}
}

func (s *mapsetFloat32Set) Pop() float32 {
	var def float32
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToFloat32(i)
}

func (s *mapsetFloat32Set) PowerSet() Float32Set {
	return &mapsetFloat32Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) CartesianProduct(other ReadOnlyFloat32Set) Float32Set {
	other = __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other)
	return &mapsetFloat32Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat32Set) ToSlice() []float32 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToFloat32Slice(s.ms.ToSlice())
}

func (s *mapsetFloat32Set) NotEmptyAndContains(item float32) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetFloat32Set) NotEmptyAndNotContains(item float32) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetFloat32Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetFloat32Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetFloat32Set) AddItems(items ...float32) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewFloat32Set(items ...float32) Float32Set {
	return newMapsetFloat32Set(items...)
}

func newMapsetFloat32Set(items ...float32) *mapsetFloat32Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetFloat32Set{ms: ms, isThreadSafe: true}
}

// NewFloat32SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewFloat32SetFromSlice(s []float32) Float32Set {
	i := __convertFloat32SliceToInterfaceSlice(s)
	return &mapsetFloat32Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeFloat32Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeFloat32Set(i ...float32) Float32Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetFloat32Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeFloat32SetFromSlice(s []float32) Float32Set {
	i := __convertFloat32SliceToInterfaceSlice(s)
	return &mapsetFloat32Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeFloat32Set(other ReadOnlyFloat32Set) ReadOnlyFloat32Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewFloat32SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeFloat32Set(other ReadOnlyFloat32Set) ReadOnlyFloat32Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeFloat32SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeFloat32SetMatchingCopyIfEnabled(s, other ReadOnlyFloat32Set) ReadOnlyFloat32Set {
	if !__Float32SetReceiverAutoConvertComparisonFloat32SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeFloat32Set(other)
	}

	return __ensureThreadUnsafeFloat32Set(other)
}

func __convertFloat32SliceToInterfaceSlice(typeSlice []float32) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToFloat32(item interface{}) float32 {
	t, ok := item.(float32)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToFloat32Slice(interfaceSlice []interface{}) []float32 {
	typeSlice := make([]float32, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToFloat32(item)
	}
	return typeSlice
}

func __emptyFloat32SetMatchingFloat32(s ReadOnlyFloat32Set) ReadOnlyFloat32Set {
	if s.IsThreadSafe() {
		return __emptyFloat32Set
	} else {
		return __emptyThreadUnsafeFloat32Set
	}
}

var __emptyFloat32Set = NewFloat32Set()
var __emptyThreadUnsafeFloat32Set = NewThreadUnsafeFloat32Set()

// reset these in an init in the dest package if you dont want the defaults
var __Float64SetReceiverAutoConvertComparisonFloat64SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyFloat64Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyFloat64Set or Float64Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Float64SetReceiverAutoConvertComparisonFloat64SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Float64Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Float64Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...float64) bool

	// Returns if the given item is not in the set
	NotContains(i float64) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...float64) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...float64) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...float64) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyFloat64Set) Float64Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyFloat64Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyFloat64Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyFloat64Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyFloat64Set) Float64Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyFloat64Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyFloat64Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyFloat64Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyFloat64Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyFloat64Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(float64) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyFloat64Set) Float64Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyFloat64Set) Float64Set
	// Returns the members of the set as a slice.
	ToSlice() []float64

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item float64) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item float64) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyFloat64Set) Float64Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Float64Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewFloat64Set() and NewFloat64SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeFloat64Set(0 and NewThreadUnsafeFloat64SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Float64Set interface {
	ReadOnlyFloat64Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i float64) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...float64) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i float64)

	// Pop removes and returns an arbitrary item from the set.
	Pop() float64
}

type mapsetFloat64Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetFloat64Set) NotContains(i float64) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetFloat64Set) NotContainsAny(tt ...float64) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetFloat64Set) Nil() bool {
	return s == nil
}

func (s *mapsetFloat64Set) NotNil() bool {
	return s != nil
}

func (s *mapsetFloat64Set) IsDisjoint(other ReadOnlyFloat64Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetFloat64Set) Intersects(o ReadOnlyFloat64Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetFloat64Set) ContainsAny(items ...float64) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetFloat64Set) ContainsAll(i ...float64) bool {
	return s.Contains(i...)
}

func (s *mapsetFloat64Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetFloat64Set) Add(i float64) bool {
	return s.ms.Add(i)
}

func (s *mapsetFloat64Set) AddAll(il ...float64) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetFloat64Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetFloat64Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetFloat64Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetFloat64Set) Clone() Float64Set {
	if s == nil {
		return nil
	}
	return &mapsetFloat64Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) Contains(t ...float64) bool {
	if s == nil {
		return false
	}
	i := __convertFloat64SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetFloat64Set) Difference(other ReadOnlyFloat64Set) Float64Set {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return &mapsetFloat64Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) Equal(other ReadOnlyFloat64Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetFloat64Set) NotEqual(other ReadOnlyFloat64Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetFloat64Set) Intersect(other ReadOnlyFloat64Set) Float64Set {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetFloat64Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) IsProperSubset(other ReadOnlyFloat64Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetFloat64Set) IsProperSuperset(other ReadOnlyFloat64Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetFloat64Set) IsSubset(other ReadOnlyFloat64Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetFloat64Set) IsSuperset(other ReadOnlyFloat64Set) bool {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetFloat64Set) Each(f func(float64) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(float64)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetFloat64Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetFloat64Set) Remove(i float64) {
	s.ms.Remove(i)
}

func (s *mapsetFloat64Set) String() string {
	return s.ms.String()
}

func (s *mapsetFloat64Set) SymmetricDifference(other ReadOnlyFloat64Set) Float64Set {
	return &mapsetFloat64Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) Union(other ReadOnlyFloat64Set) Float64Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
		return &mapsetFloat64Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyFloat64SetMatchingFloat64(other))
	default:
		return s.Union(__emptyFloat64SetMatchingFloat64(s))
	}
}

func (s *mapsetFloat64Set) Pop() float64 {
	var def float64
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToFloat64(i)
}

func (s *mapsetFloat64Set) PowerSet() Float64Set {
	return &mapsetFloat64Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) CartesianProduct(other ReadOnlyFloat64Set) Float64Set {
	other = __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other)
	return &mapsetFloat64Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetFloat64Set) ToSlice() []float64 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToFloat64Slice(s.ms.ToSlice())
}

func (s *mapsetFloat64Set) NotEmptyAndContains(item float64) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetFloat64Set) NotEmptyAndNotContains(item float64) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetFloat64Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetFloat64Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetFloat64Set) AddItems(items ...float64) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewFloat64Set(items ...float64) Float64Set {
	return newMapsetFloat64Set(items...)
}

func newMapsetFloat64Set(items ...float64) *mapsetFloat64Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetFloat64Set{ms: ms, isThreadSafe: true}
}

// NewFloat64SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewFloat64SetFromSlice(s []float64) Float64Set {
	i := __convertFloat64SliceToInterfaceSlice(s)
	return &mapsetFloat64Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeFloat64Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeFloat64Set(i ...float64) Float64Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetFloat64Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeFloat64SetFromSlice(s []float64) Float64Set {
	i := __convertFloat64SliceToInterfaceSlice(s)
	return &mapsetFloat64Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeFloat64Set(other ReadOnlyFloat64Set) ReadOnlyFloat64Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewFloat64SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeFloat64Set(other ReadOnlyFloat64Set) ReadOnlyFloat64Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeFloat64SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeFloat64SetMatchingCopyIfEnabled(s, other ReadOnlyFloat64Set) ReadOnlyFloat64Set {
	if !__Float64SetReceiverAutoConvertComparisonFloat64SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeFloat64Set(other)
	}

	return __ensureThreadUnsafeFloat64Set(other)
}

func __convertFloat64SliceToInterfaceSlice(typeSlice []float64) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToFloat64(item interface{}) float64 {
	t, ok := item.(float64)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToFloat64Slice(interfaceSlice []interface{}) []float64 {
	typeSlice := make([]float64, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToFloat64(item)
	}
	return typeSlice
}

func __emptyFloat64SetMatchingFloat64(s ReadOnlyFloat64Set) ReadOnlyFloat64Set {
	if s.IsThreadSafe() {
		return __emptyFloat64Set
	} else {
		return __emptyThreadUnsafeFloat64Set
	}
}

var __emptyFloat64Set = NewFloat64Set()
var __emptyThreadUnsafeFloat64Set = NewThreadUnsafeFloat64Set()

// reset these in an init in the dest package if you dont want the defaults
var __Complex64SetReceiverAutoConvertComparisonComplex64SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyComplex64Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyComplex64Set or Complex64Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Complex64SetReceiverAutoConvertComparisonComplex64SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Complex64Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Complex64Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...complex64) bool

	// Returns if the given item is not in the set
	NotContains(i complex64) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...complex64) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...complex64) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...complex64) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyComplex64Set) Complex64Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyComplex64Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyComplex64Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyComplex64Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyComplex64Set) Complex64Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyComplex64Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyComplex64Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyComplex64Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyComplex64Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyComplex64Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(complex64) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyComplex64Set) Complex64Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyComplex64Set) Complex64Set
	// Returns the members of the set as a slice.
	ToSlice() []complex64

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item complex64) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item complex64) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyComplex64Set) Complex64Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Complex64Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewComplex64Set() and NewComplex64SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeComplex64Set(0 and NewThreadUnsafeComplex64SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Complex64Set interface {
	ReadOnlyComplex64Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i complex64) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...complex64) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i complex64)

	// Pop removes and returns an arbitrary item from the set.
	Pop() complex64
}

type mapsetComplex64Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetComplex64Set) NotContains(i complex64) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetComplex64Set) NotContainsAny(tt ...complex64) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetComplex64Set) Nil() bool {
	return s == nil
}

func (s *mapsetComplex64Set) NotNil() bool {
	return s != nil
}

func (s *mapsetComplex64Set) IsDisjoint(other ReadOnlyComplex64Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetComplex64Set) Intersects(o ReadOnlyComplex64Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetComplex64Set) ContainsAny(items ...complex64) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetComplex64Set) ContainsAll(i ...complex64) bool {
	return s.Contains(i...)
}

func (s *mapsetComplex64Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetComplex64Set) Add(i complex64) bool {
	return s.ms.Add(i)
}

func (s *mapsetComplex64Set) AddAll(il ...complex64) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetComplex64Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetComplex64Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetComplex64Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetComplex64Set) Clone() Complex64Set {
	if s == nil {
		return nil
	}
	return &mapsetComplex64Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) Contains(t ...complex64) bool {
	if s == nil {
		return false
	}
	i := __convertComplex64SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetComplex64Set) Difference(other ReadOnlyComplex64Set) Complex64Set {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return &mapsetComplex64Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) Equal(other ReadOnlyComplex64Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetComplex64Set) NotEqual(other ReadOnlyComplex64Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetComplex64Set) Intersect(other ReadOnlyComplex64Set) Complex64Set {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetComplex64Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) IsProperSubset(other ReadOnlyComplex64Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetComplex64Set) IsProperSuperset(other ReadOnlyComplex64Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetComplex64Set) IsSubset(other ReadOnlyComplex64Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetComplex64Set) IsSuperset(other ReadOnlyComplex64Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetComplex64Set) Each(f func(complex64) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(complex64)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetComplex64Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetComplex64Set) Remove(i complex64) {
	s.ms.Remove(i)
}

func (s *mapsetComplex64Set) String() string {
	return s.ms.String()
}

func (s *mapsetComplex64Set) SymmetricDifference(other ReadOnlyComplex64Set) Complex64Set {
	return &mapsetComplex64Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) Union(other ReadOnlyComplex64Set) Complex64Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
		return &mapsetComplex64Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyComplex64SetMatchingComplex64(other))
	default:
		return s.Union(__emptyComplex64SetMatchingComplex64(s))
	}
}

func (s *mapsetComplex64Set) Pop() complex64 {
	var def complex64
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToComplex64(i)
}

func (s *mapsetComplex64Set) PowerSet() Complex64Set {
	return &mapsetComplex64Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) CartesianProduct(other ReadOnlyComplex64Set) Complex64Set {
	other = __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other)
	return &mapsetComplex64Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex64Set) ToSlice() []complex64 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToComplex64Slice(s.ms.ToSlice())
}

func (s *mapsetComplex64Set) NotEmptyAndContains(item complex64) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetComplex64Set) NotEmptyAndNotContains(item complex64) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetComplex64Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetComplex64Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetComplex64Set) AddItems(items ...complex64) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewComplex64Set(items ...complex64) Complex64Set {
	return newMapsetComplex64Set(items...)
}

func newMapsetComplex64Set(items ...complex64) *mapsetComplex64Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetComplex64Set{ms: ms, isThreadSafe: true}
}

// NewComplex64SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewComplex64SetFromSlice(s []complex64) Complex64Set {
	i := __convertComplex64SliceToInterfaceSlice(s)
	return &mapsetComplex64Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeComplex64Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeComplex64Set(i ...complex64) Complex64Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetComplex64Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeComplex64SetFromSlice(s []complex64) Complex64Set {
	i := __convertComplex64SliceToInterfaceSlice(s)
	return &mapsetComplex64Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeComplex64Set(other ReadOnlyComplex64Set) ReadOnlyComplex64Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewComplex64SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeComplex64Set(other ReadOnlyComplex64Set) ReadOnlyComplex64Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeComplex64SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeComplex64SetMatchingCopyIfEnabled(s, other ReadOnlyComplex64Set) ReadOnlyComplex64Set {
	if !__Complex64SetReceiverAutoConvertComparisonComplex64SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeComplex64Set(other)
	}

	return __ensureThreadUnsafeComplex64Set(other)
}

func __convertComplex64SliceToInterfaceSlice(typeSlice []complex64) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToComplex64(item interface{}) complex64 {
	t, ok := item.(complex64)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToComplex64Slice(interfaceSlice []interface{}) []complex64 {
	typeSlice := make([]complex64, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToComplex64(item)
	}
	return typeSlice
}

func __emptyComplex64SetMatchingComplex64(s ReadOnlyComplex64Set) ReadOnlyComplex64Set {
	if s.IsThreadSafe() {
		return __emptyComplex64Set
	} else {
		return __emptyThreadUnsafeComplex64Set
	}
}

var __emptyComplex64Set = NewComplex64Set()
var __emptyThreadUnsafeComplex64Set = NewThreadUnsafeComplex64Set()

// reset these in an init in the dest package if you dont want the defaults
var __Complex128SetReceiverAutoConvertComparisonComplex128SetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyComplex128Set interface {

	// Note that the argument to all methods that
	// take a ReadOnlyComplex128Set or Complex128Set as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __Complex128SetReceiverAutoConvertComparisonComplex128SetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that Complex128Set is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() Complex128Set

	// Returns whether the given items
	// are all in the set.
	Contains(i ...complex128) bool

	// Returns if the given item is not in the set
	NotContains(i complex128) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...complex128) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...complex128) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...complex128) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyComplex128Set) Complex128Set

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyComplex128Set) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyComplex128Set) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyComplex128Set) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyComplex128Set) Complex128Set

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyComplex128Set) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyComplex128Set) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyComplex128Set) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyComplex128Set) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyComplex128Set) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(complex128) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyComplex128Set) Complex128Set

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyComplex128Set) Complex128Set
	// Returns the members of the set as a slice.
	ToSlice() []complex128

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item complex128) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item complex128) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyComplex128Set) Complex128Set

	// Returns all subsets of a given set (Power Set).
	PowerSet() Complex128Set

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewComplex128Set() and NewComplex128SetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeComplex128Set(0 and NewThreadUnsafeComplex128SetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type Complex128Set interface {
	ReadOnlyComplex128Set

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i complex128) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...complex128) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i complex128)

	// Pop removes and returns an arbitrary item from the set.
	Pop() complex128
}

type mapsetComplex128Set struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetComplex128Set) NotContains(i complex128) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetComplex128Set) NotContainsAny(tt ...complex128) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetComplex128Set) Nil() bool {
	return s == nil
}

func (s *mapsetComplex128Set) NotNil() bool {
	return s != nil
}

func (s *mapsetComplex128Set) IsDisjoint(other ReadOnlyComplex128Set) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetComplex128Set) Intersects(o ReadOnlyComplex128Set) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetComplex128Set) ContainsAny(items ...complex128) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetComplex128Set) ContainsAll(i ...complex128) bool {
	return s.Contains(i...)
}

func (s *mapsetComplex128Set) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetComplex128Set) Add(i complex128) bool {
	return s.ms.Add(i)
}

func (s *mapsetComplex128Set) AddAll(il ...complex128) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetComplex128Set) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetComplex128Set) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetComplex128Set) Clear() {
	s.ms.Clear()
}

func (s *mapsetComplex128Set) Clone() Complex128Set {
	if s == nil {
		return nil
	}
	return &mapsetComplex128Set{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) Contains(t ...complex128) bool {
	if s == nil {
		return false
	}
	i := __convertComplex128SliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetComplex128Set) Difference(other ReadOnlyComplex128Set) Complex128Set {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return &mapsetComplex128Set{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) Equal(other ReadOnlyComplex128Set) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetComplex128Set) NotEqual(other ReadOnlyComplex128Set) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetComplex128Set) Intersect(other ReadOnlyComplex128Set) Complex128Set {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetComplex128Set{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) IsProperSubset(other ReadOnlyComplex128Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetComplex128Set) IsProperSuperset(other ReadOnlyComplex128Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetComplex128Set) IsSubset(other ReadOnlyComplex128Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetComplex128Set) IsSuperset(other ReadOnlyComplex128Set) bool {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetComplex128Set) Each(f func(complex128) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(complex128)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetComplex128Set) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetComplex128Set) Remove(i complex128) {
	s.ms.Remove(i)
}

func (s *mapsetComplex128Set) String() string {
	return s.ms.String()
}

func (s *mapsetComplex128Set) SymmetricDifference(other ReadOnlyComplex128Set) Complex128Set {
	return &mapsetComplex128Set{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) Union(other ReadOnlyComplex128Set) Complex128Set {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
		return &mapsetComplex128Set{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyComplex128SetMatchingComplex128(other))
	default:
		return s.Union(__emptyComplex128SetMatchingComplex128(s))
	}
}

func (s *mapsetComplex128Set) Pop() complex128 {
	var def complex128
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToComplex128(i)
}

func (s *mapsetComplex128Set) PowerSet() Complex128Set {
	return &mapsetComplex128Set{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) CartesianProduct(other ReadOnlyComplex128Set) Complex128Set {
	other = __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other)
	return &mapsetComplex128Set{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetComplex128Set) ToSlice() []complex128 {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToComplex128Slice(s.ms.ToSlice())
}

func (s *mapsetComplex128Set) NotEmptyAndContains(item complex128) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetComplex128Set) NotEmptyAndNotContains(item complex128) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetComplex128Set) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetComplex128Set) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetComplex128Set) AddItems(items ...complex128) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewComplex128Set(items ...complex128) Complex128Set {
	return newMapsetComplex128Set(items...)
}

func newMapsetComplex128Set(items ...complex128) *mapsetComplex128Set {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetComplex128Set{ms: ms, isThreadSafe: true}
}

// NewComplex128SetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewComplex128SetFromSlice(s []complex128) Complex128Set {
	i := __convertComplex128SliceToInterfaceSlice(s)
	return &mapsetComplex128Set{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeComplex128Set creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeComplex128Set(i ...complex128) Complex128Set {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetComplex128Set{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeComplex128SetFromSlice(s []complex128) Complex128Set {
	i := __convertComplex128SliceToInterfaceSlice(s)
	return &mapsetComplex128Set{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeComplex128Set(other ReadOnlyComplex128Set) ReadOnlyComplex128Set {
	if other.IsThreadSafe() {
		return other
	}
	return NewComplex128SetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeComplex128Set(other ReadOnlyComplex128Set) ReadOnlyComplex128Set {
	if other.IsThreadSafe() {
		return NewThreadUnsafeComplex128SetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeComplex128SetMatchingCopyIfEnabled(s, other ReadOnlyComplex128Set) ReadOnlyComplex128Set {
	if !__Complex128SetReceiverAutoConvertComparisonComplex128SetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeComplex128Set(other)
	}

	return __ensureThreadUnsafeComplex128Set(other)
}

func __convertComplex128SliceToInterfaceSlice(typeSlice []complex128) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToComplex128(item interface{}) complex128 {
	t, ok := item.(complex128)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToComplex128Slice(interfaceSlice []interface{}) []complex128 {
	typeSlice := make([]complex128, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToComplex128(item)
	}
	return typeSlice
}

func __emptyComplex128SetMatchingComplex128(s ReadOnlyComplex128Set) ReadOnlyComplex128Set {
	if s.IsThreadSafe() {
		return __emptyComplex128Set
	} else {
		return __emptyThreadUnsafeComplex128Set
	}
}

var __emptyComplex128Set = NewComplex128Set()
var __emptyThreadUnsafeComplex128Set = NewThreadUnsafeComplex128Set()
