// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/noho-digital/genny

package collex

import "sync"

type ByteByteKeyValue struct {
	Key   byte
	Value byte
}

type ByteByteConcurrentMapOption func(*ByteByteConcurrentMap)

func WithUnsafeByteByteMap(m map[byte]byte) ByteByteConcurrentMapOption {
	return func(cm *ByteByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteByteMap(m map[byte]byte) ByteByteConcurrentMapOption {
	return func(cm *ByteByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteByteConcurrentMap(opts ...ByteByteConcurrentMapOption) *ByteByteConcurrentMap {
	cm := &ByteByteConcurrentMap{
		m: make(map[byte]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteByteMapKeyValue struct {
	Key   byte
	Value byte
}

type ByteByteConcurrentMap struct {
	m map[byte]byte
	L *sync.RWMutex
}

func (cm *ByteByteConcurrentMap) Get(k byte) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteByteConcurrentMap) GetDefault(k byte, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteByteConcurrentMap) GetOK(k byte) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteByteConcurrentMap) Set(k byte, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteByteConcurrentMap) Delete(k byte) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteByteConcurrentMap) SetKeyValues(kvs ...ByteByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteByteConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteByteConcurrentMap) KeyValues() []ByteByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteByteConcurrentMap) ToUnsafeMap() map[byte]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteRuneKeyValue struct {
	Key   byte
	Value rune
}

type ByteRuneConcurrentMapOption func(*ByteRuneConcurrentMap)

func WithUnsafeByteRuneMap(m map[byte]rune) ByteRuneConcurrentMapOption {
	return func(cm *ByteRuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteRuneMap(m map[byte]rune) ByteRuneConcurrentMapOption {
	return func(cm *ByteRuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteRuneConcurrentMap(opts ...ByteRuneConcurrentMapOption) *ByteRuneConcurrentMap {
	cm := &ByteRuneConcurrentMap{
		m: make(map[byte]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteRuneMapKeyValue struct {
	Key   byte
	Value rune
}

type ByteRuneConcurrentMap struct {
	m map[byte]rune
	L *sync.RWMutex
}

func (cm *ByteRuneConcurrentMap) Get(k byte) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteRuneConcurrentMap) GetDefault(k byte, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteRuneConcurrentMap) GetOK(k byte) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteRuneConcurrentMap) Set(k byte, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteRuneConcurrentMap) Delete(k byte) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteRuneConcurrentMap) SetKeyValues(kvs ...ByteRuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteRuneConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteRuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteRuneConcurrentMap) KeyValues() []ByteRuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteRuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteRuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteRuneConcurrentMap) ToUnsafeMap() map[byte]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteUintKeyValue struct {
	Key   byte
	Value uint
}

type ByteUintConcurrentMapOption func(*ByteUintConcurrentMap)

func WithUnsafeByteUintMap(m map[byte]uint) ByteUintConcurrentMapOption {
	return func(cm *ByteUintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteUintMap(m map[byte]uint) ByteUintConcurrentMapOption {
	return func(cm *ByteUintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteUintConcurrentMap(opts ...ByteUintConcurrentMapOption) *ByteUintConcurrentMap {
	cm := &ByteUintConcurrentMap{
		m: make(map[byte]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteUintMapKeyValue struct {
	Key   byte
	Value uint
}

type ByteUintConcurrentMap struct {
	m map[byte]uint
	L *sync.RWMutex
}

func (cm *ByteUintConcurrentMap) Get(k byte) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteUintConcurrentMap) GetDefault(k byte, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteUintConcurrentMap) GetOK(k byte) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteUintConcurrentMap) Set(k byte, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteUintConcurrentMap) Delete(k byte) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteUintConcurrentMap) SetKeyValues(kvs ...ByteUintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteUintConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteUintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteUintConcurrentMap) KeyValues() []ByteUintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteUintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteUintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteUintConcurrentMap) ToUnsafeMap() map[byte]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteUint8KeyValue struct {
	Key   byte
	Value uint8
}

type ByteUint8ConcurrentMapOption func(*ByteUint8ConcurrentMap)

func WithUnsafeByteUint8Map(m map[byte]uint8) ByteUint8ConcurrentMapOption {
	return func(cm *ByteUint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteUint8Map(m map[byte]uint8) ByteUint8ConcurrentMapOption {
	return func(cm *ByteUint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteUint8ConcurrentMap(opts ...ByteUint8ConcurrentMapOption) *ByteUint8ConcurrentMap {
	cm := &ByteUint8ConcurrentMap{
		m: make(map[byte]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteUint8MapKeyValue struct {
	Key   byte
	Value uint8
}

type ByteUint8ConcurrentMap struct {
	m map[byte]uint8
	L *sync.RWMutex
}

func (cm *ByteUint8ConcurrentMap) Get(k byte) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteUint8ConcurrentMap) GetDefault(k byte, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteUint8ConcurrentMap) GetOK(k byte) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteUint8ConcurrentMap) Set(k byte, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteUint8ConcurrentMap) Delete(k byte) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteUint8ConcurrentMap) SetKeyValues(kvs ...ByteUint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteUint8ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteUint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteUint8ConcurrentMap) KeyValues() []ByteUint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteUint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteUint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteUint8ConcurrentMap) ToUnsafeMap() map[byte]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteUint16KeyValue struct {
	Key   byte
	Value uint16
}

type ByteUint16ConcurrentMapOption func(*ByteUint16ConcurrentMap)

func WithUnsafeByteUint16Map(m map[byte]uint16) ByteUint16ConcurrentMapOption {
	return func(cm *ByteUint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteUint16Map(m map[byte]uint16) ByteUint16ConcurrentMapOption {
	return func(cm *ByteUint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteUint16ConcurrentMap(opts ...ByteUint16ConcurrentMapOption) *ByteUint16ConcurrentMap {
	cm := &ByteUint16ConcurrentMap{
		m: make(map[byte]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteUint16MapKeyValue struct {
	Key   byte
	Value uint16
}

type ByteUint16ConcurrentMap struct {
	m map[byte]uint16
	L *sync.RWMutex
}

func (cm *ByteUint16ConcurrentMap) Get(k byte) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteUint16ConcurrentMap) GetDefault(k byte, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteUint16ConcurrentMap) GetOK(k byte) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteUint16ConcurrentMap) Set(k byte, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteUint16ConcurrentMap) Delete(k byte) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteUint16ConcurrentMap) SetKeyValues(kvs ...ByteUint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteUint16ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteUint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteUint16ConcurrentMap) KeyValues() []ByteUint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteUint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteUint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteUint16ConcurrentMap) ToUnsafeMap() map[byte]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteInterfaceKeyValue struct {
	Key   byte
	Value Interface
}

type ByteInterfaceConcurrentMapOption func(*ByteInterfaceConcurrentMap)

func WithUnsafeByteInterfaceMap(m map[byte]Interface) ByteInterfaceConcurrentMapOption {
	return func(cm *ByteInterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteInterfaceMap(m map[byte]Interface) ByteInterfaceConcurrentMapOption {
	return func(cm *ByteInterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteInterfaceConcurrentMap(opts ...ByteInterfaceConcurrentMapOption) *ByteInterfaceConcurrentMap {
	cm := &ByteInterfaceConcurrentMap{
		m: make(map[byte]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteInterfaceMapKeyValue struct {
	Key   byte
	Value Interface
}

type ByteInterfaceConcurrentMap struct {
	m map[byte]Interface
	L *sync.RWMutex
}

func (cm *ByteInterfaceConcurrentMap) Get(k byte) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteInterfaceConcurrentMap) GetDefault(k byte, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteInterfaceConcurrentMap) GetOK(k byte) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteInterfaceConcurrentMap) Set(k byte, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteInterfaceConcurrentMap) Delete(k byte) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteInterfaceConcurrentMap) SetKeyValues(kvs ...ByteInterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteInterfaceConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteInterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteInterfaceConcurrentMap) KeyValues() []ByteInterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteInterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteInterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteInterfaceConcurrentMap) ToUnsafeMap() map[byte]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteUint32KeyValue struct {
	Key   byte
	Value uint32
}

type ByteUint32ConcurrentMapOption func(*ByteUint32ConcurrentMap)

func WithUnsafeByteUint32Map(m map[byte]uint32) ByteUint32ConcurrentMapOption {
	return func(cm *ByteUint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteUint32Map(m map[byte]uint32) ByteUint32ConcurrentMapOption {
	return func(cm *ByteUint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteUint32ConcurrentMap(opts ...ByteUint32ConcurrentMapOption) *ByteUint32ConcurrentMap {
	cm := &ByteUint32ConcurrentMap{
		m: make(map[byte]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteUint32MapKeyValue struct {
	Key   byte
	Value uint32
}

type ByteUint32ConcurrentMap struct {
	m map[byte]uint32
	L *sync.RWMutex
}

func (cm *ByteUint32ConcurrentMap) Get(k byte) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteUint32ConcurrentMap) GetDefault(k byte, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteUint32ConcurrentMap) GetOK(k byte) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteUint32ConcurrentMap) Set(k byte, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteUint32ConcurrentMap) Delete(k byte) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteUint32ConcurrentMap) SetKeyValues(kvs ...ByteUint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteUint32ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteUint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteUint32ConcurrentMap) KeyValues() []ByteUint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteUint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteUint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteUint32ConcurrentMap) ToUnsafeMap() map[byte]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteUint64KeyValue struct {
	Key   byte
	Value uint64
}

type ByteUint64ConcurrentMapOption func(*ByteUint64ConcurrentMap)

func WithUnsafeByteUint64Map(m map[byte]uint64) ByteUint64ConcurrentMapOption {
	return func(cm *ByteUint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteUint64Map(m map[byte]uint64) ByteUint64ConcurrentMapOption {
	return func(cm *ByteUint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteUint64ConcurrentMap(opts ...ByteUint64ConcurrentMapOption) *ByteUint64ConcurrentMap {
	cm := &ByteUint64ConcurrentMap{
		m: make(map[byte]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteUint64MapKeyValue struct {
	Key   byte
	Value uint64
}

type ByteUint64ConcurrentMap struct {
	m map[byte]uint64
	L *sync.RWMutex
}

func (cm *ByteUint64ConcurrentMap) Get(k byte) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteUint64ConcurrentMap) GetDefault(k byte, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteUint64ConcurrentMap) GetOK(k byte) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteUint64ConcurrentMap) Set(k byte, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteUint64ConcurrentMap) Delete(k byte) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteUint64ConcurrentMap) SetKeyValues(kvs ...ByteUint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteUint64ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteUint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteUint64ConcurrentMap) KeyValues() []ByteUint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteUint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteUint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteUint64ConcurrentMap) ToUnsafeMap() map[byte]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteIntKeyValue struct {
	Key   byte
	Value int
}

type ByteIntConcurrentMapOption func(*ByteIntConcurrentMap)

func WithUnsafeByteIntMap(m map[byte]int) ByteIntConcurrentMapOption {
	return func(cm *ByteIntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteIntMap(m map[byte]int) ByteIntConcurrentMapOption {
	return func(cm *ByteIntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteIntConcurrentMap(opts ...ByteIntConcurrentMapOption) *ByteIntConcurrentMap {
	cm := &ByteIntConcurrentMap{
		m: make(map[byte]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteIntMapKeyValue struct {
	Key   byte
	Value int
}

type ByteIntConcurrentMap struct {
	m map[byte]int
	L *sync.RWMutex
}

func (cm *ByteIntConcurrentMap) Get(k byte) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteIntConcurrentMap) GetDefault(k byte, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteIntConcurrentMap) GetOK(k byte) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteIntConcurrentMap) Set(k byte, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteIntConcurrentMap) Delete(k byte) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteIntConcurrentMap) SetKeyValues(kvs ...ByteIntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteIntConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteIntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteIntConcurrentMap) KeyValues() []ByteIntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteIntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteIntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteIntConcurrentMap) ToUnsafeMap() map[byte]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteInt8KeyValue struct {
	Key   byte
	Value int8
}

type ByteInt8ConcurrentMapOption func(*ByteInt8ConcurrentMap)

func WithUnsafeByteInt8Map(m map[byte]int8) ByteInt8ConcurrentMapOption {
	return func(cm *ByteInt8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteInt8Map(m map[byte]int8) ByteInt8ConcurrentMapOption {
	return func(cm *ByteInt8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteInt8ConcurrentMap(opts ...ByteInt8ConcurrentMapOption) *ByteInt8ConcurrentMap {
	cm := &ByteInt8ConcurrentMap{
		m: make(map[byte]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteInt8MapKeyValue struct {
	Key   byte
	Value int8
}

type ByteInt8ConcurrentMap struct {
	m map[byte]int8
	L *sync.RWMutex
}

func (cm *ByteInt8ConcurrentMap) Get(k byte) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteInt8ConcurrentMap) GetDefault(k byte, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteInt8ConcurrentMap) GetOK(k byte) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteInt8ConcurrentMap) Set(k byte, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteInt8ConcurrentMap) Delete(k byte) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteInt8ConcurrentMap) SetKeyValues(kvs ...ByteInt8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteInt8ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteInt8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteInt8ConcurrentMap) KeyValues() []ByteInt8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteInt8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteInt8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteInt8ConcurrentMap) ToUnsafeMap() map[byte]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteInt16KeyValue struct {
	Key   byte
	Value int16
}

type ByteInt16ConcurrentMapOption func(*ByteInt16ConcurrentMap)

func WithUnsafeByteInt16Map(m map[byte]int16) ByteInt16ConcurrentMapOption {
	return func(cm *ByteInt16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteInt16Map(m map[byte]int16) ByteInt16ConcurrentMapOption {
	return func(cm *ByteInt16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteInt16ConcurrentMap(opts ...ByteInt16ConcurrentMapOption) *ByteInt16ConcurrentMap {
	cm := &ByteInt16ConcurrentMap{
		m: make(map[byte]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteInt16MapKeyValue struct {
	Key   byte
	Value int16
}

type ByteInt16ConcurrentMap struct {
	m map[byte]int16
	L *sync.RWMutex
}

func (cm *ByteInt16ConcurrentMap) Get(k byte) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteInt16ConcurrentMap) GetDefault(k byte, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteInt16ConcurrentMap) GetOK(k byte) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteInt16ConcurrentMap) Set(k byte, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteInt16ConcurrentMap) Delete(k byte) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteInt16ConcurrentMap) SetKeyValues(kvs ...ByteInt16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteInt16ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteInt16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteInt16ConcurrentMap) KeyValues() []ByteInt16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteInt16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteInt16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteInt16ConcurrentMap) ToUnsafeMap() map[byte]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteInt32KeyValue struct {
	Key   byte
	Value int32
}

type ByteInt32ConcurrentMapOption func(*ByteInt32ConcurrentMap)

func WithUnsafeByteInt32Map(m map[byte]int32) ByteInt32ConcurrentMapOption {
	return func(cm *ByteInt32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteInt32Map(m map[byte]int32) ByteInt32ConcurrentMapOption {
	return func(cm *ByteInt32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteInt32ConcurrentMap(opts ...ByteInt32ConcurrentMapOption) *ByteInt32ConcurrentMap {
	cm := &ByteInt32ConcurrentMap{
		m: make(map[byte]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteInt32MapKeyValue struct {
	Key   byte
	Value int32
}

type ByteInt32ConcurrentMap struct {
	m map[byte]int32
	L *sync.RWMutex
}

func (cm *ByteInt32ConcurrentMap) Get(k byte) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteInt32ConcurrentMap) GetDefault(k byte, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteInt32ConcurrentMap) GetOK(k byte) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteInt32ConcurrentMap) Set(k byte, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteInt32ConcurrentMap) Delete(k byte) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteInt32ConcurrentMap) SetKeyValues(kvs ...ByteInt32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteInt32ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteInt32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteInt32ConcurrentMap) KeyValues() []ByteInt32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteInt32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteInt32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteInt32ConcurrentMap) ToUnsafeMap() map[byte]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteInt64KeyValue struct {
	Key   byte
	Value int64
}

type ByteInt64ConcurrentMapOption func(*ByteInt64ConcurrentMap)

func WithUnsafeByteInt64Map(m map[byte]int64) ByteInt64ConcurrentMapOption {
	return func(cm *ByteInt64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteInt64Map(m map[byte]int64) ByteInt64ConcurrentMapOption {
	return func(cm *ByteInt64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteInt64ConcurrentMap(opts ...ByteInt64ConcurrentMapOption) *ByteInt64ConcurrentMap {
	cm := &ByteInt64ConcurrentMap{
		m: make(map[byte]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteInt64MapKeyValue struct {
	Key   byte
	Value int64
}

type ByteInt64ConcurrentMap struct {
	m map[byte]int64
	L *sync.RWMutex
}

func (cm *ByteInt64ConcurrentMap) Get(k byte) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteInt64ConcurrentMap) GetDefault(k byte, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteInt64ConcurrentMap) GetOK(k byte) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteInt64ConcurrentMap) Set(k byte, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteInt64ConcurrentMap) Delete(k byte) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteInt64ConcurrentMap) SetKeyValues(kvs ...ByteInt64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteInt64ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteInt64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteInt64ConcurrentMap) KeyValues() []ByteInt64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteInt64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteInt64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteInt64ConcurrentMap) ToUnsafeMap() map[byte]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteFloat32KeyValue struct {
	Key   byte
	Value float32
}

type ByteFloat32ConcurrentMapOption func(*ByteFloat32ConcurrentMap)

func WithUnsafeByteFloat32Map(m map[byte]float32) ByteFloat32ConcurrentMapOption {
	return func(cm *ByteFloat32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteFloat32Map(m map[byte]float32) ByteFloat32ConcurrentMapOption {
	return func(cm *ByteFloat32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteFloat32ConcurrentMap(opts ...ByteFloat32ConcurrentMapOption) *ByteFloat32ConcurrentMap {
	cm := &ByteFloat32ConcurrentMap{
		m: make(map[byte]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteFloat32MapKeyValue struct {
	Key   byte
	Value float32
}

type ByteFloat32ConcurrentMap struct {
	m map[byte]float32
	L *sync.RWMutex
}

func (cm *ByteFloat32ConcurrentMap) Get(k byte) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteFloat32ConcurrentMap) GetDefault(k byte, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteFloat32ConcurrentMap) GetOK(k byte) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteFloat32ConcurrentMap) Set(k byte, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteFloat32ConcurrentMap) Delete(k byte) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteFloat32ConcurrentMap) SetKeyValues(kvs ...ByteFloat32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteFloat32ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteFloat32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteFloat32ConcurrentMap) KeyValues() []ByteFloat32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteFloat32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteFloat32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteFloat32ConcurrentMap) ToUnsafeMap() map[byte]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteFloat64KeyValue struct {
	Key   byte
	Value float64
}

type ByteFloat64ConcurrentMapOption func(*ByteFloat64ConcurrentMap)

func WithUnsafeByteFloat64Map(m map[byte]float64) ByteFloat64ConcurrentMapOption {
	return func(cm *ByteFloat64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteFloat64Map(m map[byte]float64) ByteFloat64ConcurrentMapOption {
	return func(cm *ByteFloat64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteFloat64ConcurrentMap(opts ...ByteFloat64ConcurrentMapOption) *ByteFloat64ConcurrentMap {
	cm := &ByteFloat64ConcurrentMap{
		m: make(map[byte]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteFloat64MapKeyValue struct {
	Key   byte
	Value float64
}

type ByteFloat64ConcurrentMap struct {
	m map[byte]float64
	L *sync.RWMutex
}

func (cm *ByteFloat64ConcurrentMap) Get(k byte) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteFloat64ConcurrentMap) GetDefault(k byte, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteFloat64ConcurrentMap) GetOK(k byte) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteFloat64ConcurrentMap) Set(k byte, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteFloat64ConcurrentMap) Delete(k byte) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteFloat64ConcurrentMap) SetKeyValues(kvs ...ByteFloat64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteFloat64ConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteFloat64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteFloat64ConcurrentMap) KeyValues() []ByteFloat64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteFloat64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteFloat64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteFloat64ConcurrentMap) ToUnsafeMap() map[byte]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteTypeKeyValue struct {
	Key   byte
	Value Type
}

type ByteTypeConcurrentMapOption func(*ByteTypeConcurrentMap)

func WithUnsafeByteTypeMap(m map[byte]Type) ByteTypeConcurrentMapOption {
	return func(cm *ByteTypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteTypeMap(m map[byte]Type) ByteTypeConcurrentMapOption {
	return func(cm *ByteTypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteTypeConcurrentMap(opts ...ByteTypeConcurrentMapOption) *ByteTypeConcurrentMap {
	cm := &ByteTypeConcurrentMap{
		m: make(map[byte]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteTypeMapKeyValue struct {
	Key   byte
	Value Type
}

type ByteTypeConcurrentMap struct {
	m map[byte]Type
	L *sync.RWMutex
}

func (cm *ByteTypeConcurrentMap) Get(k byte) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteTypeConcurrentMap) GetDefault(k byte, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteTypeConcurrentMap) GetOK(k byte) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteTypeConcurrentMap) Set(k byte, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteTypeConcurrentMap) Delete(k byte) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteTypeConcurrentMap) SetKeyValues(kvs ...ByteTypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteTypeConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteTypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteTypeConcurrentMap) KeyValues() []ByteTypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteTypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteTypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteTypeConcurrentMap) ToUnsafeMap() map[byte]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteBoolKeyValue struct {
	Key   byte
	Value bool
}

type ByteBoolConcurrentMapOption func(*ByteBoolConcurrentMap)

func WithUnsafeByteBoolMap(m map[byte]bool) ByteBoolConcurrentMapOption {
	return func(cm *ByteBoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteBoolMap(m map[byte]bool) ByteBoolConcurrentMapOption {
	return func(cm *ByteBoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteBoolConcurrentMap(opts ...ByteBoolConcurrentMapOption) *ByteBoolConcurrentMap {
	cm := &ByteBoolConcurrentMap{
		m: make(map[byte]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteBoolMapKeyValue struct {
	Key   byte
	Value bool
}

type ByteBoolConcurrentMap struct {
	m map[byte]bool
	L *sync.RWMutex
}

func (cm *ByteBoolConcurrentMap) Get(k byte) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteBoolConcurrentMap) GetDefault(k byte, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteBoolConcurrentMap) GetOK(k byte) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteBoolConcurrentMap) Set(k byte, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteBoolConcurrentMap) Delete(k byte) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteBoolConcurrentMap) SetKeyValues(kvs ...ByteBoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteBoolConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteBoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteBoolConcurrentMap) KeyValues() []ByteBoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteBoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteBoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteBoolConcurrentMap) ToUnsafeMap() map[byte]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type ByteStringKeyValue struct {
	Key   byte
	Value string
}

type ByteStringConcurrentMapOption func(*ByteStringConcurrentMap)

func WithUnsafeByteStringMap(m map[byte]string) ByteStringConcurrentMapOption {
	return func(cm *ByteStringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithByteStringMap(m map[byte]string) ByteStringConcurrentMapOption {
	return func(cm *ByteStringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewByteStringConcurrentMap(opts ...ByteStringConcurrentMapOption) *ByteStringConcurrentMap {
	cm := &ByteStringConcurrentMap{
		m: make(map[byte]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type ByteStringMapKeyValue struct {
	Key   byte
	Value string
}

type ByteStringConcurrentMap struct {
	m map[byte]string
	L *sync.RWMutex
}

func (cm *ByteStringConcurrentMap) Get(k byte) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *ByteStringConcurrentMap) GetDefault(k byte, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *ByteStringConcurrentMap) GetOK(k byte) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *ByteStringConcurrentMap) Set(k byte, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *ByteStringConcurrentMap) Delete(k byte) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *ByteStringConcurrentMap) SetKeyValues(kvs ...ByteStringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *ByteStringConcurrentMap) Keys() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []byte
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *ByteStringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *ByteStringConcurrentMap) KeyValues() []ByteStringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []ByteStringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, ByteStringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *ByteStringConcurrentMap) ToUnsafeMap() map[byte]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[byte]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneByteKeyValue struct {
	Key   rune
	Value byte
}

type RuneByteConcurrentMapOption func(*RuneByteConcurrentMap)

func WithUnsafeRuneByteMap(m map[rune]byte) RuneByteConcurrentMapOption {
	return func(cm *RuneByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneByteMap(m map[rune]byte) RuneByteConcurrentMapOption {
	return func(cm *RuneByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneByteConcurrentMap(opts ...RuneByteConcurrentMapOption) *RuneByteConcurrentMap {
	cm := &RuneByteConcurrentMap{
		m: make(map[rune]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneByteMapKeyValue struct {
	Key   rune
	Value byte
}

type RuneByteConcurrentMap struct {
	m map[rune]byte
	L *sync.RWMutex
}

func (cm *RuneByteConcurrentMap) Get(k rune) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneByteConcurrentMap) GetDefault(k rune, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneByteConcurrentMap) GetOK(k rune) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneByteConcurrentMap) Set(k rune, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneByteConcurrentMap) Delete(k rune) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneByteConcurrentMap) SetKeyValues(kvs ...RuneByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneByteConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneByteConcurrentMap) KeyValues() []RuneByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneByteConcurrentMap) ToUnsafeMap() map[rune]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneRuneKeyValue struct {
	Key   rune
	Value rune
}

type RuneRuneConcurrentMapOption func(*RuneRuneConcurrentMap)

func WithUnsafeRuneRuneMap(m map[rune]rune) RuneRuneConcurrentMapOption {
	return func(cm *RuneRuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneRuneMap(m map[rune]rune) RuneRuneConcurrentMapOption {
	return func(cm *RuneRuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneRuneConcurrentMap(opts ...RuneRuneConcurrentMapOption) *RuneRuneConcurrentMap {
	cm := &RuneRuneConcurrentMap{
		m: make(map[rune]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneRuneMapKeyValue struct {
	Key   rune
	Value rune
}

type RuneRuneConcurrentMap struct {
	m map[rune]rune
	L *sync.RWMutex
}

func (cm *RuneRuneConcurrentMap) Get(k rune) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneRuneConcurrentMap) GetDefault(k rune, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneRuneConcurrentMap) GetOK(k rune) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneRuneConcurrentMap) Set(k rune, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneRuneConcurrentMap) Delete(k rune) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneRuneConcurrentMap) SetKeyValues(kvs ...RuneRuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneRuneConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneRuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneRuneConcurrentMap) KeyValues() []RuneRuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneRuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneRuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneRuneConcurrentMap) ToUnsafeMap() map[rune]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneUintKeyValue struct {
	Key   rune
	Value uint
}

type RuneUintConcurrentMapOption func(*RuneUintConcurrentMap)

func WithUnsafeRuneUintMap(m map[rune]uint) RuneUintConcurrentMapOption {
	return func(cm *RuneUintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneUintMap(m map[rune]uint) RuneUintConcurrentMapOption {
	return func(cm *RuneUintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneUintConcurrentMap(opts ...RuneUintConcurrentMapOption) *RuneUintConcurrentMap {
	cm := &RuneUintConcurrentMap{
		m: make(map[rune]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneUintMapKeyValue struct {
	Key   rune
	Value uint
}

type RuneUintConcurrentMap struct {
	m map[rune]uint
	L *sync.RWMutex
}

func (cm *RuneUintConcurrentMap) Get(k rune) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneUintConcurrentMap) GetDefault(k rune, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneUintConcurrentMap) GetOK(k rune) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneUintConcurrentMap) Set(k rune, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneUintConcurrentMap) Delete(k rune) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneUintConcurrentMap) SetKeyValues(kvs ...RuneUintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneUintConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneUintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneUintConcurrentMap) KeyValues() []RuneUintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneUintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneUintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneUintConcurrentMap) ToUnsafeMap() map[rune]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneUint8KeyValue struct {
	Key   rune
	Value uint8
}

type RuneUint8ConcurrentMapOption func(*RuneUint8ConcurrentMap)

func WithUnsafeRuneUint8Map(m map[rune]uint8) RuneUint8ConcurrentMapOption {
	return func(cm *RuneUint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneUint8Map(m map[rune]uint8) RuneUint8ConcurrentMapOption {
	return func(cm *RuneUint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneUint8ConcurrentMap(opts ...RuneUint8ConcurrentMapOption) *RuneUint8ConcurrentMap {
	cm := &RuneUint8ConcurrentMap{
		m: make(map[rune]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneUint8MapKeyValue struct {
	Key   rune
	Value uint8
}

type RuneUint8ConcurrentMap struct {
	m map[rune]uint8
	L *sync.RWMutex
}

func (cm *RuneUint8ConcurrentMap) Get(k rune) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneUint8ConcurrentMap) GetDefault(k rune, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneUint8ConcurrentMap) GetOK(k rune) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneUint8ConcurrentMap) Set(k rune, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneUint8ConcurrentMap) Delete(k rune) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneUint8ConcurrentMap) SetKeyValues(kvs ...RuneUint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneUint8ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneUint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneUint8ConcurrentMap) KeyValues() []RuneUint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneUint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneUint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneUint8ConcurrentMap) ToUnsafeMap() map[rune]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneUint16KeyValue struct {
	Key   rune
	Value uint16
}

type RuneUint16ConcurrentMapOption func(*RuneUint16ConcurrentMap)

func WithUnsafeRuneUint16Map(m map[rune]uint16) RuneUint16ConcurrentMapOption {
	return func(cm *RuneUint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneUint16Map(m map[rune]uint16) RuneUint16ConcurrentMapOption {
	return func(cm *RuneUint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneUint16ConcurrentMap(opts ...RuneUint16ConcurrentMapOption) *RuneUint16ConcurrentMap {
	cm := &RuneUint16ConcurrentMap{
		m: make(map[rune]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneUint16MapKeyValue struct {
	Key   rune
	Value uint16
}

type RuneUint16ConcurrentMap struct {
	m map[rune]uint16
	L *sync.RWMutex
}

func (cm *RuneUint16ConcurrentMap) Get(k rune) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneUint16ConcurrentMap) GetDefault(k rune, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneUint16ConcurrentMap) GetOK(k rune) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneUint16ConcurrentMap) Set(k rune, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneUint16ConcurrentMap) Delete(k rune) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneUint16ConcurrentMap) SetKeyValues(kvs ...RuneUint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneUint16ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneUint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneUint16ConcurrentMap) KeyValues() []RuneUint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneUint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneUint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneUint16ConcurrentMap) ToUnsafeMap() map[rune]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneInterfaceKeyValue struct {
	Key   rune
	Value Interface
}

type RuneInterfaceConcurrentMapOption func(*RuneInterfaceConcurrentMap)

func WithUnsafeRuneInterfaceMap(m map[rune]Interface) RuneInterfaceConcurrentMapOption {
	return func(cm *RuneInterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneInterfaceMap(m map[rune]Interface) RuneInterfaceConcurrentMapOption {
	return func(cm *RuneInterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneInterfaceConcurrentMap(opts ...RuneInterfaceConcurrentMapOption) *RuneInterfaceConcurrentMap {
	cm := &RuneInterfaceConcurrentMap{
		m: make(map[rune]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneInterfaceMapKeyValue struct {
	Key   rune
	Value Interface
}

type RuneInterfaceConcurrentMap struct {
	m map[rune]Interface
	L *sync.RWMutex
}

func (cm *RuneInterfaceConcurrentMap) Get(k rune) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneInterfaceConcurrentMap) GetDefault(k rune, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneInterfaceConcurrentMap) GetOK(k rune) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneInterfaceConcurrentMap) Set(k rune, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneInterfaceConcurrentMap) Delete(k rune) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneInterfaceConcurrentMap) SetKeyValues(kvs ...RuneInterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneInterfaceConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneInterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneInterfaceConcurrentMap) KeyValues() []RuneInterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneInterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneInterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneInterfaceConcurrentMap) ToUnsafeMap() map[rune]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneUint32KeyValue struct {
	Key   rune
	Value uint32
}

type RuneUint32ConcurrentMapOption func(*RuneUint32ConcurrentMap)

func WithUnsafeRuneUint32Map(m map[rune]uint32) RuneUint32ConcurrentMapOption {
	return func(cm *RuneUint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneUint32Map(m map[rune]uint32) RuneUint32ConcurrentMapOption {
	return func(cm *RuneUint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneUint32ConcurrentMap(opts ...RuneUint32ConcurrentMapOption) *RuneUint32ConcurrentMap {
	cm := &RuneUint32ConcurrentMap{
		m: make(map[rune]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneUint32MapKeyValue struct {
	Key   rune
	Value uint32
}

type RuneUint32ConcurrentMap struct {
	m map[rune]uint32
	L *sync.RWMutex
}

func (cm *RuneUint32ConcurrentMap) Get(k rune) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneUint32ConcurrentMap) GetDefault(k rune, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneUint32ConcurrentMap) GetOK(k rune) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneUint32ConcurrentMap) Set(k rune, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneUint32ConcurrentMap) Delete(k rune) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneUint32ConcurrentMap) SetKeyValues(kvs ...RuneUint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneUint32ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneUint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneUint32ConcurrentMap) KeyValues() []RuneUint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneUint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneUint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneUint32ConcurrentMap) ToUnsafeMap() map[rune]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneUint64KeyValue struct {
	Key   rune
	Value uint64
}

type RuneUint64ConcurrentMapOption func(*RuneUint64ConcurrentMap)

func WithUnsafeRuneUint64Map(m map[rune]uint64) RuneUint64ConcurrentMapOption {
	return func(cm *RuneUint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneUint64Map(m map[rune]uint64) RuneUint64ConcurrentMapOption {
	return func(cm *RuneUint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneUint64ConcurrentMap(opts ...RuneUint64ConcurrentMapOption) *RuneUint64ConcurrentMap {
	cm := &RuneUint64ConcurrentMap{
		m: make(map[rune]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneUint64MapKeyValue struct {
	Key   rune
	Value uint64
}

type RuneUint64ConcurrentMap struct {
	m map[rune]uint64
	L *sync.RWMutex
}

func (cm *RuneUint64ConcurrentMap) Get(k rune) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneUint64ConcurrentMap) GetDefault(k rune, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneUint64ConcurrentMap) GetOK(k rune) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneUint64ConcurrentMap) Set(k rune, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneUint64ConcurrentMap) Delete(k rune) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneUint64ConcurrentMap) SetKeyValues(kvs ...RuneUint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneUint64ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneUint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneUint64ConcurrentMap) KeyValues() []RuneUint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneUint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneUint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneUint64ConcurrentMap) ToUnsafeMap() map[rune]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneIntKeyValue struct {
	Key   rune
	Value int
}

type RuneIntConcurrentMapOption func(*RuneIntConcurrentMap)

func WithUnsafeRuneIntMap(m map[rune]int) RuneIntConcurrentMapOption {
	return func(cm *RuneIntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneIntMap(m map[rune]int) RuneIntConcurrentMapOption {
	return func(cm *RuneIntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneIntConcurrentMap(opts ...RuneIntConcurrentMapOption) *RuneIntConcurrentMap {
	cm := &RuneIntConcurrentMap{
		m: make(map[rune]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneIntMapKeyValue struct {
	Key   rune
	Value int
}

type RuneIntConcurrentMap struct {
	m map[rune]int
	L *sync.RWMutex
}

func (cm *RuneIntConcurrentMap) Get(k rune) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneIntConcurrentMap) GetDefault(k rune, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneIntConcurrentMap) GetOK(k rune) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneIntConcurrentMap) Set(k rune, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneIntConcurrentMap) Delete(k rune) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneIntConcurrentMap) SetKeyValues(kvs ...RuneIntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneIntConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneIntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneIntConcurrentMap) KeyValues() []RuneIntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneIntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneIntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneIntConcurrentMap) ToUnsafeMap() map[rune]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneInt8KeyValue struct {
	Key   rune
	Value int8
}

type RuneInt8ConcurrentMapOption func(*RuneInt8ConcurrentMap)

func WithUnsafeRuneInt8Map(m map[rune]int8) RuneInt8ConcurrentMapOption {
	return func(cm *RuneInt8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneInt8Map(m map[rune]int8) RuneInt8ConcurrentMapOption {
	return func(cm *RuneInt8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneInt8ConcurrentMap(opts ...RuneInt8ConcurrentMapOption) *RuneInt8ConcurrentMap {
	cm := &RuneInt8ConcurrentMap{
		m: make(map[rune]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneInt8MapKeyValue struct {
	Key   rune
	Value int8
}

type RuneInt8ConcurrentMap struct {
	m map[rune]int8
	L *sync.RWMutex
}

func (cm *RuneInt8ConcurrentMap) Get(k rune) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneInt8ConcurrentMap) GetDefault(k rune, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneInt8ConcurrentMap) GetOK(k rune) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneInt8ConcurrentMap) Set(k rune, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneInt8ConcurrentMap) Delete(k rune) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneInt8ConcurrentMap) SetKeyValues(kvs ...RuneInt8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneInt8ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneInt8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneInt8ConcurrentMap) KeyValues() []RuneInt8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneInt8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneInt8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneInt8ConcurrentMap) ToUnsafeMap() map[rune]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneInt16KeyValue struct {
	Key   rune
	Value int16
}

type RuneInt16ConcurrentMapOption func(*RuneInt16ConcurrentMap)

func WithUnsafeRuneInt16Map(m map[rune]int16) RuneInt16ConcurrentMapOption {
	return func(cm *RuneInt16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneInt16Map(m map[rune]int16) RuneInt16ConcurrentMapOption {
	return func(cm *RuneInt16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneInt16ConcurrentMap(opts ...RuneInt16ConcurrentMapOption) *RuneInt16ConcurrentMap {
	cm := &RuneInt16ConcurrentMap{
		m: make(map[rune]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneInt16MapKeyValue struct {
	Key   rune
	Value int16
}

type RuneInt16ConcurrentMap struct {
	m map[rune]int16
	L *sync.RWMutex
}

func (cm *RuneInt16ConcurrentMap) Get(k rune) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneInt16ConcurrentMap) GetDefault(k rune, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneInt16ConcurrentMap) GetOK(k rune) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneInt16ConcurrentMap) Set(k rune, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneInt16ConcurrentMap) Delete(k rune) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneInt16ConcurrentMap) SetKeyValues(kvs ...RuneInt16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneInt16ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneInt16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneInt16ConcurrentMap) KeyValues() []RuneInt16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneInt16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneInt16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneInt16ConcurrentMap) ToUnsafeMap() map[rune]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneInt32KeyValue struct {
	Key   rune
	Value int32
}

type RuneInt32ConcurrentMapOption func(*RuneInt32ConcurrentMap)

func WithUnsafeRuneInt32Map(m map[rune]int32) RuneInt32ConcurrentMapOption {
	return func(cm *RuneInt32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneInt32Map(m map[rune]int32) RuneInt32ConcurrentMapOption {
	return func(cm *RuneInt32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneInt32ConcurrentMap(opts ...RuneInt32ConcurrentMapOption) *RuneInt32ConcurrentMap {
	cm := &RuneInt32ConcurrentMap{
		m: make(map[rune]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneInt32MapKeyValue struct {
	Key   rune
	Value int32
}

type RuneInt32ConcurrentMap struct {
	m map[rune]int32
	L *sync.RWMutex
}

func (cm *RuneInt32ConcurrentMap) Get(k rune) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneInt32ConcurrentMap) GetDefault(k rune, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneInt32ConcurrentMap) GetOK(k rune) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneInt32ConcurrentMap) Set(k rune, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneInt32ConcurrentMap) Delete(k rune) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneInt32ConcurrentMap) SetKeyValues(kvs ...RuneInt32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneInt32ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneInt32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneInt32ConcurrentMap) KeyValues() []RuneInt32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneInt32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneInt32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneInt32ConcurrentMap) ToUnsafeMap() map[rune]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneInt64KeyValue struct {
	Key   rune
	Value int64
}

type RuneInt64ConcurrentMapOption func(*RuneInt64ConcurrentMap)

func WithUnsafeRuneInt64Map(m map[rune]int64) RuneInt64ConcurrentMapOption {
	return func(cm *RuneInt64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneInt64Map(m map[rune]int64) RuneInt64ConcurrentMapOption {
	return func(cm *RuneInt64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneInt64ConcurrentMap(opts ...RuneInt64ConcurrentMapOption) *RuneInt64ConcurrentMap {
	cm := &RuneInt64ConcurrentMap{
		m: make(map[rune]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneInt64MapKeyValue struct {
	Key   rune
	Value int64
}

type RuneInt64ConcurrentMap struct {
	m map[rune]int64
	L *sync.RWMutex
}

func (cm *RuneInt64ConcurrentMap) Get(k rune) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneInt64ConcurrentMap) GetDefault(k rune, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneInt64ConcurrentMap) GetOK(k rune) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneInt64ConcurrentMap) Set(k rune, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneInt64ConcurrentMap) Delete(k rune) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneInt64ConcurrentMap) SetKeyValues(kvs ...RuneInt64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneInt64ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneInt64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneInt64ConcurrentMap) KeyValues() []RuneInt64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneInt64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneInt64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneInt64ConcurrentMap) ToUnsafeMap() map[rune]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneFloat32KeyValue struct {
	Key   rune
	Value float32
}

type RuneFloat32ConcurrentMapOption func(*RuneFloat32ConcurrentMap)

func WithUnsafeRuneFloat32Map(m map[rune]float32) RuneFloat32ConcurrentMapOption {
	return func(cm *RuneFloat32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneFloat32Map(m map[rune]float32) RuneFloat32ConcurrentMapOption {
	return func(cm *RuneFloat32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneFloat32ConcurrentMap(opts ...RuneFloat32ConcurrentMapOption) *RuneFloat32ConcurrentMap {
	cm := &RuneFloat32ConcurrentMap{
		m: make(map[rune]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneFloat32MapKeyValue struct {
	Key   rune
	Value float32
}

type RuneFloat32ConcurrentMap struct {
	m map[rune]float32
	L *sync.RWMutex
}

func (cm *RuneFloat32ConcurrentMap) Get(k rune) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneFloat32ConcurrentMap) GetDefault(k rune, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneFloat32ConcurrentMap) GetOK(k rune) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneFloat32ConcurrentMap) Set(k rune, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneFloat32ConcurrentMap) Delete(k rune) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneFloat32ConcurrentMap) SetKeyValues(kvs ...RuneFloat32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneFloat32ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneFloat32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneFloat32ConcurrentMap) KeyValues() []RuneFloat32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneFloat32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneFloat32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneFloat32ConcurrentMap) ToUnsafeMap() map[rune]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneFloat64KeyValue struct {
	Key   rune
	Value float64
}

type RuneFloat64ConcurrentMapOption func(*RuneFloat64ConcurrentMap)

func WithUnsafeRuneFloat64Map(m map[rune]float64) RuneFloat64ConcurrentMapOption {
	return func(cm *RuneFloat64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneFloat64Map(m map[rune]float64) RuneFloat64ConcurrentMapOption {
	return func(cm *RuneFloat64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneFloat64ConcurrentMap(opts ...RuneFloat64ConcurrentMapOption) *RuneFloat64ConcurrentMap {
	cm := &RuneFloat64ConcurrentMap{
		m: make(map[rune]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneFloat64MapKeyValue struct {
	Key   rune
	Value float64
}

type RuneFloat64ConcurrentMap struct {
	m map[rune]float64
	L *sync.RWMutex
}

func (cm *RuneFloat64ConcurrentMap) Get(k rune) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneFloat64ConcurrentMap) GetDefault(k rune, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneFloat64ConcurrentMap) GetOK(k rune) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneFloat64ConcurrentMap) Set(k rune, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneFloat64ConcurrentMap) Delete(k rune) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneFloat64ConcurrentMap) SetKeyValues(kvs ...RuneFloat64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneFloat64ConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneFloat64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneFloat64ConcurrentMap) KeyValues() []RuneFloat64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneFloat64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneFloat64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneFloat64ConcurrentMap) ToUnsafeMap() map[rune]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneTypeKeyValue struct {
	Key   rune
	Value Type
}

type RuneTypeConcurrentMapOption func(*RuneTypeConcurrentMap)

func WithUnsafeRuneTypeMap(m map[rune]Type) RuneTypeConcurrentMapOption {
	return func(cm *RuneTypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneTypeMap(m map[rune]Type) RuneTypeConcurrentMapOption {
	return func(cm *RuneTypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneTypeConcurrentMap(opts ...RuneTypeConcurrentMapOption) *RuneTypeConcurrentMap {
	cm := &RuneTypeConcurrentMap{
		m: make(map[rune]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneTypeMapKeyValue struct {
	Key   rune
	Value Type
}

type RuneTypeConcurrentMap struct {
	m map[rune]Type
	L *sync.RWMutex
}

func (cm *RuneTypeConcurrentMap) Get(k rune) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneTypeConcurrentMap) GetDefault(k rune, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneTypeConcurrentMap) GetOK(k rune) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneTypeConcurrentMap) Set(k rune, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneTypeConcurrentMap) Delete(k rune) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneTypeConcurrentMap) SetKeyValues(kvs ...RuneTypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneTypeConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneTypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneTypeConcurrentMap) KeyValues() []RuneTypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneTypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneTypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneTypeConcurrentMap) ToUnsafeMap() map[rune]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneBoolKeyValue struct {
	Key   rune
	Value bool
}

type RuneBoolConcurrentMapOption func(*RuneBoolConcurrentMap)

func WithUnsafeRuneBoolMap(m map[rune]bool) RuneBoolConcurrentMapOption {
	return func(cm *RuneBoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneBoolMap(m map[rune]bool) RuneBoolConcurrentMapOption {
	return func(cm *RuneBoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneBoolConcurrentMap(opts ...RuneBoolConcurrentMapOption) *RuneBoolConcurrentMap {
	cm := &RuneBoolConcurrentMap{
		m: make(map[rune]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneBoolMapKeyValue struct {
	Key   rune
	Value bool
}

type RuneBoolConcurrentMap struct {
	m map[rune]bool
	L *sync.RWMutex
}

func (cm *RuneBoolConcurrentMap) Get(k rune) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneBoolConcurrentMap) GetDefault(k rune, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneBoolConcurrentMap) GetOK(k rune) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneBoolConcurrentMap) Set(k rune, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneBoolConcurrentMap) Delete(k rune) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneBoolConcurrentMap) SetKeyValues(kvs ...RuneBoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneBoolConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneBoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneBoolConcurrentMap) KeyValues() []RuneBoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneBoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneBoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneBoolConcurrentMap) ToUnsafeMap() map[rune]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type RuneStringKeyValue struct {
	Key   rune
	Value string
}

type RuneStringConcurrentMapOption func(*RuneStringConcurrentMap)

func WithUnsafeRuneStringMap(m map[rune]string) RuneStringConcurrentMapOption {
	return func(cm *RuneStringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithRuneStringMap(m map[rune]string) RuneStringConcurrentMapOption {
	return func(cm *RuneStringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewRuneStringConcurrentMap(opts ...RuneStringConcurrentMapOption) *RuneStringConcurrentMap {
	cm := &RuneStringConcurrentMap{
		m: make(map[rune]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type RuneStringMapKeyValue struct {
	Key   rune
	Value string
}

type RuneStringConcurrentMap struct {
	m map[rune]string
	L *sync.RWMutex
}

func (cm *RuneStringConcurrentMap) Get(k rune) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *RuneStringConcurrentMap) GetDefault(k rune, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *RuneStringConcurrentMap) GetOK(k rune) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *RuneStringConcurrentMap) Set(k rune, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *RuneStringConcurrentMap) Delete(k rune) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *RuneStringConcurrentMap) SetKeyValues(kvs ...RuneStringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *RuneStringConcurrentMap) Keys() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []rune
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *RuneStringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *RuneStringConcurrentMap) KeyValues() []RuneStringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []RuneStringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, RuneStringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *RuneStringConcurrentMap) ToUnsafeMap() map[rune]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[rune]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintByteKeyValue struct {
	Key   uint
	Value byte
}

type UintByteConcurrentMapOption func(*UintByteConcurrentMap)

func WithUnsafeUintByteMap(m map[uint]byte) UintByteConcurrentMapOption {
	return func(cm *UintByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintByteMap(m map[uint]byte) UintByteConcurrentMapOption {
	return func(cm *UintByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintByteConcurrentMap(opts ...UintByteConcurrentMapOption) *UintByteConcurrentMap {
	cm := &UintByteConcurrentMap{
		m: make(map[uint]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintByteMapKeyValue struct {
	Key   uint
	Value byte
}

type UintByteConcurrentMap struct {
	m map[uint]byte
	L *sync.RWMutex
}

func (cm *UintByteConcurrentMap) Get(k uint) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintByteConcurrentMap) GetDefault(k uint, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintByteConcurrentMap) GetOK(k uint) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintByteConcurrentMap) Set(k uint, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintByteConcurrentMap) Delete(k uint) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintByteConcurrentMap) SetKeyValues(kvs ...UintByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintByteConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintByteConcurrentMap) KeyValues() []UintByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintByteConcurrentMap) ToUnsafeMap() map[uint]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintRuneKeyValue struct {
	Key   uint
	Value rune
}

type UintRuneConcurrentMapOption func(*UintRuneConcurrentMap)

func WithUnsafeUintRuneMap(m map[uint]rune) UintRuneConcurrentMapOption {
	return func(cm *UintRuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintRuneMap(m map[uint]rune) UintRuneConcurrentMapOption {
	return func(cm *UintRuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintRuneConcurrentMap(opts ...UintRuneConcurrentMapOption) *UintRuneConcurrentMap {
	cm := &UintRuneConcurrentMap{
		m: make(map[uint]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintRuneMapKeyValue struct {
	Key   uint
	Value rune
}

type UintRuneConcurrentMap struct {
	m map[uint]rune
	L *sync.RWMutex
}

func (cm *UintRuneConcurrentMap) Get(k uint) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintRuneConcurrentMap) GetDefault(k uint, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintRuneConcurrentMap) GetOK(k uint) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintRuneConcurrentMap) Set(k uint, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintRuneConcurrentMap) Delete(k uint) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintRuneConcurrentMap) SetKeyValues(kvs ...UintRuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintRuneConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintRuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintRuneConcurrentMap) KeyValues() []UintRuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintRuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintRuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintRuneConcurrentMap) ToUnsafeMap() map[uint]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintUintKeyValue struct {
	Key   uint
	Value uint
}

type UintUintConcurrentMapOption func(*UintUintConcurrentMap)

func WithUnsafeUintUintMap(m map[uint]uint) UintUintConcurrentMapOption {
	return func(cm *UintUintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintUintMap(m map[uint]uint) UintUintConcurrentMapOption {
	return func(cm *UintUintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintUintConcurrentMap(opts ...UintUintConcurrentMapOption) *UintUintConcurrentMap {
	cm := &UintUintConcurrentMap{
		m: make(map[uint]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintUintMapKeyValue struct {
	Key   uint
	Value uint
}

type UintUintConcurrentMap struct {
	m map[uint]uint
	L *sync.RWMutex
}

func (cm *UintUintConcurrentMap) Get(k uint) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintUintConcurrentMap) GetDefault(k uint, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintUintConcurrentMap) GetOK(k uint) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintUintConcurrentMap) Set(k uint, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintUintConcurrentMap) Delete(k uint) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintUintConcurrentMap) SetKeyValues(kvs ...UintUintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintUintConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintUintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintUintConcurrentMap) KeyValues() []UintUintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintUintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintUintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintUintConcurrentMap) ToUnsafeMap() map[uint]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintUint8KeyValue struct {
	Key   uint
	Value uint8
}

type UintUint8ConcurrentMapOption func(*UintUint8ConcurrentMap)

func WithUnsafeUintUint8Map(m map[uint]uint8) UintUint8ConcurrentMapOption {
	return func(cm *UintUint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintUint8Map(m map[uint]uint8) UintUint8ConcurrentMapOption {
	return func(cm *UintUint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintUint8ConcurrentMap(opts ...UintUint8ConcurrentMapOption) *UintUint8ConcurrentMap {
	cm := &UintUint8ConcurrentMap{
		m: make(map[uint]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintUint8MapKeyValue struct {
	Key   uint
	Value uint8
}

type UintUint8ConcurrentMap struct {
	m map[uint]uint8
	L *sync.RWMutex
}

func (cm *UintUint8ConcurrentMap) Get(k uint) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintUint8ConcurrentMap) GetDefault(k uint, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintUint8ConcurrentMap) GetOK(k uint) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintUint8ConcurrentMap) Set(k uint, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintUint8ConcurrentMap) Delete(k uint) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintUint8ConcurrentMap) SetKeyValues(kvs ...UintUint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintUint8ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintUint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintUint8ConcurrentMap) KeyValues() []UintUint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintUint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintUint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintUint8ConcurrentMap) ToUnsafeMap() map[uint]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintUint16KeyValue struct {
	Key   uint
	Value uint16
}

type UintUint16ConcurrentMapOption func(*UintUint16ConcurrentMap)

func WithUnsafeUintUint16Map(m map[uint]uint16) UintUint16ConcurrentMapOption {
	return func(cm *UintUint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintUint16Map(m map[uint]uint16) UintUint16ConcurrentMapOption {
	return func(cm *UintUint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintUint16ConcurrentMap(opts ...UintUint16ConcurrentMapOption) *UintUint16ConcurrentMap {
	cm := &UintUint16ConcurrentMap{
		m: make(map[uint]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintUint16MapKeyValue struct {
	Key   uint
	Value uint16
}

type UintUint16ConcurrentMap struct {
	m map[uint]uint16
	L *sync.RWMutex
}

func (cm *UintUint16ConcurrentMap) Get(k uint) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintUint16ConcurrentMap) GetDefault(k uint, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintUint16ConcurrentMap) GetOK(k uint) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintUint16ConcurrentMap) Set(k uint, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintUint16ConcurrentMap) Delete(k uint) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintUint16ConcurrentMap) SetKeyValues(kvs ...UintUint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintUint16ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintUint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintUint16ConcurrentMap) KeyValues() []UintUint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintUint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintUint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintUint16ConcurrentMap) ToUnsafeMap() map[uint]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintInterfaceKeyValue struct {
	Key   uint
	Value Interface
}

type UintInterfaceConcurrentMapOption func(*UintInterfaceConcurrentMap)

func WithUnsafeUintInterfaceMap(m map[uint]Interface) UintInterfaceConcurrentMapOption {
	return func(cm *UintInterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintInterfaceMap(m map[uint]Interface) UintInterfaceConcurrentMapOption {
	return func(cm *UintInterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintInterfaceConcurrentMap(opts ...UintInterfaceConcurrentMapOption) *UintInterfaceConcurrentMap {
	cm := &UintInterfaceConcurrentMap{
		m: make(map[uint]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintInterfaceMapKeyValue struct {
	Key   uint
	Value Interface
}

type UintInterfaceConcurrentMap struct {
	m map[uint]Interface
	L *sync.RWMutex
}

func (cm *UintInterfaceConcurrentMap) Get(k uint) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintInterfaceConcurrentMap) GetDefault(k uint, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintInterfaceConcurrentMap) GetOK(k uint) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintInterfaceConcurrentMap) Set(k uint, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintInterfaceConcurrentMap) Delete(k uint) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintInterfaceConcurrentMap) SetKeyValues(kvs ...UintInterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintInterfaceConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintInterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintInterfaceConcurrentMap) KeyValues() []UintInterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintInterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintInterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintInterfaceConcurrentMap) ToUnsafeMap() map[uint]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintUint32KeyValue struct {
	Key   uint
	Value uint32
}

type UintUint32ConcurrentMapOption func(*UintUint32ConcurrentMap)

func WithUnsafeUintUint32Map(m map[uint]uint32) UintUint32ConcurrentMapOption {
	return func(cm *UintUint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintUint32Map(m map[uint]uint32) UintUint32ConcurrentMapOption {
	return func(cm *UintUint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintUint32ConcurrentMap(opts ...UintUint32ConcurrentMapOption) *UintUint32ConcurrentMap {
	cm := &UintUint32ConcurrentMap{
		m: make(map[uint]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintUint32MapKeyValue struct {
	Key   uint
	Value uint32
}

type UintUint32ConcurrentMap struct {
	m map[uint]uint32
	L *sync.RWMutex
}

func (cm *UintUint32ConcurrentMap) Get(k uint) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintUint32ConcurrentMap) GetDefault(k uint, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintUint32ConcurrentMap) GetOK(k uint) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintUint32ConcurrentMap) Set(k uint, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintUint32ConcurrentMap) Delete(k uint) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintUint32ConcurrentMap) SetKeyValues(kvs ...UintUint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintUint32ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintUint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintUint32ConcurrentMap) KeyValues() []UintUint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintUint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintUint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintUint32ConcurrentMap) ToUnsafeMap() map[uint]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintUint64KeyValue struct {
	Key   uint
	Value uint64
}

type UintUint64ConcurrentMapOption func(*UintUint64ConcurrentMap)

func WithUnsafeUintUint64Map(m map[uint]uint64) UintUint64ConcurrentMapOption {
	return func(cm *UintUint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintUint64Map(m map[uint]uint64) UintUint64ConcurrentMapOption {
	return func(cm *UintUint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintUint64ConcurrentMap(opts ...UintUint64ConcurrentMapOption) *UintUint64ConcurrentMap {
	cm := &UintUint64ConcurrentMap{
		m: make(map[uint]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintUint64MapKeyValue struct {
	Key   uint
	Value uint64
}

type UintUint64ConcurrentMap struct {
	m map[uint]uint64
	L *sync.RWMutex
}

func (cm *UintUint64ConcurrentMap) Get(k uint) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintUint64ConcurrentMap) GetDefault(k uint, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintUint64ConcurrentMap) GetOK(k uint) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintUint64ConcurrentMap) Set(k uint, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintUint64ConcurrentMap) Delete(k uint) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintUint64ConcurrentMap) SetKeyValues(kvs ...UintUint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintUint64ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintUint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintUint64ConcurrentMap) KeyValues() []UintUint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintUint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintUint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintUint64ConcurrentMap) ToUnsafeMap() map[uint]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintIntKeyValue struct {
	Key   uint
	Value int
}

type UintIntConcurrentMapOption func(*UintIntConcurrentMap)

func WithUnsafeUintIntMap(m map[uint]int) UintIntConcurrentMapOption {
	return func(cm *UintIntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintIntMap(m map[uint]int) UintIntConcurrentMapOption {
	return func(cm *UintIntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintIntConcurrentMap(opts ...UintIntConcurrentMapOption) *UintIntConcurrentMap {
	cm := &UintIntConcurrentMap{
		m: make(map[uint]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintIntMapKeyValue struct {
	Key   uint
	Value int
}

type UintIntConcurrentMap struct {
	m map[uint]int
	L *sync.RWMutex
}

func (cm *UintIntConcurrentMap) Get(k uint) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintIntConcurrentMap) GetDefault(k uint, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintIntConcurrentMap) GetOK(k uint) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintIntConcurrentMap) Set(k uint, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintIntConcurrentMap) Delete(k uint) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintIntConcurrentMap) SetKeyValues(kvs ...UintIntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintIntConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintIntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintIntConcurrentMap) KeyValues() []UintIntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintIntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintIntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintIntConcurrentMap) ToUnsafeMap() map[uint]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintInt8KeyValue struct {
	Key   uint
	Value int8
}

type UintInt8ConcurrentMapOption func(*UintInt8ConcurrentMap)

func WithUnsafeUintInt8Map(m map[uint]int8) UintInt8ConcurrentMapOption {
	return func(cm *UintInt8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintInt8Map(m map[uint]int8) UintInt8ConcurrentMapOption {
	return func(cm *UintInt8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintInt8ConcurrentMap(opts ...UintInt8ConcurrentMapOption) *UintInt8ConcurrentMap {
	cm := &UintInt8ConcurrentMap{
		m: make(map[uint]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintInt8MapKeyValue struct {
	Key   uint
	Value int8
}

type UintInt8ConcurrentMap struct {
	m map[uint]int8
	L *sync.RWMutex
}

func (cm *UintInt8ConcurrentMap) Get(k uint) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintInt8ConcurrentMap) GetDefault(k uint, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintInt8ConcurrentMap) GetOK(k uint) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintInt8ConcurrentMap) Set(k uint, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintInt8ConcurrentMap) Delete(k uint) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintInt8ConcurrentMap) SetKeyValues(kvs ...UintInt8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintInt8ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintInt8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintInt8ConcurrentMap) KeyValues() []UintInt8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintInt8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintInt8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintInt8ConcurrentMap) ToUnsafeMap() map[uint]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintInt16KeyValue struct {
	Key   uint
	Value int16
}

type UintInt16ConcurrentMapOption func(*UintInt16ConcurrentMap)

func WithUnsafeUintInt16Map(m map[uint]int16) UintInt16ConcurrentMapOption {
	return func(cm *UintInt16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintInt16Map(m map[uint]int16) UintInt16ConcurrentMapOption {
	return func(cm *UintInt16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintInt16ConcurrentMap(opts ...UintInt16ConcurrentMapOption) *UintInt16ConcurrentMap {
	cm := &UintInt16ConcurrentMap{
		m: make(map[uint]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintInt16MapKeyValue struct {
	Key   uint
	Value int16
}

type UintInt16ConcurrentMap struct {
	m map[uint]int16
	L *sync.RWMutex
}

func (cm *UintInt16ConcurrentMap) Get(k uint) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintInt16ConcurrentMap) GetDefault(k uint, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintInt16ConcurrentMap) GetOK(k uint) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintInt16ConcurrentMap) Set(k uint, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintInt16ConcurrentMap) Delete(k uint) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintInt16ConcurrentMap) SetKeyValues(kvs ...UintInt16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintInt16ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintInt16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintInt16ConcurrentMap) KeyValues() []UintInt16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintInt16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintInt16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintInt16ConcurrentMap) ToUnsafeMap() map[uint]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintInt32KeyValue struct {
	Key   uint
	Value int32
}

type UintInt32ConcurrentMapOption func(*UintInt32ConcurrentMap)

func WithUnsafeUintInt32Map(m map[uint]int32) UintInt32ConcurrentMapOption {
	return func(cm *UintInt32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintInt32Map(m map[uint]int32) UintInt32ConcurrentMapOption {
	return func(cm *UintInt32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintInt32ConcurrentMap(opts ...UintInt32ConcurrentMapOption) *UintInt32ConcurrentMap {
	cm := &UintInt32ConcurrentMap{
		m: make(map[uint]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintInt32MapKeyValue struct {
	Key   uint
	Value int32
}

type UintInt32ConcurrentMap struct {
	m map[uint]int32
	L *sync.RWMutex
}

func (cm *UintInt32ConcurrentMap) Get(k uint) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintInt32ConcurrentMap) GetDefault(k uint, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintInt32ConcurrentMap) GetOK(k uint) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintInt32ConcurrentMap) Set(k uint, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintInt32ConcurrentMap) Delete(k uint) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintInt32ConcurrentMap) SetKeyValues(kvs ...UintInt32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintInt32ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintInt32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintInt32ConcurrentMap) KeyValues() []UintInt32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintInt32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintInt32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintInt32ConcurrentMap) ToUnsafeMap() map[uint]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintInt64KeyValue struct {
	Key   uint
	Value int64
}

type UintInt64ConcurrentMapOption func(*UintInt64ConcurrentMap)

func WithUnsafeUintInt64Map(m map[uint]int64) UintInt64ConcurrentMapOption {
	return func(cm *UintInt64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintInt64Map(m map[uint]int64) UintInt64ConcurrentMapOption {
	return func(cm *UintInt64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintInt64ConcurrentMap(opts ...UintInt64ConcurrentMapOption) *UintInt64ConcurrentMap {
	cm := &UintInt64ConcurrentMap{
		m: make(map[uint]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintInt64MapKeyValue struct {
	Key   uint
	Value int64
}

type UintInt64ConcurrentMap struct {
	m map[uint]int64
	L *sync.RWMutex
}

func (cm *UintInt64ConcurrentMap) Get(k uint) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintInt64ConcurrentMap) GetDefault(k uint, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintInt64ConcurrentMap) GetOK(k uint) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintInt64ConcurrentMap) Set(k uint, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintInt64ConcurrentMap) Delete(k uint) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintInt64ConcurrentMap) SetKeyValues(kvs ...UintInt64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintInt64ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintInt64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintInt64ConcurrentMap) KeyValues() []UintInt64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintInt64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintInt64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintInt64ConcurrentMap) ToUnsafeMap() map[uint]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintFloat32KeyValue struct {
	Key   uint
	Value float32
}

type UintFloat32ConcurrentMapOption func(*UintFloat32ConcurrentMap)

func WithUnsafeUintFloat32Map(m map[uint]float32) UintFloat32ConcurrentMapOption {
	return func(cm *UintFloat32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintFloat32Map(m map[uint]float32) UintFloat32ConcurrentMapOption {
	return func(cm *UintFloat32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintFloat32ConcurrentMap(opts ...UintFloat32ConcurrentMapOption) *UintFloat32ConcurrentMap {
	cm := &UintFloat32ConcurrentMap{
		m: make(map[uint]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintFloat32MapKeyValue struct {
	Key   uint
	Value float32
}

type UintFloat32ConcurrentMap struct {
	m map[uint]float32
	L *sync.RWMutex
}

func (cm *UintFloat32ConcurrentMap) Get(k uint) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintFloat32ConcurrentMap) GetDefault(k uint, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintFloat32ConcurrentMap) GetOK(k uint) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintFloat32ConcurrentMap) Set(k uint, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintFloat32ConcurrentMap) Delete(k uint) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintFloat32ConcurrentMap) SetKeyValues(kvs ...UintFloat32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintFloat32ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintFloat32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintFloat32ConcurrentMap) KeyValues() []UintFloat32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintFloat32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintFloat32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintFloat32ConcurrentMap) ToUnsafeMap() map[uint]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintFloat64KeyValue struct {
	Key   uint
	Value float64
}

type UintFloat64ConcurrentMapOption func(*UintFloat64ConcurrentMap)

func WithUnsafeUintFloat64Map(m map[uint]float64) UintFloat64ConcurrentMapOption {
	return func(cm *UintFloat64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintFloat64Map(m map[uint]float64) UintFloat64ConcurrentMapOption {
	return func(cm *UintFloat64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintFloat64ConcurrentMap(opts ...UintFloat64ConcurrentMapOption) *UintFloat64ConcurrentMap {
	cm := &UintFloat64ConcurrentMap{
		m: make(map[uint]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintFloat64MapKeyValue struct {
	Key   uint
	Value float64
}

type UintFloat64ConcurrentMap struct {
	m map[uint]float64
	L *sync.RWMutex
}

func (cm *UintFloat64ConcurrentMap) Get(k uint) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintFloat64ConcurrentMap) GetDefault(k uint, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintFloat64ConcurrentMap) GetOK(k uint) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintFloat64ConcurrentMap) Set(k uint, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintFloat64ConcurrentMap) Delete(k uint) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintFloat64ConcurrentMap) SetKeyValues(kvs ...UintFloat64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintFloat64ConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintFloat64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintFloat64ConcurrentMap) KeyValues() []UintFloat64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintFloat64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintFloat64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintFloat64ConcurrentMap) ToUnsafeMap() map[uint]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintTypeKeyValue struct {
	Key   uint
	Value Type
}

type UintTypeConcurrentMapOption func(*UintTypeConcurrentMap)

func WithUnsafeUintTypeMap(m map[uint]Type) UintTypeConcurrentMapOption {
	return func(cm *UintTypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintTypeMap(m map[uint]Type) UintTypeConcurrentMapOption {
	return func(cm *UintTypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintTypeConcurrentMap(opts ...UintTypeConcurrentMapOption) *UintTypeConcurrentMap {
	cm := &UintTypeConcurrentMap{
		m: make(map[uint]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintTypeMapKeyValue struct {
	Key   uint
	Value Type
}

type UintTypeConcurrentMap struct {
	m map[uint]Type
	L *sync.RWMutex
}

func (cm *UintTypeConcurrentMap) Get(k uint) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintTypeConcurrentMap) GetDefault(k uint, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintTypeConcurrentMap) GetOK(k uint) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintTypeConcurrentMap) Set(k uint, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintTypeConcurrentMap) Delete(k uint) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintTypeConcurrentMap) SetKeyValues(kvs ...UintTypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintTypeConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintTypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintTypeConcurrentMap) KeyValues() []UintTypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintTypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintTypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintTypeConcurrentMap) ToUnsafeMap() map[uint]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintBoolKeyValue struct {
	Key   uint
	Value bool
}

type UintBoolConcurrentMapOption func(*UintBoolConcurrentMap)

func WithUnsafeUintBoolMap(m map[uint]bool) UintBoolConcurrentMapOption {
	return func(cm *UintBoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintBoolMap(m map[uint]bool) UintBoolConcurrentMapOption {
	return func(cm *UintBoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintBoolConcurrentMap(opts ...UintBoolConcurrentMapOption) *UintBoolConcurrentMap {
	cm := &UintBoolConcurrentMap{
		m: make(map[uint]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintBoolMapKeyValue struct {
	Key   uint
	Value bool
}

type UintBoolConcurrentMap struct {
	m map[uint]bool
	L *sync.RWMutex
}

func (cm *UintBoolConcurrentMap) Get(k uint) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintBoolConcurrentMap) GetDefault(k uint, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintBoolConcurrentMap) GetOK(k uint) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintBoolConcurrentMap) Set(k uint, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintBoolConcurrentMap) Delete(k uint) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintBoolConcurrentMap) SetKeyValues(kvs ...UintBoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintBoolConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintBoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintBoolConcurrentMap) KeyValues() []UintBoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintBoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintBoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintBoolConcurrentMap) ToUnsafeMap() map[uint]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type UintStringKeyValue struct {
	Key   uint
	Value string
}

type UintStringConcurrentMapOption func(*UintStringConcurrentMap)

func WithUnsafeUintStringMap(m map[uint]string) UintStringConcurrentMapOption {
	return func(cm *UintStringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUintStringMap(m map[uint]string) UintStringConcurrentMapOption {
	return func(cm *UintStringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUintStringConcurrentMap(opts ...UintStringConcurrentMapOption) *UintStringConcurrentMap {
	cm := &UintStringConcurrentMap{
		m: make(map[uint]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type UintStringMapKeyValue struct {
	Key   uint
	Value string
}

type UintStringConcurrentMap struct {
	m map[uint]string
	L *sync.RWMutex
}

func (cm *UintStringConcurrentMap) Get(k uint) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *UintStringConcurrentMap) GetDefault(k uint, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *UintStringConcurrentMap) GetOK(k uint) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *UintStringConcurrentMap) Set(k uint, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *UintStringConcurrentMap) Delete(k uint) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *UintStringConcurrentMap) SetKeyValues(kvs ...UintStringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *UintStringConcurrentMap) Keys() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *UintStringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *UintStringConcurrentMap) KeyValues() []UintStringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []UintStringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, UintStringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *UintStringConcurrentMap) ToUnsafeMap() map[uint]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8ByteKeyValue struct {
	Key   uint8
	Value byte
}

type Uint8ByteConcurrentMapOption func(*Uint8ByteConcurrentMap)

func WithUnsafeUint8ByteMap(m map[uint8]byte) Uint8ByteConcurrentMapOption {
	return func(cm *Uint8ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8ByteMap(m map[uint8]byte) Uint8ByteConcurrentMapOption {
	return func(cm *Uint8ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8ByteConcurrentMap(opts ...Uint8ByteConcurrentMapOption) *Uint8ByteConcurrentMap {
	cm := &Uint8ByteConcurrentMap{
		m: make(map[uint8]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8ByteMapKeyValue struct {
	Key   uint8
	Value byte
}

type Uint8ByteConcurrentMap struct {
	m map[uint8]byte
	L *sync.RWMutex
}

func (cm *Uint8ByteConcurrentMap) Get(k uint8) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8ByteConcurrentMap) GetDefault(k uint8, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8ByteConcurrentMap) GetOK(k uint8) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8ByteConcurrentMap) Set(k uint8, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8ByteConcurrentMap) Delete(k uint8) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8ByteConcurrentMap) SetKeyValues(kvs ...Uint8ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8ByteConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8ByteConcurrentMap) KeyValues() []Uint8ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8ByteConcurrentMap) ToUnsafeMap() map[uint8]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8RuneKeyValue struct {
	Key   uint8
	Value rune
}

type Uint8RuneConcurrentMapOption func(*Uint8RuneConcurrentMap)

func WithUnsafeUint8RuneMap(m map[uint8]rune) Uint8RuneConcurrentMapOption {
	return func(cm *Uint8RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8RuneMap(m map[uint8]rune) Uint8RuneConcurrentMapOption {
	return func(cm *Uint8RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8RuneConcurrentMap(opts ...Uint8RuneConcurrentMapOption) *Uint8RuneConcurrentMap {
	cm := &Uint8RuneConcurrentMap{
		m: make(map[uint8]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8RuneMapKeyValue struct {
	Key   uint8
	Value rune
}

type Uint8RuneConcurrentMap struct {
	m map[uint8]rune
	L *sync.RWMutex
}

func (cm *Uint8RuneConcurrentMap) Get(k uint8) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8RuneConcurrentMap) GetDefault(k uint8, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8RuneConcurrentMap) GetOK(k uint8) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8RuneConcurrentMap) Set(k uint8, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8RuneConcurrentMap) Delete(k uint8) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8RuneConcurrentMap) SetKeyValues(kvs ...Uint8RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8RuneConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8RuneConcurrentMap) KeyValues() []Uint8RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8RuneConcurrentMap) ToUnsafeMap() map[uint8]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8UintKeyValue struct {
	Key   uint8
	Value uint
}

type Uint8UintConcurrentMapOption func(*Uint8UintConcurrentMap)

func WithUnsafeUint8UintMap(m map[uint8]uint) Uint8UintConcurrentMapOption {
	return func(cm *Uint8UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8UintMap(m map[uint8]uint) Uint8UintConcurrentMapOption {
	return func(cm *Uint8UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8UintConcurrentMap(opts ...Uint8UintConcurrentMapOption) *Uint8UintConcurrentMap {
	cm := &Uint8UintConcurrentMap{
		m: make(map[uint8]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8UintMapKeyValue struct {
	Key   uint8
	Value uint
}

type Uint8UintConcurrentMap struct {
	m map[uint8]uint
	L *sync.RWMutex
}

func (cm *Uint8UintConcurrentMap) Get(k uint8) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8UintConcurrentMap) GetDefault(k uint8, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8UintConcurrentMap) GetOK(k uint8) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8UintConcurrentMap) Set(k uint8, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8UintConcurrentMap) Delete(k uint8) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8UintConcurrentMap) SetKeyValues(kvs ...Uint8UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8UintConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8UintConcurrentMap) KeyValues() []Uint8UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8UintConcurrentMap) ToUnsafeMap() map[uint8]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Uint8KeyValue struct {
	Key   uint8
	Value uint8
}

type Uint8Uint8ConcurrentMapOption func(*Uint8Uint8ConcurrentMap)

func WithUnsafeUint8Uint8Map(m map[uint8]uint8) Uint8Uint8ConcurrentMapOption {
	return func(cm *Uint8Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Uint8Map(m map[uint8]uint8) Uint8Uint8ConcurrentMapOption {
	return func(cm *Uint8Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Uint8ConcurrentMap(opts ...Uint8Uint8ConcurrentMapOption) *Uint8Uint8ConcurrentMap {
	cm := &Uint8Uint8ConcurrentMap{
		m: make(map[uint8]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Uint8MapKeyValue struct {
	Key   uint8
	Value uint8
}

type Uint8Uint8ConcurrentMap struct {
	m map[uint8]uint8
	L *sync.RWMutex
}

func (cm *Uint8Uint8ConcurrentMap) Get(k uint8) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Uint8ConcurrentMap) GetDefault(k uint8, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Uint8ConcurrentMap) GetOK(k uint8) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Uint8ConcurrentMap) Set(k uint8, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Uint8ConcurrentMap) Delete(k uint8) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Uint8ConcurrentMap) SetKeyValues(kvs ...Uint8Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Uint8ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Uint8ConcurrentMap) KeyValues() []Uint8Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Uint8ConcurrentMap) ToUnsafeMap() map[uint8]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Uint16KeyValue struct {
	Key   uint8
	Value uint16
}

type Uint8Uint16ConcurrentMapOption func(*Uint8Uint16ConcurrentMap)

func WithUnsafeUint8Uint16Map(m map[uint8]uint16) Uint8Uint16ConcurrentMapOption {
	return func(cm *Uint8Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Uint16Map(m map[uint8]uint16) Uint8Uint16ConcurrentMapOption {
	return func(cm *Uint8Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Uint16ConcurrentMap(opts ...Uint8Uint16ConcurrentMapOption) *Uint8Uint16ConcurrentMap {
	cm := &Uint8Uint16ConcurrentMap{
		m: make(map[uint8]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Uint16MapKeyValue struct {
	Key   uint8
	Value uint16
}

type Uint8Uint16ConcurrentMap struct {
	m map[uint8]uint16
	L *sync.RWMutex
}

func (cm *Uint8Uint16ConcurrentMap) Get(k uint8) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Uint16ConcurrentMap) GetDefault(k uint8, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Uint16ConcurrentMap) GetOK(k uint8) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Uint16ConcurrentMap) Set(k uint8, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Uint16ConcurrentMap) Delete(k uint8) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Uint16ConcurrentMap) SetKeyValues(kvs ...Uint8Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Uint16ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Uint16ConcurrentMap) KeyValues() []Uint8Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Uint16ConcurrentMap) ToUnsafeMap() map[uint8]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8InterfaceKeyValue struct {
	Key   uint8
	Value Interface
}

type Uint8InterfaceConcurrentMapOption func(*Uint8InterfaceConcurrentMap)

func WithUnsafeUint8InterfaceMap(m map[uint8]Interface) Uint8InterfaceConcurrentMapOption {
	return func(cm *Uint8InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8InterfaceMap(m map[uint8]Interface) Uint8InterfaceConcurrentMapOption {
	return func(cm *Uint8InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8InterfaceConcurrentMap(opts ...Uint8InterfaceConcurrentMapOption) *Uint8InterfaceConcurrentMap {
	cm := &Uint8InterfaceConcurrentMap{
		m: make(map[uint8]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8InterfaceMapKeyValue struct {
	Key   uint8
	Value Interface
}

type Uint8InterfaceConcurrentMap struct {
	m map[uint8]Interface
	L *sync.RWMutex
}

func (cm *Uint8InterfaceConcurrentMap) Get(k uint8) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8InterfaceConcurrentMap) GetDefault(k uint8, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8InterfaceConcurrentMap) GetOK(k uint8) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8InterfaceConcurrentMap) Set(k uint8, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8InterfaceConcurrentMap) Delete(k uint8) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8InterfaceConcurrentMap) SetKeyValues(kvs ...Uint8InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8InterfaceConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8InterfaceConcurrentMap) KeyValues() []Uint8InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8InterfaceConcurrentMap) ToUnsafeMap() map[uint8]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Uint32KeyValue struct {
	Key   uint8
	Value uint32
}

type Uint8Uint32ConcurrentMapOption func(*Uint8Uint32ConcurrentMap)

func WithUnsafeUint8Uint32Map(m map[uint8]uint32) Uint8Uint32ConcurrentMapOption {
	return func(cm *Uint8Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Uint32Map(m map[uint8]uint32) Uint8Uint32ConcurrentMapOption {
	return func(cm *Uint8Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Uint32ConcurrentMap(opts ...Uint8Uint32ConcurrentMapOption) *Uint8Uint32ConcurrentMap {
	cm := &Uint8Uint32ConcurrentMap{
		m: make(map[uint8]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Uint32MapKeyValue struct {
	Key   uint8
	Value uint32
}

type Uint8Uint32ConcurrentMap struct {
	m map[uint8]uint32
	L *sync.RWMutex
}

func (cm *Uint8Uint32ConcurrentMap) Get(k uint8) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Uint32ConcurrentMap) GetDefault(k uint8, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Uint32ConcurrentMap) GetOK(k uint8) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Uint32ConcurrentMap) Set(k uint8, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Uint32ConcurrentMap) Delete(k uint8) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Uint32ConcurrentMap) SetKeyValues(kvs ...Uint8Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Uint32ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Uint32ConcurrentMap) KeyValues() []Uint8Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Uint32ConcurrentMap) ToUnsafeMap() map[uint8]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Uint64KeyValue struct {
	Key   uint8
	Value uint64
}

type Uint8Uint64ConcurrentMapOption func(*Uint8Uint64ConcurrentMap)

func WithUnsafeUint8Uint64Map(m map[uint8]uint64) Uint8Uint64ConcurrentMapOption {
	return func(cm *Uint8Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Uint64Map(m map[uint8]uint64) Uint8Uint64ConcurrentMapOption {
	return func(cm *Uint8Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Uint64ConcurrentMap(opts ...Uint8Uint64ConcurrentMapOption) *Uint8Uint64ConcurrentMap {
	cm := &Uint8Uint64ConcurrentMap{
		m: make(map[uint8]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Uint64MapKeyValue struct {
	Key   uint8
	Value uint64
}

type Uint8Uint64ConcurrentMap struct {
	m map[uint8]uint64
	L *sync.RWMutex
}

func (cm *Uint8Uint64ConcurrentMap) Get(k uint8) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Uint64ConcurrentMap) GetDefault(k uint8, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Uint64ConcurrentMap) GetOK(k uint8) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Uint64ConcurrentMap) Set(k uint8, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Uint64ConcurrentMap) Delete(k uint8) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Uint64ConcurrentMap) SetKeyValues(kvs ...Uint8Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Uint64ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Uint64ConcurrentMap) KeyValues() []Uint8Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Uint64ConcurrentMap) ToUnsafeMap() map[uint8]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8IntKeyValue struct {
	Key   uint8
	Value int
}

type Uint8IntConcurrentMapOption func(*Uint8IntConcurrentMap)

func WithUnsafeUint8IntMap(m map[uint8]int) Uint8IntConcurrentMapOption {
	return func(cm *Uint8IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8IntMap(m map[uint8]int) Uint8IntConcurrentMapOption {
	return func(cm *Uint8IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8IntConcurrentMap(opts ...Uint8IntConcurrentMapOption) *Uint8IntConcurrentMap {
	cm := &Uint8IntConcurrentMap{
		m: make(map[uint8]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8IntMapKeyValue struct {
	Key   uint8
	Value int
}

type Uint8IntConcurrentMap struct {
	m map[uint8]int
	L *sync.RWMutex
}

func (cm *Uint8IntConcurrentMap) Get(k uint8) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8IntConcurrentMap) GetDefault(k uint8, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8IntConcurrentMap) GetOK(k uint8) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8IntConcurrentMap) Set(k uint8, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8IntConcurrentMap) Delete(k uint8) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8IntConcurrentMap) SetKeyValues(kvs ...Uint8IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8IntConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8IntConcurrentMap) KeyValues() []Uint8IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8IntConcurrentMap) ToUnsafeMap() map[uint8]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Int8KeyValue struct {
	Key   uint8
	Value int8
}

type Uint8Int8ConcurrentMapOption func(*Uint8Int8ConcurrentMap)

func WithUnsafeUint8Int8Map(m map[uint8]int8) Uint8Int8ConcurrentMapOption {
	return func(cm *Uint8Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Int8Map(m map[uint8]int8) Uint8Int8ConcurrentMapOption {
	return func(cm *Uint8Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Int8ConcurrentMap(opts ...Uint8Int8ConcurrentMapOption) *Uint8Int8ConcurrentMap {
	cm := &Uint8Int8ConcurrentMap{
		m: make(map[uint8]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Int8MapKeyValue struct {
	Key   uint8
	Value int8
}

type Uint8Int8ConcurrentMap struct {
	m map[uint8]int8
	L *sync.RWMutex
}

func (cm *Uint8Int8ConcurrentMap) Get(k uint8) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Int8ConcurrentMap) GetDefault(k uint8, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Int8ConcurrentMap) GetOK(k uint8) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Int8ConcurrentMap) Set(k uint8, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Int8ConcurrentMap) Delete(k uint8) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Int8ConcurrentMap) SetKeyValues(kvs ...Uint8Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Int8ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Int8ConcurrentMap) KeyValues() []Uint8Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Int8ConcurrentMap) ToUnsafeMap() map[uint8]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Int16KeyValue struct {
	Key   uint8
	Value int16
}

type Uint8Int16ConcurrentMapOption func(*Uint8Int16ConcurrentMap)

func WithUnsafeUint8Int16Map(m map[uint8]int16) Uint8Int16ConcurrentMapOption {
	return func(cm *Uint8Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Int16Map(m map[uint8]int16) Uint8Int16ConcurrentMapOption {
	return func(cm *Uint8Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Int16ConcurrentMap(opts ...Uint8Int16ConcurrentMapOption) *Uint8Int16ConcurrentMap {
	cm := &Uint8Int16ConcurrentMap{
		m: make(map[uint8]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Int16MapKeyValue struct {
	Key   uint8
	Value int16
}

type Uint8Int16ConcurrentMap struct {
	m map[uint8]int16
	L *sync.RWMutex
}

func (cm *Uint8Int16ConcurrentMap) Get(k uint8) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Int16ConcurrentMap) GetDefault(k uint8, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Int16ConcurrentMap) GetOK(k uint8) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Int16ConcurrentMap) Set(k uint8, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Int16ConcurrentMap) Delete(k uint8) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Int16ConcurrentMap) SetKeyValues(kvs ...Uint8Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Int16ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Int16ConcurrentMap) KeyValues() []Uint8Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Int16ConcurrentMap) ToUnsafeMap() map[uint8]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Int32KeyValue struct {
	Key   uint8
	Value int32
}

type Uint8Int32ConcurrentMapOption func(*Uint8Int32ConcurrentMap)

func WithUnsafeUint8Int32Map(m map[uint8]int32) Uint8Int32ConcurrentMapOption {
	return func(cm *Uint8Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Int32Map(m map[uint8]int32) Uint8Int32ConcurrentMapOption {
	return func(cm *Uint8Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Int32ConcurrentMap(opts ...Uint8Int32ConcurrentMapOption) *Uint8Int32ConcurrentMap {
	cm := &Uint8Int32ConcurrentMap{
		m: make(map[uint8]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Int32MapKeyValue struct {
	Key   uint8
	Value int32
}

type Uint8Int32ConcurrentMap struct {
	m map[uint8]int32
	L *sync.RWMutex
}

func (cm *Uint8Int32ConcurrentMap) Get(k uint8) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Int32ConcurrentMap) GetDefault(k uint8, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Int32ConcurrentMap) GetOK(k uint8) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Int32ConcurrentMap) Set(k uint8, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Int32ConcurrentMap) Delete(k uint8) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Int32ConcurrentMap) SetKeyValues(kvs ...Uint8Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Int32ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Int32ConcurrentMap) KeyValues() []Uint8Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Int32ConcurrentMap) ToUnsafeMap() map[uint8]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Int64KeyValue struct {
	Key   uint8
	Value int64
}

type Uint8Int64ConcurrentMapOption func(*Uint8Int64ConcurrentMap)

func WithUnsafeUint8Int64Map(m map[uint8]int64) Uint8Int64ConcurrentMapOption {
	return func(cm *Uint8Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Int64Map(m map[uint8]int64) Uint8Int64ConcurrentMapOption {
	return func(cm *Uint8Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Int64ConcurrentMap(opts ...Uint8Int64ConcurrentMapOption) *Uint8Int64ConcurrentMap {
	cm := &Uint8Int64ConcurrentMap{
		m: make(map[uint8]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Int64MapKeyValue struct {
	Key   uint8
	Value int64
}

type Uint8Int64ConcurrentMap struct {
	m map[uint8]int64
	L *sync.RWMutex
}

func (cm *Uint8Int64ConcurrentMap) Get(k uint8) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Int64ConcurrentMap) GetDefault(k uint8, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Int64ConcurrentMap) GetOK(k uint8) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Int64ConcurrentMap) Set(k uint8, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Int64ConcurrentMap) Delete(k uint8) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Int64ConcurrentMap) SetKeyValues(kvs ...Uint8Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Int64ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Int64ConcurrentMap) KeyValues() []Uint8Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Int64ConcurrentMap) ToUnsafeMap() map[uint8]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Float32KeyValue struct {
	Key   uint8
	Value float32
}

type Uint8Float32ConcurrentMapOption func(*Uint8Float32ConcurrentMap)

func WithUnsafeUint8Float32Map(m map[uint8]float32) Uint8Float32ConcurrentMapOption {
	return func(cm *Uint8Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Float32Map(m map[uint8]float32) Uint8Float32ConcurrentMapOption {
	return func(cm *Uint8Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Float32ConcurrentMap(opts ...Uint8Float32ConcurrentMapOption) *Uint8Float32ConcurrentMap {
	cm := &Uint8Float32ConcurrentMap{
		m: make(map[uint8]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Float32MapKeyValue struct {
	Key   uint8
	Value float32
}

type Uint8Float32ConcurrentMap struct {
	m map[uint8]float32
	L *sync.RWMutex
}

func (cm *Uint8Float32ConcurrentMap) Get(k uint8) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Float32ConcurrentMap) GetDefault(k uint8, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Float32ConcurrentMap) GetOK(k uint8) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Float32ConcurrentMap) Set(k uint8, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Float32ConcurrentMap) Delete(k uint8) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Float32ConcurrentMap) SetKeyValues(kvs ...Uint8Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Float32ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Float32ConcurrentMap) KeyValues() []Uint8Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Float32ConcurrentMap) ToUnsafeMap() map[uint8]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8Float64KeyValue struct {
	Key   uint8
	Value float64
}

type Uint8Float64ConcurrentMapOption func(*Uint8Float64ConcurrentMap)

func WithUnsafeUint8Float64Map(m map[uint8]float64) Uint8Float64ConcurrentMapOption {
	return func(cm *Uint8Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8Float64Map(m map[uint8]float64) Uint8Float64ConcurrentMapOption {
	return func(cm *Uint8Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8Float64ConcurrentMap(opts ...Uint8Float64ConcurrentMapOption) *Uint8Float64ConcurrentMap {
	cm := &Uint8Float64ConcurrentMap{
		m: make(map[uint8]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8Float64MapKeyValue struct {
	Key   uint8
	Value float64
}

type Uint8Float64ConcurrentMap struct {
	m map[uint8]float64
	L *sync.RWMutex
}

func (cm *Uint8Float64ConcurrentMap) Get(k uint8) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8Float64ConcurrentMap) GetDefault(k uint8, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8Float64ConcurrentMap) GetOK(k uint8) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8Float64ConcurrentMap) Set(k uint8, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8Float64ConcurrentMap) Delete(k uint8) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8Float64ConcurrentMap) SetKeyValues(kvs ...Uint8Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8Float64ConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8Float64ConcurrentMap) KeyValues() []Uint8Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8Float64ConcurrentMap) ToUnsafeMap() map[uint8]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8TypeKeyValue struct {
	Key   uint8
	Value Type
}

type Uint8TypeConcurrentMapOption func(*Uint8TypeConcurrentMap)

func WithUnsafeUint8TypeMap(m map[uint8]Type) Uint8TypeConcurrentMapOption {
	return func(cm *Uint8TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8TypeMap(m map[uint8]Type) Uint8TypeConcurrentMapOption {
	return func(cm *Uint8TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8TypeConcurrentMap(opts ...Uint8TypeConcurrentMapOption) *Uint8TypeConcurrentMap {
	cm := &Uint8TypeConcurrentMap{
		m: make(map[uint8]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8TypeMapKeyValue struct {
	Key   uint8
	Value Type
}

type Uint8TypeConcurrentMap struct {
	m map[uint8]Type
	L *sync.RWMutex
}

func (cm *Uint8TypeConcurrentMap) Get(k uint8) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8TypeConcurrentMap) GetDefault(k uint8, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8TypeConcurrentMap) GetOK(k uint8) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8TypeConcurrentMap) Set(k uint8, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8TypeConcurrentMap) Delete(k uint8) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8TypeConcurrentMap) SetKeyValues(kvs ...Uint8TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8TypeConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8TypeConcurrentMap) KeyValues() []Uint8TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8TypeConcurrentMap) ToUnsafeMap() map[uint8]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8BoolKeyValue struct {
	Key   uint8
	Value bool
}

type Uint8BoolConcurrentMapOption func(*Uint8BoolConcurrentMap)

func WithUnsafeUint8BoolMap(m map[uint8]bool) Uint8BoolConcurrentMapOption {
	return func(cm *Uint8BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8BoolMap(m map[uint8]bool) Uint8BoolConcurrentMapOption {
	return func(cm *Uint8BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8BoolConcurrentMap(opts ...Uint8BoolConcurrentMapOption) *Uint8BoolConcurrentMap {
	cm := &Uint8BoolConcurrentMap{
		m: make(map[uint8]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8BoolMapKeyValue struct {
	Key   uint8
	Value bool
}

type Uint8BoolConcurrentMap struct {
	m map[uint8]bool
	L *sync.RWMutex
}

func (cm *Uint8BoolConcurrentMap) Get(k uint8) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8BoolConcurrentMap) GetDefault(k uint8, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8BoolConcurrentMap) GetOK(k uint8) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8BoolConcurrentMap) Set(k uint8, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8BoolConcurrentMap) Delete(k uint8) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8BoolConcurrentMap) SetKeyValues(kvs ...Uint8BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8BoolConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8BoolConcurrentMap) KeyValues() []Uint8BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8BoolConcurrentMap) ToUnsafeMap() map[uint8]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint8StringKeyValue struct {
	Key   uint8
	Value string
}

type Uint8StringConcurrentMapOption func(*Uint8StringConcurrentMap)

func WithUnsafeUint8StringMap(m map[uint8]string) Uint8StringConcurrentMapOption {
	return func(cm *Uint8StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint8StringMap(m map[uint8]string) Uint8StringConcurrentMapOption {
	return func(cm *Uint8StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint8StringConcurrentMap(opts ...Uint8StringConcurrentMapOption) *Uint8StringConcurrentMap {
	cm := &Uint8StringConcurrentMap{
		m: make(map[uint8]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint8StringMapKeyValue struct {
	Key   uint8
	Value string
}

type Uint8StringConcurrentMap struct {
	m map[uint8]string
	L *sync.RWMutex
}

func (cm *Uint8StringConcurrentMap) Get(k uint8) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint8StringConcurrentMap) GetDefault(k uint8, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint8StringConcurrentMap) GetOK(k uint8) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint8StringConcurrentMap) Set(k uint8, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint8StringConcurrentMap) Delete(k uint8) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint8StringConcurrentMap) SetKeyValues(kvs ...Uint8StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint8StringConcurrentMap) Keys() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint8StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint8StringConcurrentMap) KeyValues() []Uint8StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint8StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint8StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint8StringConcurrentMap) ToUnsafeMap() map[uint8]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint8]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16ByteKeyValue struct {
	Key   uint16
	Value byte
}

type Uint16ByteConcurrentMapOption func(*Uint16ByteConcurrentMap)

func WithUnsafeUint16ByteMap(m map[uint16]byte) Uint16ByteConcurrentMapOption {
	return func(cm *Uint16ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16ByteMap(m map[uint16]byte) Uint16ByteConcurrentMapOption {
	return func(cm *Uint16ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16ByteConcurrentMap(opts ...Uint16ByteConcurrentMapOption) *Uint16ByteConcurrentMap {
	cm := &Uint16ByteConcurrentMap{
		m: make(map[uint16]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16ByteMapKeyValue struct {
	Key   uint16
	Value byte
}

type Uint16ByteConcurrentMap struct {
	m map[uint16]byte
	L *sync.RWMutex
}

func (cm *Uint16ByteConcurrentMap) Get(k uint16) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16ByteConcurrentMap) GetDefault(k uint16, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16ByteConcurrentMap) GetOK(k uint16) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16ByteConcurrentMap) Set(k uint16, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16ByteConcurrentMap) Delete(k uint16) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16ByteConcurrentMap) SetKeyValues(kvs ...Uint16ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16ByteConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16ByteConcurrentMap) KeyValues() []Uint16ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16ByteConcurrentMap) ToUnsafeMap() map[uint16]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16RuneKeyValue struct {
	Key   uint16
	Value rune
}

type Uint16RuneConcurrentMapOption func(*Uint16RuneConcurrentMap)

func WithUnsafeUint16RuneMap(m map[uint16]rune) Uint16RuneConcurrentMapOption {
	return func(cm *Uint16RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16RuneMap(m map[uint16]rune) Uint16RuneConcurrentMapOption {
	return func(cm *Uint16RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16RuneConcurrentMap(opts ...Uint16RuneConcurrentMapOption) *Uint16RuneConcurrentMap {
	cm := &Uint16RuneConcurrentMap{
		m: make(map[uint16]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16RuneMapKeyValue struct {
	Key   uint16
	Value rune
}

type Uint16RuneConcurrentMap struct {
	m map[uint16]rune
	L *sync.RWMutex
}

func (cm *Uint16RuneConcurrentMap) Get(k uint16) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16RuneConcurrentMap) GetDefault(k uint16, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16RuneConcurrentMap) GetOK(k uint16) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16RuneConcurrentMap) Set(k uint16, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16RuneConcurrentMap) Delete(k uint16) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16RuneConcurrentMap) SetKeyValues(kvs ...Uint16RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16RuneConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16RuneConcurrentMap) KeyValues() []Uint16RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16RuneConcurrentMap) ToUnsafeMap() map[uint16]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16UintKeyValue struct {
	Key   uint16
	Value uint
}

type Uint16UintConcurrentMapOption func(*Uint16UintConcurrentMap)

func WithUnsafeUint16UintMap(m map[uint16]uint) Uint16UintConcurrentMapOption {
	return func(cm *Uint16UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16UintMap(m map[uint16]uint) Uint16UintConcurrentMapOption {
	return func(cm *Uint16UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16UintConcurrentMap(opts ...Uint16UintConcurrentMapOption) *Uint16UintConcurrentMap {
	cm := &Uint16UintConcurrentMap{
		m: make(map[uint16]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16UintMapKeyValue struct {
	Key   uint16
	Value uint
}

type Uint16UintConcurrentMap struct {
	m map[uint16]uint
	L *sync.RWMutex
}

func (cm *Uint16UintConcurrentMap) Get(k uint16) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16UintConcurrentMap) GetDefault(k uint16, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16UintConcurrentMap) GetOK(k uint16) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16UintConcurrentMap) Set(k uint16, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16UintConcurrentMap) Delete(k uint16) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16UintConcurrentMap) SetKeyValues(kvs ...Uint16UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16UintConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16UintConcurrentMap) KeyValues() []Uint16UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16UintConcurrentMap) ToUnsafeMap() map[uint16]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Uint8KeyValue struct {
	Key   uint16
	Value uint8
}

type Uint16Uint8ConcurrentMapOption func(*Uint16Uint8ConcurrentMap)

func WithUnsafeUint16Uint8Map(m map[uint16]uint8) Uint16Uint8ConcurrentMapOption {
	return func(cm *Uint16Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Uint8Map(m map[uint16]uint8) Uint16Uint8ConcurrentMapOption {
	return func(cm *Uint16Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Uint8ConcurrentMap(opts ...Uint16Uint8ConcurrentMapOption) *Uint16Uint8ConcurrentMap {
	cm := &Uint16Uint8ConcurrentMap{
		m: make(map[uint16]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Uint8MapKeyValue struct {
	Key   uint16
	Value uint8
}

type Uint16Uint8ConcurrentMap struct {
	m map[uint16]uint8
	L *sync.RWMutex
}

func (cm *Uint16Uint8ConcurrentMap) Get(k uint16) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Uint8ConcurrentMap) GetDefault(k uint16, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Uint8ConcurrentMap) GetOK(k uint16) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Uint8ConcurrentMap) Set(k uint16, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Uint8ConcurrentMap) Delete(k uint16) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Uint8ConcurrentMap) SetKeyValues(kvs ...Uint16Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Uint8ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Uint8ConcurrentMap) KeyValues() []Uint16Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Uint8ConcurrentMap) ToUnsafeMap() map[uint16]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Uint16KeyValue struct {
	Key   uint16
	Value uint16
}

type Uint16Uint16ConcurrentMapOption func(*Uint16Uint16ConcurrentMap)

func WithUnsafeUint16Uint16Map(m map[uint16]uint16) Uint16Uint16ConcurrentMapOption {
	return func(cm *Uint16Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Uint16Map(m map[uint16]uint16) Uint16Uint16ConcurrentMapOption {
	return func(cm *Uint16Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Uint16ConcurrentMap(opts ...Uint16Uint16ConcurrentMapOption) *Uint16Uint16ConcurrentMap {
	cm := &Uint16Uint16ConcurrentMap{
		m: make(map[uint16]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Uint16MapKeyValue struct {
	Key   uint16
	Value uint16
}

type Uint16Uint16ConcurrentMap struct {
	m map[uint16]uint16
	L *sync.RWMutex
}

func (cm *Uint16Uint16ConcurrentMap) Get(k uint16) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Uint16ConcurrentMap) GetDefault(k uint16, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Uint16ConcurrentMap) GetOK(k uint16) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Uint16ConcurrentMap) Set(k uint16, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Uint16ConcurrentMap) Delete(k uint16) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Uint16ConcurrentMap) SetKeyValues(kvs ...Uint16Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Uint16ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Uint16ConcurrentMap) KeyValues() []Uint16Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Uint16ConcurrentMap) ToUnsafeMap() map[uint16]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16InterfaceKeyValue struct {
	Key   uint16
	Value Interface
}

type Uint16InterfaceConcurrentMapOption func(*Uint16InterfaceConcurrentMap)

func WithUnsafeUint16InterfaceMap(m map[uint16]Interface) Uint16InterfaceConcurrentMapOption {
	return func(cm *Uint16InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16InterfaceMap(m map[uint16]Interface) Uint16InterfaceConcurrentMapOption {
	return func(cm *Uint16InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16InterfaceConcurrentMap(opts ...Uint16InterfaceConcurrentMapOption) *Uint16InterfaceConcurrentMap {
	cm := &Uint16InterfaceConcurrentMap{
		m: make(map[uint16]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16InterfaceMapKeyValue struct {
	Key   uint16
	Value Interface
}

type Uint16InterfaceConcurrentMap struct {
	m map[uint16]Interface
	L *sync.RWMutex
}

func (cm *Uint16InterfaceConcurrentMap) Get(k uint16) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16InterfaceConcurrentMap) GetDefault(k uint16, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16InterfaceConcurrentMap) GetOK(k uint16) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16InterfaceConcurrentMap) Set(k uint16, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16InterfaceConcurrentMap) Delete(k uint16) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16InterfaceConcurrentMap) SetKeyValues(kvs ...Uint16InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16InterfaceConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16InterfaceConcurrentMap) KeyValues() []Uint16InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16InterfaceConcurrentMap) ToUnsafeMap() map[uint16]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Uint32KeyValue struct {
	Key   uint16
	Value uint32
}

type Uint16Uint32ConcurrentMapOption func(*Uint16Uint32ConcurrentMap)

func WithUnsafeUint16Uint32Map(m map[uint16]uint32) Uint16Uint32ConcurrentMapOption {
	return func(cm *Uint16Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Uint32Map(m map[uint16]uint32) Uint16Uint32ConcurrentMapOption {
	return func(cm *Uint16Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Uint32ConcurrentMap(opts ...Uint16Uint32ConcurrentMapOption) *Uint16Uint32ConcurrentMap {
	cm := &Uint16Uint32ConcurrentMap{
		m: make(map[uint16]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Uint32MapKeyValue struct {
	Key   uint16
	Value uint32
}

type Uint16Uint32ConcurrentMap struct {
	m map[uint16]uint32
	L *sync.RWMutex
}

func (cm *Uint16Uint32ConcurrentMap) Get(k uint16) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Uint32ConcurrentMap) GetDefault(k uint16, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Uint32ConcurrentMap) GetOK(k uint16) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Uint32ConcurrentMap) Set(k uint16, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Uint32ConcurrentMap) Delete(k uint16) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Uint32ConcurrentMap) SetKeyValues(kvs ...Uint16Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Uint32ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Uint32ConcurrentMap) KeyValues() []Uint16Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Uint32ConcurrentMap) ToUnsafeMap() map[uint16]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Uint64KeyValue struct {
	Key   uint16
	Value uint64
}

type Uint16Uint64ConcurrentMapOption func(*Uint16Uint64ConcurrentMap)

func WithUnsafeUint16Uint64Map(m map[uint16]uint64) Uint16Uint64ConcurrentMapOption {
	return func(cm *Uint16Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Uint64Map(m map[uint16]uint64) Uint16Uint64ConcurrentMapOption {
	return func(cm *Uint16Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Uint64ConcurrentMap(opts ...Uint16Uint64ConcurrentMapOption) *Uint16Uint64ConcurrentMap {
	cm := &Uint16Uint64ConcurrentMap{
		m: make(map[uint16]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Uint64MapKeyValue struct {
	Key   uint16
	Value uint64
}

type Uint16Uint64ConcurrentMap struct {
	m map[uint16]uint64
	L *sync.RWMutex
}

func (cm *Uint16Uint64ConcurrentMap) Get(k uint16) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Uint64ConcurrentMap) GetDefault(k uint16, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Uint64ConcurrentMap) GetOK(k uint16) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Uint64ConcurrentMap) Set(k uint16, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Uint64ConcurrentMap) Delete(k uint16) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Uint64ConcurrentMap) SetKeyValues(kvs ...Uint16Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Uint64ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Uint64ConcurrentMap) KeyValues() []Uint16Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Uint64ConcurrentMap) ToUnsafeMap() map[uint16]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16IntKeyValue struct {
	Key   uint16
	Value int
}

type Uint16IntConcurrentMapOption func(*Uint16IntConcurrentMap)

func WithUnsafeUint16IntMap(m map[uint16]int) Uint16IntConcurrentMapOption {
	return func(cm *Uint16IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16IntMap(m map[uint16]int) Uint16IntConcurrentMapOption {
	return func(cm *Uint16IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16IntConcurrentMap(opts ...Uint16IntConcurrentMapOption) *Uint16IntConcurrentMap {
	cm := &Uint16IntConcurrentMap{
		m: make(map[uint16]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16IntMapKeyValue struct {
	Key   uint16
	Value int
}

type Uint16IntConcurrentMap struct {
	m map[uint16]int
	L *sync.RWMutex
}

func (cm *Uint16IntConcurrentMap) Get(k uint16) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16IntConcurrentMap) GetDefault(k uint16, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16IntConcurrentMap) GetOK(k uint16) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16IntConcurrentMap) Set(k uint16, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16IntConcurrentMap) Delete(k uint16) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16IntConcurrentMap) SetKeyValues(kvs ...Uint16IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16IntConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16IntConcurrentMap) KeyValues() []Uint16IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16IntConcurrentMap) ToUnsafeMap() map[uint16]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Int8KeyValue struct {
	Key   uint16
	Value int8
}

type Uint16Int8ConcurrentMapOption func(*Uint16Int8ConcurrentMap)

func WithUnsafeUint16Int8Map(m map[uint16]int8) Uint16Int8ConcurrentMapOption {
	return func(cm *Uint16Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Int8Map(m map[uint16]int8) Uint16Int8ConcurrentMapOption {
	return func(cm *Uint16Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Int8ConcurrentMap(opts ...Uint16Int8ConcurrentMapOption) *Uint16Int8ConcurrentMap {
	cm := &Uint16Int8ConcurrentMap{
		m: make(map[uint16]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Int8MapKeyValue struct {
	Key   uint16
	Value int8
}

type Uint16Int8ConcurrentMap struct {
	m map[uint16]int8
	L *sync.RWMutex
}

func (cm *Uint16Int8ConcurrentMap) Get(k uint16) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Int8ConcurrentMap) GetDefault(k uint16, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Int8ConcurrentMap) GetOK(k uint16) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Int8ConcurrentMap) Set(k uint16, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Int8ConcurrentMap) Delete(k uint16) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Int8ConcurrentMap) SetKeyValues(kvs ...Uint16Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Int8ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Int8ConcurrentMap) KeyValues() []Uint16Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Int8ConcurrentMap) ToUnsafeMap() map[uint16]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Int16KeyValue struct {
	Key   uint16
	Value int16
}

type Uint16Int16ConcurrentMapOption func(*Uint16Int16ConcurrentMap)

func WithUnsafeUint16Int16Map(m map[uint16]int16) Uint16Int16ConcurrentMapOption {
	return func(cm *Uint16Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Int16Map(m map[uint16]int16) Uint16Int16ConcurrentMapOption {
	return func(cm *Uint16Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Int16ConcurrentMap(opts ...Uint16Int16ConcurrentMapOption) *Uint16Int16ConcurrentMap {
	cm := &Uint16Int16ConcurrentMap{
		m: make(map[uint16]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Int16MapKeyValue struct {
	Key   uint16
	Value int16
}

type Uint16Int16ConcurrentMap struct {
	m map[uint16]int16
	L *sync.RWMutex
}

func (cm *Uint16Int16ConcurrentMap) Get(k uint16) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Int16ConcurrentMap) GetDefault(k uint16, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Int16ConcurrentMap) GetOK(k uint16) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Int16ConcurrentMap) Set(k uint16, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Int16ConcurrentMap) Delete(k uint16) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Int16ConcurrentMap) SetKeyValues(kvs ...Uint16Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Int16ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Int16ConcurrentMap) KeyValues() []Uint16Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Int16ConcurrentMap) ToUnsafeMap() map[uint16]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Int32KeyValue struct {
	Key   uint16
	Value int32
}

type Uint16Int32ConcurrentMapOption func(*Uint16Int32ConcurrentMap)

func WithUnsafeUint16Int32Map(m map[uint16]int32) Uint16Int32ConcurrentMapOption {
	return func(cm *Uint16Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Int32Map(m map[uint16]int32) Uint16Int32ConcurrentMapOption {
	return func(cm *Uint16Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Int32ConcurrentMap(opts ...Uint16Int32ConcurrentMapOption) *Uint16Int32ConcurrentMap {
	cm := &Uint16Int32ConcurrentMap{
		m: make(map[uint16]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Int32MapKeyValue struct {
	Key   uint16
	Value int32
}

type Uint16Int32ConcurrentMap struct {
	m map[uint16]int32
	L *sync.RWMutex
}

func (cm *Uint16Int32ConcurrentMap) Get(k uint16) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Int32ConcurrentMap) GetDefault(k uint16, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Int32ConcurrentMap) GetOK(k uint16) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Int32ConcurrentMap) Set(k uint16, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Int32ConcurrentMap) Delete(k uint16) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Int32ConcurrentMap) SetKeyValues(kvs ...Uint16Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Int32ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Int32ConcurrentMap) KeyValues() []Uint16Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Int32ConcurrentMap) ToUnsafeMap() map[uint16]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Int64KeyValue struct {
	Key   uint16
	Value int64
}

type Uint16Int64ConcurrentMapOption func(*Uint16Int64ConcurrentMap)

func WithUnsafeUint16Int64Map(m map[uint16]int64) Uint16Int64ConcurrentMapOption {
	return func(cm *Uint16Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Int64Map(m map[uint16]int64) Uint16Int64ConcurrentMapOption {
	return func(cm *Uint16Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Int64ConcurrentMap(opts ...Uint16Int64ConcurrentMapOption) *Uint16Int64ConcurrentMap {
	cm := &Uint16Int64ConcurrentMap{
		m: make(map[uint16]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Int64MapKeyValue struct {
	Key   uint16
	Value int64
}

type Uint16Int64ConcurrentMap struct {
	m map[uint16]int64
	L *sync.RWMutex
}

func (cm *Uint16Int64ConcurrentMap) Get(k uint16) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Int64ConcurrentMap) GetDefault(k uint16, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Int64ConcurrentMap) GetOK(k uint16) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Int64ConcurrentMap) Set(k uint16, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Int64ConcurrentMap) Delete(k uint16) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Int64ConcurrentMap) SetKeyValues(kvs ...Uint16Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Int64ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Int64ConcurrentMap) KeyValues() []Uint16Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Int64ConcurrentMap) ToUnsafeMap() map[uint16]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Float32KeyValue struct {
	Key   uint16
	Value float32
}

type Uint16Float32ConcurrentMapOption func(*Uint16Float32ConcurrentMap)

func WithUnsafeUint16Float32Map(m map[uint16]float32) Uint16Float32ConcurrentMapOption {
	return func(cm *Uint16Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Float32Map(m map[uint16]float32) Uint16Float32ConcurrentMapOption {
	return func(cm *Uint16Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Float32ConcurrentMap(opts ...Uint16Float32ConcurrentMapOption) *Uint16Float32ConcurrentMap {
	cm := &Uint16Float32ConcurrentMap{
		m: make(map[uint16]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Float32MapKeyValue struct {
	Key   uint16
	Value float32
}

type Uint16Float32ConcurrentMap struct {
	m map[uint16]float32
	L *sync.RWMutex
}

func (cm *Uint16Float32ConcurrentMap) Get(k uint16) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Float32ConcurrentMap) GetDefault(k uint16, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Float32ConcurrentMap) GetOK(k uint16) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Float32ConcurrentMap) Set(k uint16, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Float32ConcurrentMap) Delete(k uint16) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Float32ConcurrentMap) SetKeyValues(kvs ...Uint16Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Float32ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Float32ConcurrentMap) KeyValues() []Uint16Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Float32ConcurrentMap) ToUnsafeMap() map[uint16]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16Float64KeyValue struct {
	Key   uint16
	Value float64
}

type Uint16Float64ConcurrentMapOption func(*Uint16Float64ConcurrentMap)

func WithUnsafeUint16Float64Map(m map[uint16]float64) Uint16Float64ConcurrentMapOption {
	return func(cm *Uint16Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16Float64Map(m map[uint16]float64) Uint16Float64ConcurrentMapOption {
	return func(cm *Uint16Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16Float64ConcurrentMap(opts ...Uint16Float64ConcurrentMapOption) *Uint16Float64ConcurrentMap {
	cm := &Uint16Float64ConcurrentMap{
		m: make(map[uint16]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16Float64MapKeyValue struct {
	Key   uint16
	Value float64
}

type Uint16Float64ConcurrentMap struct {
	m map[uint16]float64
	L *sync.RWMutex
}

func (cm *Uint16Float64ConcurrentMap) Get(k uint16) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16Float64ConcurrentMap) GetDefault(k uint16, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16Float64ConcurrentMap) GetOK(k uint16) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16Float64ConcurrentMap) Set(k uint16, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16Float64ConcurrentMap) Delete(k uint16) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16Float64ConcurrentMap) SetKeyValues(kvs ...Uint16Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16Float64ConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16Float64ConcurrentMap) KeyValues() []Uint16Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16Float64ConcurrentMap) ToUnsafeMap() map[uint16]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16TypeKeyValue struct {
	Key   uint16
	Value Type
}

type Uint16TypeConcurrentMapOption func(*Uint16TypeConcurrentMap)

func WithUnsafeUint16TypeMap(m map[uint16]Type) Uint16TypeConcurrentMapOption {
	return func(cm *Uint16TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16TypeMap(m map[uint16]Type) Uint16TypeConcurrentMapOption {
	return func(cm *Uint16TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16TypeConcurrentMap(opts ...Uint16TypeConcurrentMapOption) *Uint16TypeConcurrentMap {
	cm := &Uint16TypeConcurrentMap{
		m: make(map[uint16]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16TypeMapKeyValue struct {
	Key   uint16
	Value Type
}

type Uint16TypeConcurrentMap struct {
	m map[uint16]Type
	L *sync.RWMutex
}

func (cm *Uint16TypeConcurrentMap) Get(k uint16) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16TypeConcurrentMap) GetDefault(k uint16, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16TypeConcurrentMap) GetOK(k uint16) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16TypeConcurrentMap) Set(k uint16, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16TypeConcurrentMap) Delete(k uint16) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16TypeConcurrentMap) SetKeyValues(kvs ...Uint16TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16TypeConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16TypeConcurrentMap) KeyValues() []Uint16TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16TypeConcurrentMap) ToUnsafeMap() map[uint16]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16BoolKeyValue struct {
	Key   uint16
	Value bool
}

type Uint16BoolConcurrentMapOption func(*Uint16BoolConcurrentMap)

func WithUnsafeUint16BoolMap(m map[uint16]bool) Uint16BoolConcurrentMapOption {
	return func(cm *Uint16BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16BoolMap(m map[uint16]bool) Uint16BoolConcurrentMapOption {
	return func(cm *Uint16BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16BoolConcurrentMap(opts ...Uint16BoolConcurrentMapOption) *Uint16BoolConcurrentMap {
	cm := &Uint16BoolConcurrentMap{
		m: make(map[uint16]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16BoolMapKeyValue struct {
	Key   uint16
	Value bool
}

type Uint16BoolConcurrentMap struct {
	m map[uint16]bool
	L *sync.RWMutex
}

func (cm *Uint16BoolConcurrentMap) Get(k uint16) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16BoolConcurrentMap) GetDefault(k uint16, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16BoolConcurrentMap) GetOK(k uint16) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16BoolConcurrentMap) Set(k uint16, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16BoolConcurrentMap) Delete(k uint16) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16BoolConcurrentMap) SetKeyValues(kvs ...Uint16BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16BoolConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16BoolConcurrentMap) KeyValues() []Uint16BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16BoolConcurrentMap) ToUnsafeMap() map[uint16]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint16StringKeyValue struct {
	Key   uint16
	Value string
}

type Uint16StringConcurrentMapOption func(*Uint16StringConcurrentMap)

func WithUnsafeUint16StringMap(m map[uint16]string) Uint16StringConcurrentMapOption {
	return func(cm *Uint16StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint16StringMap(m map[uint16]string) Uint16StringConcurrentMapOption {
	return func(cm *Uint16StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint16StringConcurrentMap(opts ...Uint16StringConcurrentMapOption) *Uint16StringConcurrentMap {
	cm := &Uint16StringConcurrentMap{
		m: make(map[uint16]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint16StringMapKeyValue struct {
	Key   uint16
	Value string
}

type Uint16StringConcurrentMap struct {
	m map[uint16]string
	L *sync.RWMutex
}

func (cm *Uint16StringConcurrentMap) Get(k uint16) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint16StringConcurrentMap) GetDefault(k uint16, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint16StringConcurrentMap) GetOK(k uint16) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint16StringConcurrentMap) Set(k uint16, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint16StringConcurrentMap) Delete(k uint16) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint16StringConcurrentMap) SetKeyValues(kvs ...Uint16StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint16StringConcurrentMap) Keys() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint16StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint16StringConcurrentMap) KeyValues() []Uint16StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint16StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint16StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint16StringConcurrentMap) ToUnsafeMap() map[uint16]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint16]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32ByteKeyValue struct {
	Key   uint32
	Value byte
}

type Uint32ByteConcurrentMapOption func(*Uint32ByteConcurrentMap)

func WithUnsafeUint32ByteMap(m map[uint32]byte) Uint32ByteConcurrentMapOption {
	return func(cm *Uint32ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32ByteMap(m map[uint32]byte) Uint32ByteConcurrentMapOption {
	return func(cm *Uint32ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32ByteConcurrentMap(opts ...Uint32ByteConcurrentMapOption) *Uint32ByteConcurrentMap {
	cm := &Uint32ByteConcurrentMap{
		m: make(map[uint32]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32ByteMapKeyValue struct {
	Key   uint32
	Value byte
}

type Uint32ByteConcurrentMap struct {
	m map[uint32]byte
	L *sync.RWMutex
}

func (cm *Uint32ByteConcurrentMap) Get(k uint32) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32ByteConcurrentMap) GetDefault(k uint32, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32ByteConcurrentMap) GetOK(k uint32) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32ByteConcurrentMap) Set(k uint32, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32ByteConcurrentMap) Delete(k uint32) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32ByteConcurrentMap) SetKeyValues(kvs ...Uint32ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32ByteConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32ByteConcurrentMap) KeyValues() []Uint32ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32ByteConcurrentMap) ToUnsafeMap() map[uint32]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32RuneKeyValue struct {
	Key   uint32
	Value rune
}

type Uint32RuneConcurrentMapOption func(*Uint32RuneConcurrentMap)

func WithUnsafeUint32RuneMap(m map[uint32]rune) Uint32RuneConcurrentMapOption {
	return func(cm *Uint32RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32RuneMap(m map[uint32]rune) Uint32RuneConcurrentMapOption {
	return func(cm *Uint32RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32RuneConcurrentMap(opts ...Uint32RuneConcurrentMapOption) *Uint32RuneConcurrentMap {
	cm := &Uint32RuneConcurrentMap{
		m: make(map[uint32]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32RuneMapKeyValue struct {
	Key   uint32
	Value rune
}

type Uint32RuneConcurrentMap struct {
	m map[uint32]rune
	L *sync.RWMutex
}

func (cm *Uint32RuneConcurrentMap) Get(k uint32) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32RuneConcurrentMap) GetDefault(k uint32, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32RuneConcurrentMap) GetOK(k uint32) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32RuneConcurrentMap) Set(k uint32, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32RuneConcurrentMap) Delete(k uint32) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32RuneConcurrentMap) SetKeyValues(kvs ...Uint32RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32RuneConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32RuneConcurrentMap) KeyValues() []Uint32RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32RuneConcurrentMap) ToUnsafeMap() map[uint32]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32UintKeyValue struct {
	Key   uint32
	Value uint
}

type Uint32UintConcurrentMapOption func(*Uint32UintConcurrentMap)

func WithUnsafeUint32UintMap(m map[uint32]uint) Uint32UintConcurrentMapOption {
	return func(cm *Uint32UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32UintMap(m map[uint32]uint) Uint32UintConcurrentMapOption {
	return func(cm *Uint32UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32UintConcurrentMap(opts ...Uint32UintConcurrentMapOption) *Uint32UintConcurrentMap {
	cm := &Uint32UintConcurrentMap{
		m: make(map[uint32]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32UintMapKeyValue struct {
	Key   uint32
	Value uint
}

type Uint32UintConcurrentMap struct {
	m map[uint32]uint
	L *sync.RWMutex
}

func (cm *Uint32UintConcurrentMap) Get(k uint32) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32UintConcurrentMap) GetDefault(k uint32, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32UintConcurrentMap) GetOK(k uint32) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32UintConcurrentMap) Set(k uint32, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32UintConcurrentMap) Delete(k uint32) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32UintConcurrentMap) SetKeyValues(kvs ...Uint32UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32UintConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32UintConcurrentMap) KeyValues() []Uint32UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32UintConcurrentMap) ToUnsafeMap() map[uint32]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Uint8KeyValue struct {
	Key   uint32
	Value uint8
}

type Uint32Uint8ConcurrentMapOption func(*Uint32Uint8ConcurrentMap)

func WithUnsafeUint32Uint8Map(m map[uint32]uint8) Uint32Uint8ConcurrentMapOption {
	return func(cm *Uint32Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Uint8Map(m map[uint32]uint8) Uint32Uint8ConcurrentMapOption {
	return func(cm *Uint32Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Uint8ConcurrentMap(opts ...Uint32Uint8ConcurrentMapOption) *Uint32Uint8ConcurrentMap {
	cm := &Uint32Uint8ConcurrentMap{
		m: make(map[uint32]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Uint8MapKeyValue struct {
	Key   uint32
	Value uint8
}

type Uint32Uint8ConcurrentMap struct {
	m map[uint32]uint8
	L *sync.RWMutex
}

func (cm *Uint32Uint8ConcurrentMap) Get(k uint32) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Uint8ConcurrentMap) GetDefault(k uint32, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Uint8ConcurrentMap) GetOK(k uint32) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Uint8ConcurrentMap) Set(k uint32, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Uint8ConcurrentMap) Delete(k uint32) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Uint8ConcurrentMap) SetKeyValues(kvs ...Uint32Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Uint8ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Uint8ConcurrentMap) KeyValues() []Uint32Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Uint8ConcurrentMap) ToUnsafeMap() map[uint32]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Uint16KeyValue struct {
	Key   uint32
	Value uint16
}

type Uint32Uint16ConcurrentMapOption func(*Uint32Uint16ConcurrentMap)

func WithUnsafeUint32Uint16Map(m map[uint32]uint16) Uint32Uint16ConcurrentMapOption {
	return func(cm *Uint32Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Uint16Map(m map[uint32]uint16) Uint32Uint16ConcurrentMapOption {
	return func(cm *Uint32Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Uint16ConcurrentMap(opts ...Uint32Uint16ConcurrentMapOption) *Uint32Uint16ConcurrentMap {
	cm := &Uint32Uint16ConcurrentMap{
		m: make(map[uint32]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Uint16MapKeyValue struct {
	Key   uint32
	Value uint16
}

type Uint32Uint16ConcurrentMap struct {
	m map[uint32]uint16
	L *sync.RWMutex
}

func (cm *Uint32Uint16ConcurrentMap) Get(k uint32) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Uint16ConcurrentMap) GetDefault(k uint32, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Uint16ConcurrentMap) GetOK(k uint32) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Uint16ConcurrentMap) Set(k uint32, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Uint16ConcurrentMap) Delete(k uint32) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Uint16ConcurrentMap) SetKeyValues(kvs ...Uint32Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Uint16ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Uint16ConcurrentMap) KeyValues() []Uint32Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Uint16ConcurrentMap) ToUnsafeMap() map[uint32]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32InterfaceKeyValue struct {
	Key   uint32
	Value Interface
}

type Uint32InterfaceConcurrentMapOption func(*Uint32InterfaceConcurrentMap)

func WithUnsafeUint32InterfaceMap(m map[uint32]Interface) Uint32InterfaceConcurrentMapOption {
	return func(cm *Uint32InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32InterfaceMap(m map[uint32]Interface) Uint32InterfaceConcurrentMapOption {
	return func(cm *Uint32InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32InterfaceConcurrentMap(opts ...Uint32InterfaceConcurrentMapOption) *Uint32InterfaceConcurrentMap {
	cm := &Uint32InterfaceConcurrentMap{
		m: make(map[uint32]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32InterfaceMapKeyValue struct {
	Key   uint32
	Value Interface
}

type Uint32InterfaceConcurrentMap struct {
	m map[uint32]Interface
	L *sync.RWMutex
}

func (cm *Uint32InterfaceConcurrentMap) Get(k uint32) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32InterfaceConcurrentMap) GetDefault(k uint32, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32InterfaceConcurrentMap) GetOK(k uint32) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32InterfaceConcurrentMap) Set(k uint32, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32InterfaceConcurrentMap) Delete(k uint32) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32InterfaceConcurrentMap) SetKeyValues(kvs ...Uint32InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32InterfaceConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32InterfaceConcurrentMap) KeyValues() []Uint32InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32InterfaceConcurrentMap) ToUnsafeMap() map[uint32]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Uint32KeyValue struct {
	Key   uint32
	Value uint32
}

type Uint32Uint32ConcurrentMapOption func(*Uint32Uint32ConcurrentMap)

func WithUnsafeUint32Uint32Map(m map[uint32]uint32) Uint32Uint32ConcurrentMapOption {
	return func(cm *Uint32Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Uint32Map(m map[uint32]uint32) Uint32Uint32ConcurrentMapOption {
	return func(cm *Uint32Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Uint32ConcurrentMap(opts ...Uint32Uint32ConcurrentMapOption) *Uint32Uint32ConcurrentMap {
	cm := &Uint32Uint32ConcurrentMap{
		m: make(map[uint32]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Uint32MapKeyValue struct {
	Key   uint32
	Value uint32
}

type Uint32Uint32ConcurrentMap struct {
	m map[uint32]uint32
	L *sync.RWMutex
}

func (cm *Uint32Uint32ConcurrentMap) Get(k uint32) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Uint32ConcurrentMap) GetDefault(k uint32, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Uint32ConcurrentMap) GetOK(k uint32) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Uint32ConcurrentMap) Set(k uint32, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Uint32ConcurrentMap) Delete(k uint32) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Uint32ConcurrentMap) SetKeyValues(kvs ...Uint32Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Uint32ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Uint32ConcurrentMap) KeyValues() []Uint32Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Uint32ConcurrentMap) ToUnsafeMap() map[uint32]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Uint64KeyValue struct {
	Key   uint32
	Value uint64
}

type Uint32Uint64ConcurrentMapOption func(*Uint32Uint64ConcurrentMap)

func WithUnsafeUint32Uint64Map(m map[uint32]uint64) Uint32Uint64ConcurrentMapOption {
	return func(cm *Uint32Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Uint64Map(m map[uint32]uint64) Uint32Uint64ConcurrentMapOption {
	return func(cm *Uint32Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Uint64ConcurrentMap(opts ...Uint32Uint64ConcurrentMapOption) *Uint32Uint64ConcurrentMap {
	cm := &Uint32Uint64ConcurrentMap{
		m: make(map[uint32]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Uint64MapKeyValue struct {
	Key   uint32
	Value uint64
}

type Uint32Uint64ConcurrentMap struct {
	m map[uint32]uint64
	L *sync.RWMutex
}

func (cm *Uint32Uint64ConcurrentMap) Get(k uint32) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Uint64ConcurrentMap) GetDefault(k uint32, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Uint64ConcurrentMap) GetOK(k uint32) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Uint64ConcurrentMap) Set(k uint32, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Uint64ConcurrentMap) Delete(k uint32) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Uint64ConcurrentMap) SetKeyValues(kvs ...Uint32Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Uint64ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Uint64ConcurrentMap) KeyValues() []Uint32Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Uint64ConcurrentMap) ToUnsafeMap() map[uint32]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32IntKeyValue struct {
	Key   uint32
	Value int
}

type Uint32IntConcurrentMapOption func(*Uint32IntConcurrentMap)

func WithUnsafeUint32IntMap(m map[uint32]int) Uint32IntConcurrentMapOption {
	return func(cm *Uint32IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32IntMap(m map[uint32]int) Uint32IntConcurrentMapOption {
	return func(cm *Uint32IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32IntConcurrentMap(opts ...Uint32IntConcurrentMapOption) *Uint32IntConcurrentMap {
	cm := &Uint32IntConcurrentMap{
		m: make(map[uint32]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32IntMapKeyValue struct {
	Key   uint32
	Value int
}

type Uint32IntConcurrentMap struct {
	m map[uint32]int
	L *sync.RWMutex
}

func (cm *Uint32IntConcurrentMap) Get(k uint32) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32IntConcurrentMap) GetDefault(k uint32, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32IntConcurrentMap) GetOK(k uint32) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32IntConcurrentMap) Set(k uint32, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32IntConcurrentMap) Delete(k uint32) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32IntConcurrentMap) SetKeyValues(kvs ...Uint32IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32IntConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32IntConcurrentMap) KeyValues() []Uint32IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32IntConcurrentMap) ToUnsafeMap() map[uint32]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Int8KeyValue struct {
	Key   uint32
	Value int8
}

type Uint32Int8ConcurrentMapOption func(*Uint32Int8ConcurrentMap)

func WithUnsafeUint32Int8Map(m map[uint32]int8) Uint32Int8ConcurrentMapOption {
	return func(cm *Uint32Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Int8Map(m map[uint32]int8) Uint32Int8ConcurrentMapOption {
	return func(cm *Uint32Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Int8ConcurrentMap(opts ...Uint32Int8ConcurrentMapOption) *Uint32Int8ConcurrentMap {
	cm := &Uint32Int8ConcurrentMap{
		m: make(map[uint32]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Int8MapKeyValue struct {
	Key   uint32
	Value int8
}

type Uint32Int8ConcurrentMap struct {
	m map[uint32]int8
	L *sync.RWMutex
}

func (cm *Uint32Int8ConcurrentMap) Get(k uint32) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Int8ConcurrentMap) GetDefault(k uint32, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Int8ConcurrentMap) GetOK(k uint32) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Int8ConcurrentMap) Set(k uint32, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Int8ConcurrentMap) Delete(k uint32) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Int8ConcurrentMap) SetKeyValues(kvs ...Uint32Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Int8ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Int8ConcurrentMap) KeyValues() []Uint32Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Int8ConcurrentMap) ToUnsafeMap() map[uint32]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Int16KeyValue struct {
	Key   uint32
	Value int16
}

type Uint32Int16ConcurrentMapOption func(*Uint32Int16ConcurrentMap)

func WithUnsafeUint32Int16Map(m map[uint32]int16) Uint32Int16ConcurrentMapOption {
	return func(cm *Uint32Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Int16Map(m map[uint32]int16) Uint32Int16ConcurrentMapOption {
	return func(cm *Uint32Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Int16ConcurrentMap(opts ...Uint32Int16ConcurrentMapOption) *Uint32Int16ConcurrentMap {
	cm := &Uint32Int16ConcurrentMap{
		m: make(map[uint32]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Int16MapKeyValue struct {
	Key   uint32
	Value int16
}

type Uint32Int16ConcurrentMap struct {
	m map[uint32]int16
	L *sync.RWMutex
}

func (cm *Uint32Int16ConcurrentMap) Get(k uint32) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Int16ConcurrentMap) GetDefault(k uint32, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Int16ConcurrentMap) GetOK(k uint32) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Int16ConcurrentMap) Set(k uint32, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Int16ConcurrentMap) Delete(k uint32) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Int16ConcurrentMap) SetKeyValues(kvs ...Uint32Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Int16ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Int16ConcurrentMap) KeyValues() []Uint32Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Int16ConcurrentMap) ToUnsafeMap() map[uint32]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Int32KeyValue struct {
	Key   uint32
	Value int32
}

type Uint32Int32ConcurrentMapOption func(*Uint32Int32ConcurrentMap)

func WithUnsafeUint32Int32Map(m map[uint32]int32) Uint32Int32ConcurrentMapOption {
	return func(cm *Uint32Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Int32Map(m map[uint32]int32) Uint32Int32ConcurrentMapOption {
	return func(cm *Uint32Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Int32ConcurrentMap(opts ...Uint32Int32ConcurrentMapOption) *Uint32Int32ConcurrentMap {
	cm := &Uint32Int32ConcurrentMap{
		m: make(map[uint32]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Int32MapKeyValue struct {
	Key   uint32
	Value int32
}

type Uint32Int32ConcurrentMap struct {
	m map[uint32]int32
	L *sync.RWMutex
}

func (cm *Uint32Int32ConcurrentMap) Get(k uint32) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Int32ConcurrentMap) GetDefault(k uint32, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Int32ConcurrentMap) GetOK(k uint32) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Int32ConcurrentMap) Set(k uint32, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Int32ConcurrentMap) Delete(k uint32) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Int32ConcurrentMap) SetKeyValues(kvs ...Uint32Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Int32ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Int32ConcurrentMap) KeyValues() []Uint32Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Int32ConcurrentMap) ToUnsafeMap() map[uint32]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Int64KeyValue struct {
	Key   uint32
	Value int64
}

type Uint32Int64ConcurrentMapOption func(*Uint32Int64ConcurrentMap)

func WithUnsafeUint32Int64Map(m map[uint32]int64) Uint32Int64ConcurrentMapOption {
	return func(cm *Uint32Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Int64Map(m map[uint32]int64) Uint32Int64ConcurrentMapOption {
	return func(cm *Uint32Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Int64ConcurrentMap(opts ...Uint32Int64ConcurrentMapOption) *Uint32Int64ConcurrentMap {
	cm := &Uint32Int64ConcurrentMap{
		m: make(map[uint32]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Int64MapKeyValue struct {
	Key   uint32
	Value int64
}

type Uint32Int64ConcurrentMap struct {
	m map[uint32]int64
	L *sync.RWMutex
}

func (cm *Uint32Int64ConcurrentMap) Get(k uint32) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Int64ConcurrentMap) GetDefault(k uint32, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Int64ConcurrentMap) GetOK(k uint32) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Int64ConcurrentMap) Set(k uint32, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Int64ConcurrentMap) Delete(k uint32) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Int64ConcurrentMap) SetKeyValues(kvs ...Uint32Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Int64ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Int64ConcurrentMap) KeyValues() []Uint32Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Int64ConcurrentMap) ToUnsafeMap() map[uint32]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Float32KeyValue struct {
	Key   uint32
	Value float32
}

type Uint32Float32ConcurrentMapOption func(*Uint32Float32ConcurrentMap)

func WithUnsafeUint32Float32Map(m map[uint32]float32) Uint32Float32ConcurrentMapOption {
	return func(cm *Uint32Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Float32Map(m map[uint32]float32) Uint32Float32ConcurrentMapOption {
	return func(cm *Uint32Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Float32ConcurrentMap(opts ...Uint32Float32ConcurrentMapOption) *Uint32Float32ConcurrentMap {
	cm := &Uint32Float32ConcurrentMap{
		m: make(map[uint32]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Float32MapKeyValue struct {
	Key   uint32
	Value float32
}

type Uint32Float32ConcurrentMap struct {
	m map[uint32]float32
	L *sync.RWMutex
}

func (cm *Uint32Float32ConcurrentMap) Get(k uint32) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Float32ConcurrentMap) GetDefault(k uint32, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Float32ConcurrentMap) GetOK(k uint32) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Float32ConcurrentMap) Set(k uint32, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Float32ConcurrentMap) Delete(k uint32) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Float32ConcurrentMap) SetKeyValues(kvs ...Uint32Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Float32ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Float32ConcurrentMap) KeyValues() []Uint32Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Float32ConcurrentMap) ToUnsafeMap() map[uint32]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32Float64KeyValue struct {
	Key   uint32
	Value float64
}

type Uint32Float64ConcurrentMapOption func(*Uint32Float64ConcurrentMap)

func WithUnsafeUint32Float64Map(m map[uint32]float64) Uint32Float64ConcurrentMapOption {
	return func(cm *Uint32Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32Float64Map(m map[uint32]float64) Uint32Float64ConcurrentMapOption {
	return func(cm *Uint32Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32Float64ConcurrentMap(opts ...Uint32Float64ConcurrentMapOption) *Uint32Float64ConcurrentMap {
	cm := &Uint32Float64ConcurrentMap{
		m: make(map[uint32]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32Float64MapKeyValue struct {
	Key   uint32
	Value float64
}

type Uint32Float64ConcurrentMap struct {
	m map[uint32]float64
	L *sync.RWMutex
}

func (cm *Uint32Float64ConcurrentMap) Get(k uint32) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32Float64ConcurrentMap) GetDefault(k uint32, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32Float64ConcurrentMap) GetOK(k uint32) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32Float64ConcurrentMap) Set(k uint32, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32Float64ConcurrentMap) Delete(k uint32) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32Float64ConcurrentMap) SetKeyValues(kvs ...Uint32Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32Float64ConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32Float64ConcurrentMap) KeyValues() []Uint32Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32Float64ConcurrentMap) ToUnsafeMap() map[uint32]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32TypeKeyValue struct {
	Key   uint32
	Value Type
}

type Uint32TypeConcurrentMapOption func(*Uint32TypeConcurrentMap)

func WithUnsafeUint32TypeMap(m map[uint32]Type) Uint32TypeConcurrentMapOption {
	return func(cm *Uint32TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32TypeMap(m map[uint32]Type) Uint32TypeConcurrentMapOption {
	return func(cm *Uint32TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32TypeConcurrentMap(opts ...Uint32TypeConcurrentMapOption) *Uint32TypeConcurrentMap {
	cm := &Uint32TypeConcurrentMap{
		m: make(map[uint32]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32TypeMapKeyValue struct {
	Key   uint32
	Value Type
}

type Uint32TypeConcurrentMap struct {
	m map[uint32]Type
	L *sync.RWMutex
}

func (cm *Uint32TypeConcurrentMap) Get(k uint32) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32TypeConcurrentMap) GetDefault(k uint32, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32TypeConcurrentMap) GetOK(k uint32) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32TypeConcurrentMap) Set(k uint32, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32TypeConcurrentMap) Delete(k uint32) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32TypeConcurrentMap) SetKeyValues(kvs ...Uint32TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32TypeConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32TypeConcurrentMap) KeyValues() []Uint32TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32TypeConcurrentMap) ToUnsafeMap() map[uint32]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32BoolKeyValue struct {
	Key   uint32
	Value bool
}

type Uint32BoolConcurrentMapOption func(*Uint32BoolConcurrentMap)

func WithUnsafeUint32BoolMap(m map[uint32]bool) Uint32BoolConcurrentMapOption {
	return func(cm *Uint32BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32BoolMap(m map[uint32]bool) Uint32BoolConcurrentMapOption {
	return func(cm *Uint32BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32BoolConcurrentMap(opts ...Uint32BoolConcurrentMapOption) *Uint32BoolConcurrentMap {
	cm := &Uint32BoolConcurrentMap{
		m: make(map[uint32]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32BoolMapKeyValue struct {
	Key   uint32
	Value bool
}

type Uint32BoolConcurrentMap struct {
	m map[uint32]bool
	L *sync.RWMutex
}

func (cm *Uint32BoolConcurrentMap) Get(k uint32) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32BoolConcurrentMap) GetDefault(k uint32, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32BoolConcurrentMap) GetOK(k uint32) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32BoolConcurrentMap) Set(k uint32, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32BoolConcurrentMap) Delete(k uint32) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32BoolConcurrentMap) SetKeyValues(kvs ...Uint32BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32BoolConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32BoolConcurrentMap) KeyValues() []Uint32BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32BoolConcurrentMap) ToUnsafeMap() map[uint32]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint32StringKeyValue struct {
	Key   uint32
	Value string
}

type Uint32StringConcurrentMapOption func(*Uint32StringConcurrentMap)

func WithUnsafeUint32StringMap(m map[uint32]string) Uint32StringConcurrentMapOption {
	return func(cm *Uint32StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint32StringMap(m map[uint32]string) Uint32StringConcurrentMapOption {
	return func(cm *Uint32StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint32StringConcurrentMap(opts ...Uint32StringConcurrentMapOption) *Uint32StringConcurrentMap {
	cm := &Uint32StringConcurrentMap{
		m: make(map[uint32]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint32StringMapKeyValue struct {
	Key   uint32
	Value string
}

type Uint32StringConcurrentMap struct {
	m map[uint32]string
	L *sync.RWMutex
}

func (cm *Uint32StringConcurrentMap) Get(k uint32) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint32StringConcurrentMap) GetDefault(k uint32, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint32StringConcurrentMap) GetOK(k uint32) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint32StringConcurrentMap) Set(k uint32, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint32StringConcurrentMap) Delete(k uint32) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint32StringConcurrentMap) SetKeyValues(kvs ...Uint32StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint32StringConcurrentMap) Keys() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint32StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint32StringConcurrentMap) KeyValues() []Uint32StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint32StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint32StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint32StringConcurrentMap) ToUnsafeMap() map[uint32]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint32]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64ByteKeyValue struct {
	Key   uint64
	Value byte
}

type Uint64ByteConcurrentMapOption func(*Uint64ByteConcurrentMap)

func WithUnsafeUint64ByteMap(m map[uint64]byte) Uint64ByteConcurrentMapOption {
	return func(cm *Uint64ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64ByteMap(m map[uint64]byte) Uint64ByteConcurrentMapOption {
	return func(cm *Uint64ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64ByteConcurrentMap(opts ...Uint64ByteConcurrentMapOption) *Uint64ByteConcurrentMap {
	cm := &Uint64ByteConcurrentMap{
		m: make(map[uint64]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64ByteMapKeyValue struct {
	Key   uint64
	Value byte
}

type Uint64ByteConcurrentMap struct {
	m map[uint64]byte
	L *sync.RWMutex
}

func (cm *Uint64ByteConcurrentMap) Get(k uint64) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64ByteConcurrentMap) GetDefault(k uint64, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64ByteConcurrentMap) GetOK(k uint64) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64ByteConcurrentMap) Set(k uint64, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64ByteConcurrentMap) Delete(k uint64) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64ByteConcurrentMap) SetKeyValues(kvs ...Uint64ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64ByteConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64ByteConcurrentMap) KeyValues() []Uint64ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64ByteConcurrentMap) ToUnsafeMap() map[uint64]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64RuneKeyValue struct {
	Key   uint64
	Value rune
}

type Uint64RuneConcurrentMapOption func(*Uint64RuneConcurrentMap)

func WithUnsafeUint64RuneMap(m map[uint64]rune) Uint64RuneConcurrentMapOption {
	return func(cm *Uint64RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64RuneMap(m map[uint64]rune) Uint64RuneConcurrentMapOption {
	return func(cm *Uint64RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64RuneConcurrentMap(opts ...Uint64RuneConcurrentMapOption) *Uint64RuneConcurrentMap {
	cm := &Uint64RuneConcurrentMap{
		m: make(map[uint64]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64RuneMapKeyValue struct {
	Key   uint64
	Value rune
}

type Uint64RuneConcurrentMap struct {
	m map[uint64]rune
	L *sync.RWMutex
}

func (cm *Uint64RuneConcurrentMap) Get(k uint64) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64RuneConcurrentMap) GetDefault(k uint64, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64RuneConcurrentMap) GetOK(k uint64) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64RuneConcurrentMap) Set(k uint64, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64RuneConcurrentMap) Delete(k uint64) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64RuneConcurrentMap) SetKeyValues(kvs ...Uint64RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64RuneConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64RuneConcurrentMap) KeyValues() []Uint64RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64RuneConcurrentMap) ToUnsafeMap() map[uint64]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64UintKeyValue struct {
	Key   uint64
	Value uint
}

type Uint64UintConcurrentMapOption func(*Uint64UintConcurrentMap)

func WithUnsafeUint64UintMap(m map[uint64]uint) Uint64UintConcurrentMapOption {
	return func(cm *Uint64UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64UintMap(m map[uint64]uint) Uint64UintConcurrentMapOption {
	return func(cm *Uint64UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64UintConcurrentMap(opts ...Uint64UintConcurrentMapOption) *Uint64UintConcurrentMap {
	cm := &Uint64UintConcurrentMap{
		m: make(map[uint64]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64UintMapKeyValue struct {
	Key   uint64
	Value uint
}

type Uint64UintConcurrentMap struct {
	m map[uint64]uint
	L *sync.RWMutex
}

func (cm *Uint64UintConcurrentMap) Get(k uint64) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64UintConcurrentMap) GetDefault(k uint64, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64UintConcurrentMap) GetOK(k uint64) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64UintConcurrentMap) Set(k uint64, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64UintConcurrentMap) Delete(k uint64) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64UintConcurrentMap) SetKeyValues(kvs ...Uint64UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64UintConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64UintConcurrentMap) KeyValues() []Uint64UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64UintConcurrentMap) ToUnsafeMap() map[uint64]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Uint8KeyValue struct {
	Key   uint64
	Value uint8
}

type Uint64Uint8ConcurrentMapOption func(*Uint64Uint8ConcurrentMap)

func WithUnsafeUint64Uint8Map(m map[uint64]uint8) Uint64Uint8ConcurrentMapOption {
	return func(cm *Uint64Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Uint8Map(m map[uint64]uint8) Uint64Uint8ConcurrentMapOption {
	return func(cm *Uint64Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Uint8ConcurrentMap(opts ...Uint64Uint8ConcurrentMapOption) *Uint64Uint8ConcurrentMap {
	cm := &Uint64Uint8ConcurrentMap{
		m: make(map[uint64]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Uint8MapKeyValue struct {
	Key   uint64
	Value uint8
}

type Uint64Uint8ConcurrentMap struct {
	m map[uint64]uint8
	L *sync.RWMutex
}

func (cm *Uint64Uint8ConcurrentMap) Get(k uint64) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Uint8ConcurrentMap) GetDefault(k uint64, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Uint8ConcurrentMap) GetOK(k uint64) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Uint8ConcurrentMap) Set(k uint64, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Uint8ConcurrentMap) Delete(k uint64) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Uint8ConcurrentMap) SetKeyValues(kvs ...Uint64Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Uint8ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Uint8ConcurrentMap) KeyValues() []Uint64Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Uint8ConcurrentMap) ToUnsafeMap() map[uint64]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Uint16KeyValue struct {
	Key   uint64
	Value uint16
}

type Uint64Uint16ConcurrentMapOption func(*Uint64Uint16ConcurrentMap)

func WithUnsafeUint64Uint16Map(m map[uint64]uint16) Uint64Uint16ConcurrentMapOption {
	return func(cm *Uint64Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Uint16Map(m map[uint64]uint16) Uint64Uint16ConcurrentMapOption {
	return func(cm *Uint64Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Uint16ConcurrentMap(opts ...Uint64Uint16ConcurrentMapOption) *Uint64Uint16ConcurrentMap {
	cm := &Uint64Uint16ConcurrentMap{
		m: make(map[uint64]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Uint16MapKeyValue struct {
	Key   uint64
	Value uint16
}

type Uint64Uint16ConcurrentMap struct {
	m map[uint64]uint16
	L *sync.RWMutex
}

func (cm *Uint64Uint16ConcurrentMap) Get(k uint64) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Uint16ConcurrentMap) GetDefault(k uint64, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Uint16ConcurrentMap) GetOK(k uint64) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Uint16ConcurrentMap) Set(k uint64, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Uint16ConcurrentMap) Delete(k uint64) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Uint16ConcurrentMap) SetKeyValues(kvs ...Uint64Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Uint16ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Uint16ConcurrentMap) KeyValues() []Uint64Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Uint16ConcurrentMap) ToUnsafeMap() map[uint64]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64InterfaceKeyValue struct {
	Key   uint64
	Value Interface
}

type Uint64InterfaceConcurrentMapOption func(*Uint64InterfaceConcurrentMap)

func WithUnsafeUint64InterfaceMap(m map[uint64]Interface) Uint64InterfaceConcurrentMapOption {
	return func(cm *Uint64InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64InterfaceMap(m map[uint64]Interface) Uint64InterfaceConcurrentMapOption {
	return func(cm *Uint64InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64InterfaceConcurrentMap(opts ...Uint64InterfaceConcurrentMapOption) *Uint64InterfaceConcurrentMap {
	cm := &Uint64InterfaceConcurrentMap{
		m: make(map[uint64]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64InterfaceMapKeyValue struct {
	Key   uint64
	Value Interface
}

type Uint64InterfaceConcurrentMap struct {
	m map[uint64]Interface
	L *sync.RWMutex
}

func (cm *Uint64InterfaceConcurrentMap) Get(k uint64) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64InterfaceConcurrentMap) GetDefault(k uint64, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64InterfaceConcurrentMap) GetOK(k uint64) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64InterfaceConcurrentMap) Set(k uint64, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64InterfaceConcurrentMap) Delete(k uint64) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64InterfaceConcurrentMap) SetKeyValues(kvs ...Uint64InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64InterfaceConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64InterfaceConcurrentMap) KeyValues() []Uint64InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64InterfaceConcurrentMap) ToUnsafeMap() map[uint64]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Uint32KeyValue struct {
	Key   uint64
	Value uint32
}

type Uint64Uint32ConcurrentMapOption func(*Uint64Uint32ConcurrentMap)

func WithUnsafeUint64Uint32Map(m map[uint64]uint32) Uint64Uint32ConcurrentMapOption {
	return func(cm *Uint64Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Uint32Map(m map[uint64]uint32) Uint64Uint32ConcurrentMapOption {
	return func(cm *Uint64Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Uint32ConcurrentMap(opts ...Uint64Uint32ConcurrentMapOption) *Uint64Uint32ConcurrentMap {
	cm := &Uint64Uint32ConcurrentMap{
		m: make(map[uint64]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Uint32MapKeyValue struct {
	Key   uint64
	Value uint32
}

type Uint64Uint32ConcurrentMap struct {
	m map[uint64]uint32
	L *sync.RWMutex
}

func (cm *Uint64Uint32ConcurrentMap) Get(k uint64) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Uint32ConcurrentMap) GetDefault(k uint64, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Uint32ConcurrentMap) GetOK(k uint64) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Uint32ConcurrentMap) Set(k uint64, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Uint32ConcurrentMap) Delete(k uint64) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Uint32ConcurrentMap) SetKeyValues(kvs ...Uint64Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Uint32ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Uint32ConcurrentMap) KeyValues() []Uint64Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Uint32ConcurrentMap) ToUnsafeMap() map[uint64]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Uint64KeyValue struct {
	Key   uint64
	Value uint64
}

type Uint64Uint64ConcurrentMapOption func(*Uint64Uint64ConcurrentMap)

func WithUnsafeUint64Uint64Map(m map[uint64]uint64) Uint64Uint64ConcurrentMapOption {
	return func(cm *Uint64Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Uint64Map(m map[uint64]uint64) Uint64Uint64ConcurrentMapOption {
	return func(cm *Uint64Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Uint64ConcurrentMap(opts ...Uint64Uint64ConcurrentMapOption) *Uint64Uint64ConcurrentMap {
	cm := &Uint64Uint64ConcurrentMap{
		m: make(map[uint64]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Uint64MapKeyValue struct {
	Key   uint64
	Value uint64
}

type Uint64Uint64ConcurrentMap struct {
	m map[uint64]uint64
	L *sync.RWMutex
}

func (cm *Uint64Uint64ConcurrentMap) Get(k uint64) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Uint64ConcurrentMap) GetDefault(k uint64, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Uint64ConcurrentMap) GetOK(k uint64) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Uint64ConcurrentMap) Set(k uint64, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Uint64ConcurrentMap) Delete(k uint64) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Uint64ConcurrentMap) SetKeyValues(kvs ...Uint64Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Uint64ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Uint64ConcurrentMap) KeyValues() []Uint64Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Uint64ConcurrentMap) ToUnsafeMap() map[uint64]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64IntKeyValue struct {
	Key   uint64
	Value int
}

type Uint64IntConcurrentMapOption func(*Uint64IntConcurrentMap)

func WithUnsafeUint64IntMap(m map[uint64]int) Uint64IntConcurrentMapOption {
	return func(cm *Uint64IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64IntMap(m map[uint64]int) Uint64IntConcurrentMapOption {
	return func(cm *Uint64IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64IntConcurrentMap(opts ...Uint64IntConcurrentMapOption) *Uint64IntConcurrentMap {
	cm := &Uint64IntConcurrentMap{
		m: make(map[uint64]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64IntMapKeyValue struct {
	Key   uint64
	Value int
}

type Uint64IntConcurrentMap struct {
	m map[uint64]int
	L *sync.RWMutex
}

func (cm *Uint64IntConcurrentMap) Get(k uint64) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64IntConcurrentMap) GetDefault(k uint64, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64IntConcurrentMap) GetOK(k uint64) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64IntConcurrentMap) Set(k uint64, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64IntConcurrentMap) Delete(k uint64) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64IntConcurrentMap) SetKeyValues(kvs ...Uint64IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64IntConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64IntConcurrentMap) KeyValues() []Uint64IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64IntConcurrentMap) ToUnsafeMap() map[uint64]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Int8KeyValue struct {
	Key   uint64
	Value int8
}

type Uint64Int8ConcurrentMapOption func(*Uint64Int8ConcurrentMap)

func WithUnsafeUint64Int8Map(m map[uint64]int8) Uint64Int8ConcurrentMapOption {
	return func(cm *Uint64Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Int8Map(m map[uint64]int8) Uint64Int8ConcurrentMapOption {
	return func(cm *Uint64Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Int8ConcurrentMap(opts ...Uint64Int8ConcurrentMapOption) *Uint64Int8ConcurrentMap {
	cm := &Uint64Int8ConcurrentMap{
		m: make(map[uint64]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Int8MapKeyValue struct {
	Key   uint64
	Value int8
}

type Uint64Int8ConcurrentMap struct {
	m map[uint64]int8
	L *sync.RWMutex
}

func (cm *Uint64Int8ConcurrentMap) Get(k uint64) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Int8ConcurrentMap) GetDefault(k uint64, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Int8ConcurrentMap) GetOK(k uint64) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Int8ConcurrentMap) Set(k uint64, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Int8ConcurrentMap) Delete(k uint64) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Int8ConcurrentMap) SetKeyValues(kvs ...Uint64Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Int8ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Int8ConcurrentMap) KeyValues() []Uint64Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Int8ConcurrentMap) ToUnsafeMap() map[uint64]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Int16KeyValue struct {
	Key   uint64
	Value int16
}

type Uint64Int16ConcurrentMapOption func(*Uint64Int16ConcurrentMap)

func WithUnsafeUint64Int16Map(m map[uint64]int16) Uint64Int16ConcurrentMapOption {
	return func(cm *Uint64Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Int16Map(m map[uint64]int16) Uint64Int16ConcurrentMapOption {
	return func(cm *Uint64Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Int16ConcurrentMap(opts ...Uint64Int16ConcurrentMapOption) *Uint64Int16ConcurrentMap {
	cm := &Uint64Int16ConcurrentMap{
		m: make(map[uint64]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Int16MapKeyValue struct {
	Key   uint64
	Value int16
}

type Uint64Int16ConcurrentMap struct {
	m map[uint64]int16
	L *sync.RWMutex
}

func (cm *Uint64Int16ConcurrentMap) Get(k uint64) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Int16ConcurrentMap) GetDefault(k uint64, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Int16ConcurrentMap) GetOK(k uint64) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Int16ConcurrentMap) Set(k uint64, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Int16ConcurrentMap) Delete(k uint64) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Int16ConcurrentMap) SetKeyValues(kvs ...Uint64Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Int16ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Int16ConcurrentMap) KeyValues() []Uint64Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Int16ConcurrentMap) ToUnsafeMap() map[uint64]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Int32KeyValue struct {
	Key   uint64
	Value int32
}

type Uint64Int32ConcurrentMapOption func(*Uint64Int32ConcurrentMap)

func WithUnsafeUint64Int32Map(m map[uint64]int32) Uint64Int32ConcurrentMapOption {
	return func(cm *Uint64Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Int32Map(m map[uint64]int32) Uint64Int32ConcurrentMapOption {
	return func(cm *Uint64Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Int32ConcurrentMap(opts ...Uint64Int32ConcurrentMapOption) *Uint64Int32ConcurrentMap {
	cm := &Uint64Int32ConcurrentMap{
		m: make(map[uint64]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Int32MapKeyValue struct {
	Key   uint64
	Value int32
}

type Uint64Int32ConcurrentMap struct {
	m map[uint64]int32
	L *sync.RWMutex
}

func (cm *Uint64Int32ConcurrentMap) Get(k uint64) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Int32ConcurrentMap) GetDefault(k uint64, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Int32ConcurrentMap) GetOK(k uint64) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Int32ConcurrentMap) Set(k uint64, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Int32ConcurrentMap) Delete(k uint64) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Int32ConcurrentMap) SetKeyValues(kvs ...Uint64Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Int32ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Int32ConcurrentMap) KeyValues() []Uint64Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Int32ConcurrentMap) ToUnsafeMap() map[uint64]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Int64KeyValue struct {
	Key   uint64
	Value int64
}

type Uint64Int64ConcurrentMapOption func(*Uint64Int64ConcurrentMap)

func WithUnsafeUint64Int64Map(m map[uint64]int64) Uint64Int64ConcurrentMapOption {
	return func(cm *Uint64Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Int64Map(m map[uint64]int64) Uint64Int64ConcurrentMapOption {
	return func(cm *Uint64Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Int64ConcurrentMap(opts ...Uint64Int64ConcurrentMapOption) *Uint64Int64ConcurrentMap {
	cm := &Uint64Int64ConcurrentMap{
		m: make(map[uint64]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Int64MapKeyValue struct {
	Key   uint64
	Value int64
}

type Uint64Int64ConcurrentMap struct {
	m map[uint64]int64
	L *sync.RWMutex
}

func (cm *Uint64Int64ConcurrentMap) Get(k uint64) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Int64ConcurrentMap) GetDefault(k uint64, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Int64ConcurrentMap) GetOK(k uint64) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Int64ConcurrentMap) Set(k uint64, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Int64ConcurrentMap) Delete(k uint64) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Int64ConcurrentMap) SetKeyValues(kvs ...Uint64Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Int64ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Int64ConcurrentMap) KeyValues() []Uint64Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Int64ConcurrentMap) ToUnsafeMap() map[uint64]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Float32KeyValue struct {
	Key   uint64
	Value float32
}

type Uint64Float32ConcurrentMapOption func(*Uint64Float32ConcurrentMap)

func WithUnsafeUint64Float32Map(m map[uint64]float32) Uint64Float32ConcurrentMapOption {
	return func(cm *Uint64Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Float32Map(m map[uint64]float32) Uint64Float32ConcurrentMapOption {
	return func(cm *Uint64Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Float32ConcurrentMap(opts ...Uint64Float32ConcurrentMapOption) *Uint64Float32ConcurrentMap {
	cm := &Uint64Float32ConcurrentMap{
		m: make(map[uint64]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Float32MapKeyValue struct {
	Key   uint64
	Value float32
}

type Uint64Float32ConcurrentMap struct {
	m map[uint64]float32
	L *sync.RWMutex
}

func (cm *Uint64Float32ConcurrentMap) Get(k uint64) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Float32ConcurrentMap) GetDefault(k uint64, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Float32ConcurrentMap) GetOK(k uint64) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Float32ConcurrentMap) Set(k uint64, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Float32ConcurrentMap) Delete(k uint64) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Float32ConcurrentMap) SetKeyValues(kvs ...Uint64Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Float32ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Float32ConcurrentMap) KeyValues() []Uint64Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Float32ConcurrentMap) ToUnsafeMap() map[uint64]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64Float64KeyValue struct {
	Key   uint64
	Value float64
}

type Uint64Float64ConcurrentMapOption func(*Uint64Float64ConcurrentMap)

func WithUnsafeUint64Float64Map(m map[uint64]float64) Uint64Float64ConcurrentMapOption {
	return func(cm *Uint64Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64Float64Map(m map[uint64]float64) Uint64Float64ConcurrentMapOption {
	return func(cm *Uint64Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64Float64ConcurrentMap(opts ...Uint64Float64ConcurrentMapOption) *Uint64Float64ConcurrentMap {
	cm := &Uint64Float64ConcurrentMap{
		m: make(map[uint64]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64Float64MapKeyValue struct {
	Key   uint64
	Value float64
}

type Uint64Float64ConcurrentMap struct {
	m map[uint64]float64
	L *sync.RWMutex
}

func (cm *Uint64Float64ConcurrentMap) Get(k uint64) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64Float64ConcurrentMap) GetDefault(k uint64, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64Float64ConcurrentMap) GetOK(k uint64) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64Float64ConcurrentMap) Set(k uint64, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64Float64ConcurrentMap) Delete(k uint64) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64Float64ConcurrentMap) SetKeyValues(kvs ...Uint64Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64Float64ConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64Float64ConcurrentMap) KeyValues() []Uint64Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64Float64ConcurrentMap) ToUnsafeMap() map[uint64]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64TypeKeyValue struct {
	Key   uint64
	Value Type
}

type Uint64TypeConcurrentMapOption func(*Uint64TypeConcurrentMap)

func WithUnsafeUint64TypeMap(m map[uint64]Type) Uint64TypeConcurrentMapOption {
	return func(cm *Uint64TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64TypeMap(m map[uint64]Type) Uint64TypeConcurrentMapOption {
	return func(cm *Uint64TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64TypeConcurrentMap(opts ...Uint64TypeConcurrentMapOption) *Uint64TypeConcurrentMap {
	cm := &Uint64TypeConcurrentMap{
		m: make(map[uint64]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64TypeMapKeyValue struct {
	Key   uint64
	Value Type
}

type Uint64TypeConcurrentMap struct {
	m map[uint64]Type
	L *sync.RWMutex
}

func (cm *Uint64TypeConcurrentMap) Get(k uint64) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64TypeConcurrentMap) GetDefault(k uint64, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64TypeConcurrentMap) GetOK(k uint64) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64TypeConcurrentMap) Set(k uint64, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64TypeConcurrentMap) Delete(k uint64) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64TypeConcurrentMap) SetKeyValues(kvs ...Uint64TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64TypeConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64TypeConcurrentMap) KeyValues() []Uint64TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64TypeConcurrentMap) ToUnsafeMap() map[uint64]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64BoolKeyValue struct {
	Key   uint64
	Value bool
}

type Uint64BoolConcurrentMapOption func(*Uint64BoolConcurrentMap)

func WithUnsafeUint64BoolMap(m map[uint64]bool) Uint64BoolConcurrentMapOption {
	return func(cm *Uint64BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64BoolMap(m map[uint64]bool) Uint64BoolConcurrentMapOption {
	return func(cm *Uint64BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64BoolConcurrentMap(opts ...Uint64BoolConcurrentMapOption) *Uint64BoolConcurrentMap {
	cm := &Uint64BoolConcurrentMap{
		m: make(map[uint64]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64BoolMapKeyValue struct {
	Key   uint64
	Value bool
}

type Uint64BoolConcurrentMap struct {
	m map[uint64]bool
	L *sync.RWMutex
}

func (cm *Uint64BoolConcurrentMap) Get(k uint64) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64BoolConcurrentMap) GetDefault(k uint64, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64BoolConcurrentMap) GetOK(k uint64) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64BoolConcurrentMap) Set(k uint64, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64BoolConcurrentMap) Delete(k uint64) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64BoolConcurrentMap) SetKeyValues(kvs ...Uint64BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64BoolConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64BoolConcurrentMap) KeyValues() []Uint64BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64BoolConcurrentMap) ToUnsafeMap() map[uint64]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Uint64StringKeyValue struct {
	Key   uint64
	Value string
}

type Uint64StringConcurrentMapOption func(*Uint64StringConcurrentMap)

func WithUnsafeUint64StringMap(m map[uint64]string) Uint64StringConcurrentMapOption {
	return func(cm *Uint64StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithUint64StringMap(m map[uint64]string) Uint64StringConcurrentMapOption {
	return func(cm *Uint64StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewUint64StringConcurrentMap(opts ...Uint64StringConcurrentMapOption) *Uint64StringConcurrentMap {
	cm := &Uint64StringConcurrentMap{
		m: make(map[uint64]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Uint64StringMapKeyValue struct {
	Key   uint64
	Value string
}

type Uint64StringConcurrentMap struct {
	m map[uint64]string
	L *sync.RWMutex
}

func (cm *Uint64StringConcurrentMap) Get(k uint64) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Uint64StringConcurrentMap) GetDefault(k uint64, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Uint64StringConcurrentMap) GetOK(k uint64) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Uint64StringConcurrentMap) Set(k uint64, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Uint64StringConcurrentMap) Delete(k uint64) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Uint64StringConcurrentMap) SetKeyValues(kvs ...Uint64StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Uint64StringConcurrentMap) Keys() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []uint64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Uint64StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Uint64StringConcurrentMap) KeyValues() []Uint64StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Uint64StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Uint64StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Uint64StringConcurrentMap) ToUnsafeMap() map[uint64]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[uint64]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntByteKeyValue struct {
	Key   int
	Value byte
}

type IntByteConcurrentMapOption func(*IntByteConcurrentMap)

func WithUnsafeIntByteMap(m map[int]byte) IntByteConcurrentMapOption {
	return func(cm *IntByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntByteMap(m map[int]byte) IntByteConcurrentMapOption {
	return func(cm *IntByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntByteConcurrentMap(opts ...IntByteConcurrentMapOption) *IntByteConcurrentMap {
	cm := &IntByteConcurrentMap{
		m: make(map[int]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntByteMapKeyValue struct {
	Key   int
	Value byte
}

type IntByteConcurrentMap struct {
	m map[int]byte
	L *sync.RWMutex
}

func (cm *IntByteConcurrentMap) Get(k int) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntByteConcurrentMap) GetDefault(k int, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntByteConcurrentMap) GetOK(k int) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntByteConcurrentMap) Set(k int, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntByteConcurrentMap) Delete(k int) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntByteConcurrentMap) SetKeyValues(kvs ...IntByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntByteConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntByteConcurrentMap) KeyValues() []IntByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntByteConcurrentMap) ToUnsafeMap() map[int]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntRuneKeyValue struct {
	Key   int
	Value rune
}

type IntRuneConcurrentMapOption func(*IntRuneConcurrentMap)

func WithUnsafeIntRuneMap(m map[int]rune) IntRuneConcurrentMapOption {
	return func(cm *IntRuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntRuneMap(m map[int]rune) IntRuneConcurrentMapOption {
	return func(cm *IntRuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntRuneConcurrentMap(opts ...IntRuneConcurrentMapOption) *IntRuneConcurrentMap {
	cm := &IntRuneConcurrentMap{
		m: make(map[int]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntRuneMapKeyValue struct {
	Key   int
	Value rune
}

type IntRuneConcurrentMap struct {
	m map[int]rune
	L *sync.RWMutex
}

func (cm *IntRuneConcurrentMap) Get(k int) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntRuneConcurrentMap) GetDefault(k int, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntRuneConcurrentMap) GetOK(k int) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntRuneConcurrentMap) Set(k int, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntRuneConcurrentMap) Delete(k int) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntRuneConcurrentMap) SetKeyValues(kvs ...IntRuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntRuneConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntRuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntRuneConcurrentMap) KeyValues() []IntRuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntRuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntRuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntRuneConcurrentMap) ToUnsafeMap() map[int]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntUintKeyValue struct {
	Key   int
	Value uint
}

type IntUintConcurrentMapOption func(*IntUintConcurrentMap)

func WithUnsafeIntUintMap(m map[int]uint) IntUintConcurrentMapOption {
	return func(cm *IntUintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntUintMap(m map[int]uint) IntUintConcurrentMapOption {
	return func(cm *IntUintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntUintConcurrentMap(opts ...IntUintConcurrentMapOption) *IntUintConcurrentMap {
	cm := &IntUintConcurrentMap{
		m: make(map[int]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntUintMapKeyValue struct {
	Key   int
	Value uint
}

type IntUintConcurrentMap struct {
	m map[int]uint
	L *sync.RWMutex
}

func (cm *IntUintConcurrentMap) Get(k int) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntUintConcurrentMap) GetDefault(k int, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntUintConcurrentMap) GetOK(k int) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntUintConcurrentMap) Set(k int, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntUintConcurrentMap) Delete(k int) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntUintConcurrentMap) SetKeyValues(kvs ...IntUintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntUintConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntUintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntUintConcurrentMap) KeyValues() []IntUintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntUintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntUintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntUintConcurrentMap) ToUnsafeMap() map[int]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntUint8KeyValue struct {
	Key   int
	Value uint8
}

type IntUint8ConcurrentMapOption func(*IntUint8ConcurrentMap)

func WithUnsafeIntUint8Map(m map[int]uint8) IntUint8ConcurrentMapOption {
	return func(cm *IntUint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntUint8Map(m map[int]uint8) IntUint8ConcurrentMapOption {
	return func(cm *IntUint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntUint8ConcurrentMap(opts ...IntUint8ConcurrentMapOption) *IntUint8ConcurrentMap {
	cm := &IntUint8ConcurrentMap{
		m: make(map[int]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntUint8MapKeyValue struct {
	Key   int
	Value uint8
}

type IntUint8ConcurrentMap struct {
	m map[int]uint8
	L *sync.RWMutex
}

func (cm *IntUint8ConcurrentMap) Get(k int) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntUint8ConcurrentMap) GetDefault(k int, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntUint8ConcurrentMap) GetOK(k int) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntUint8ConcurrentMap) Set(k int, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntUint8ConcurrentMap) Delete(k int) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntUint8ConcurrentMap) SetKeyValues(kvs ...IntUint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntUint8ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntUint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntUint8ConcurrentMap) KeyValues() []IntUint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntUint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntUint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntUint8ConcurrentMap) ToUnsafeMap() map[int]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntUint16KeyValue struct {
	Key   int
	Value uint16
}

type IntUint16ConcurrentMapOption func(*IntUint16ConcurrentMap)

func WithUnsafeIntUint16Map(m map[int]uint16) IntUint16ConcurrentMapOption {
	return func(cm *IntUint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntUint16Map(m map[int]uint16) IntUint16ConcurrentMapOption {
	return func(cm *IntUint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntUint16ConcurrentMap(opts ...IntUint16ConcurrentMapOption) *IntUint16ConcurrentMap {
	cm := &IntUint16ConcurrentMap{
		m: make(map[int]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntUint16MapKeyValue struct {
	Key   int
	Value uint16
}

type IntUint16ConcurrentMap struct {
	m map[int]uint16
	L *sync.RWMutex
}

func (cm *IntUint16ConcurrentMap) Get(k int) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntUint16ConcurrentMap) GetDefault(k int, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntUint16ConcurrentMap) GetOK(k int) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntUint16ConcurrentMap) Set(k int, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntUint16ConcurrentMap) Delete(k int) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntUint16ConcurrentMap) SetKeyValues(kvs ...IntUint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntUint16ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntUint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntUint16ConcurrentMap) KeyValues() []IntUint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntUint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntUint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntUint16ConcurrentMap) ToUnsafeMap() map[int]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntInterfaceKeyValue struct {
	Key   int
	Value Interface
}

type IntInterfaceConcurrentMapOption func(*IntInterfaceConcurrentMap)

func WithUnsafeIntInterfaceMap(m map[int]Interface) IntInterfaceConcurrentMapOption {
	return func(cm *IntInterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntInterfaceMap(m map[int]Interface) IntInterfaceConcurrentMapOption {
	return func(cm *IntInterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntInterfaceConcurrentMap(opts ...IntInterfaceConcurrentMapOption) *IntInterfaceConcurrentMap {
	cm := &IntInterfaceConcurrentMap{
		m: make(map[int]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntInterfaceMapKeyValue struct {
	Key   int
	Value Interface
}

type IntInterfaceConcurrentMap struct {
	m map[int]Interface
	L *sync.RWMutex
}

func (cm *IntInterfaceConcurrentMap) Get(k int) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntInterfaceConcurrentMap) GetDefault(k int, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntInterfaceConcurrentMap) GetOK(k int) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntInterfaceConcurrentMap) Set(k int, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntInterfaceConcurrentMap) Delete(k int) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntInterfaceConcurrentMap) SetKeyValues(kvs ...IntInterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntInterfaceConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntInterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntInterfaceConcurrentMap) KeyValues() []IntInterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntInterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntInterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntInterfaceConcurrentMap) ToUnsafeMap() map[int]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntUint32KeyValue struct {
	Key   int
	Value uint32
}

type IntUint32ConcurrentMapOption func(*IntUint32ConcurrentMap)

func WithUnsafeIntUint32Map(m map[int]uint32) IntUint32ConcurrentMapOption {
	return func(cm *IntUint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntUint32Map(m map[int]uint32) IntUint32ConcurrentMapOption {
	return func(cm *IntUint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntUint32ConcurrentMap(opts ...IntUint32ConcurrentMapOption) *IntUint32ConcurrentMap {
	cm := &IntUint32ConcurrentMap{
		m: make(map[int]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntUint32MapKeyValue struct {
	Key   int
	Value uint32
}

type IntUint32ConcurrentMap struct {
	m map[int]uint32
	L *sync.RWMutex
}

func (cm *IntUint32ConcurrentMap) Get(k int) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntUint32ConcurrentMap) GetDefault(k int, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntUint32ConcurrentMap) GetOK(k int) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntUint32ConcurrentMap) Set(k int, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntUint32ConcurrentMap) Delete(k int) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntUint32ConcurrentMap) SetKeyValues(kvs ...IntUint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntUint32ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntUint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntUint32ConcurrentMap) KeyValues() []IntUint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntUint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntUint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntUint32ConcurrentMap) ToUnsafeMap() map[int]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntUint64KeyValue struct {
	Key   int
	Value uint64
}

type IntUint64ConcurrentMapOption func(*IntUint64ConcurrentMap)

func WithUnsafeIntUint64Map(m map[int]uint64) IntUint64ConcurrentMapOption {
	return func(cm *IntUint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntUint64Map(m map[int]uint64) IntUint64ConcurrentMapOption {
	return func(cm *IntUint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntUint64ConcurrentMap(opts ...IntUint64ConcurrentMapOption) *IntUint64ConcurrentMap {
	cm := &IntUint64ConcurrentMap{
		m: make(map[int]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntUint64MapKeyValue struct {
	Key   int
	Value uint64
}

type IntUint64ConcurrentMap struct {
	m map[int]uint64
	L *sync.RWMutex
}

func (cm *IntUint64ConcurrentMap) Get(k int) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntUint64ConcurrentMap) GetDefault(k int, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntUint64ConcurrentMap) GetOK(k int) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntUint64ConcurrentMap) Set(k int, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntUint64ConcurrentMap) Delete(k int) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntUint64ConcurrentMap) SetKeyValues(kvs ...IntUint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntUint64ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntUint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntUint64ConcurrentMap) KeyValues() []IntUint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntUint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntUint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntUint64ConcurrentMap) ToUnsafeMap() map[int]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntIntKeyValue struct {
	Key   int
	Value int
}

type IntIntConcurrentMapOption func(*IntIntConcurrentMap)

func WithUnsafeIntIntMap(m map[int]int) IntIntConcurrentMapOption {
	return func(cm *IntIntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntIntMap(m map[int]int) IntIntConcurrentMapOption {
	return func(cm *IntIntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntIntConcurrentMap(opts ...IntIntConcurrentMapOption) *IntIntConcurrentMap {
	cm := &IntIntConcurrentMap{
		m: make(map[int]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntIntMapKeyValue struct {
	Key   int
	Value int
}

type IntIntConcurrentMap struct {
	m map[int]int
	L *sync.RWMutex
}

func (cm *IntIntConcurrentMap) Get(k int) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntIntConcurrentMap) GetDefault(k int, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntIntConcurrentMap) GetOK(k int) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntIntConcurrentMap) Set(k int, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntIntConcurrentMap) Delete(k int) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntIntConcurrentMap) SetKeyValues(kvs ...IntIntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntIntConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntIntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntIntConcurrentMap) KeyValues() []IntIntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntIntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntIntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntIntConcurrentMap) ToUnsafeMap() map[int]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntInt8KeyValue struct {
	Key   int
	Value int8
}

type IntInt8ConcurrentMapOption func(*IntInt8ConcurrentMap)

func WithUnsafeIntInt8Map(m map[int]int8) IntInt8ConcurrentMapOption {
	return func(cm *IntInt8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntInt8Map(m map[int]int8) IntInt8ConcurrentMapOption {
	return func(cm *IntInt8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntInt8ConcurrentMap(opts ...IntInt8ConcurrentMapOption) *IntInt8ConcurrentMap {
	cm := &IntInt8ConcurrentMap{
		m: make(map[int]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntInt8MapKeyValue struct {
	Key   int
	Value int8
}

type IntInt8ConcurrentMap struct {
	m map[int]int8
	L *sync.RWMutex
}

func (cm *IntInt8ConcurrentMap) Get(k int) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntInt8ConcurrentMap) GetDefault(k int, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntInt8ConcurrentMap) GetOK(k int) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntInt8ConcurrentMap) Set(k int, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntInt8ConcurrentMap) Delete(k int) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntInt8ConcurrentMap) SetKeyValues(kvs ...IntInt8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntInt8ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntInt8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntInt8ConcurrentMap) KeyValues() []IntInt8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntInt8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntInt8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntInt8ConcurrentMap) ToUnsafeMap() map[int]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntInt16KeyValue struct {
	Key   int
	Value int16
}

type IntInt16ConcurrentMapOption func(*IntInt16ConcurrentMap)

func WithUnsafeIntInt16Map(m map[int]int16) IntInt16ConcurrentMapOption {
	return func(cm *IntInt16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntInt16Map(m map[int]int16) IntInt16ConcurrentMapOption {
	return func(cm *IntInt16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntInt16ConcurrentMap(opts ...IntInt16ConcurrentMapOption) *IntInt16ConcurrentMap {
	cm := &IntInt16ConcurrentMap{
		m: make(map[int]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntInt16MapKeyValue struct {
	Key   int
	Value int16
}

type IntInt16ConcurrentMap struct {
	m map[int]int16
	L *sync.RWMutex
}

func (cm *IntInt16ConcurrentMap) Get(k int) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntInt16ConcurrentMap) GetDefault(k int, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntInt16ConcurrentMap) GetOK(k int) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntInt16ConcurrentMap) Set(k int, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntInt16ConcurrentMap) Delete(k int) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntInt16ConcurrentMap) SetKeyValues(kvs ...IntInt16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntInt16ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntInt16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntInt16ConcurrentMap) KeyValues() []IntInt16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntInt16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntInt16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntInt16ConcurrentMap) ToUnsafeMap() map[int]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntInt32KeyValue struct {
	Key   int
	Value int32
}

type IntInt32ConcurrentMapOption func(*IntInt32ConcurrentMap)

func WithUnsafeIntInt32Map(m map[int]int32) IntInt32ConcurrentMapOption {
	return func(cm *IntInt32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntInt32Map(m map[int]int32) IntInt32ConcurrentMapOption {
	return func(cm *IntInt32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntInt32ConcurrentMap(opts ...IntInt32ConcurrentMapOption) *IntInt32ConcurrentMap {
	cm := &IntInt32ConcurrentMap{
		m: make(map[int]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntInt32MapKeyValue struct {
	Key   int
	Value int32
}

type IntInt32ConcurrentMap struct {
	m map[int]int32
	L *sync.RWMutex
}

func (cm *IntInt32ConcurrentMap) Get(k int) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntInt32ConcurrentMap) GetDefault(k int, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntInt32ConcurrentMap) GetOK(k int) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntInt32ConcurrentMap) Set(k int, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntInt32ConcurrentMap) Delete(k int) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntInt32ConcurrentMap) SetKeyValues(kvs ...IntInt32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntInt32ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntInt32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntInt32ConcurrentMap) KeyValues() []IntInt32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntInt32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntInt32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntInt32ConcurrentMap) ToUnsafeMap() map[int]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntInt64KeyValue struct {
	Key   int
	Value int64
}

type IntInt64ConcurrentMapOption func(*IntInt64ConcurrentMap)

func WithUnsafeIntInt64Map(m map[int]int64) IntInt64ConcurrentMapOption {
	return func(cm *IntInt64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntInt64Map(m map[int]int64) IntInt64ConcurrentMapOption {
	return func(cm *IntInt64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntInt64ConcurrentMap(opts ...IntInt64ConcurrentMapOption) *IntInt64ConcurrentMap {
	cm := &IntInt64ConcurrentMap{
		m: make(map[int]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntInt64MapKeyValue struct {
	Key   int
	Value int64
}

type IntInt64ConcurrentMap struct {
	m map[int]int64
	L *sync.RWMutex
}

func (cm *IntInt64ConcurrentMap) Get(k int) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntInt64ConcurrentMap) GetDefault(k int, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntInt64ConcurrentMap) GetOK(k int) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntInt64ConcurrentMap) Set(k int, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntInt64ConcurrentMap) Delete(k int) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntInt64ConcurrentMap) SetKeyValues(kvs ...IntInt64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntInt64ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntInt64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntInt64ConcurrentMap) KeyValues() []IntInt64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntInt64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntInt64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntInt64ConcurrentMap) ToUnsafeMap() map[int]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntFloat32KeyValue struct {
	Key   int
	Value float32
}

type IntFloat32ConcurrentMapOption func(*IntFloat32ConcurrentMap)

func WithUnsafeIntFloat32Map(m map[int]float32) IntFloat32ConcurrentMapOption {
	return func(cm *IntFloat32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntFloat32Map(m map[int]float32) IntFloat32ConcurrentMapOption {
	return func(cm *IntFloat32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntFloat32ConcurrentMap(opts ...IntFloat32ConcurrentMapOption) *IntFloat32ConcurrentMap {
	cm := &IntFloat32ConcurrentMap{
		m: make(map[int]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntFloat32MapKeyValue struct {
	Key   int
	Value float32
}

type IntFloat32ConcurrentMap struct {
	m map[int]float32
	L *sync.RWMutex
}

func (cm *IntFloat32ConcurrentMap) Get(k int) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntFloat32ConcurrentMap) GetDefault(k int, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntFloat32ConcurrentMap) GetOK(k int) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntFloat32ConcurrentMap) Set(k int, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntFloat32ConcurrentMap) Delete(k int) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntFloat32ConcurrentMap) SetKeyValues(kvs ...IntFloat32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntFloat32ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntFloat32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntFloat32ConcurrentMap) KeyValues() []IntFloat32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntFloat32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntFloat32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntFloat32ConcurrentMap) ToUnsafeMap() map[int]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntFloat64KeyValue struct {
	Key   int
	Value float64
}

type IntFloat64ConcurrentMapOption func(*IntFloat64ConcurrentMap)

func WithUnsafeIntFloat64Map(m map[int]float64) IntFloat64ConcurrentMapOption {
	return func(cm *IntFloat64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntFloat64Map(m map[int]float64) IntFloat64ConcurrentMapOption {
	return func(cm *IntFloat64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntFloat64ConcurrentMap(opts ...IntFloat64ConcurrentMapOption) *IntFloat64ConcurrentMap {
	cm := &IntFloat64ConcurrentMap{
		m: make(map[int]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntFloat64MapKeyValue struct {
	Key   int
	Value float64
}

type IntFloat64ConcurrentMap struct {
	m map[int]float64
	L *sync.RWMutex
}

func (cm *IntFloat64ConcurrentMap) Get(k int) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntFloat64ConcurrentMap) GetDefault(k int, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntFloat64ConcurrentMap) GetOK(k int) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntFloat64ConcurrentMap) Set(k int, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntFloat64ConcurrentMap) Delete(k int) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntFloat64ConcurrentMap) SetKeyValues(kvs ...IntFloat64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntFloat64ConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntFloat64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntFloat64ConcurrentMap) KeyValues() []IntFloat64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntFloat64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntFloat64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntFloat64ConcurrentMap) ToUnsafeMap() map[int]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntTypeKeyValue struct {
	Key   int
	Value Type
}

type IntTypeConcurrentMapOption func(*IntTypeConcurrentMap)

func WithUnsafeIntTypeMap(m map[int]Type) IntTypeConcurrentMapOption {
	return func(cm *IntTypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntTypeMap(m map[int]Type) IntTypeConcurrentMapOption {
	return func(cm *IntTypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntTypeConcurrentMap(opts ...IntTypeConcurrentMapOption) *IntTypeConcurrentMap {
	cm := &IntTypeConcurrentMap{
		m: make(map[int]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntTypeMapKeyValue struct {
	Key   int
	Value Type
}

type IntTypeConcurrentMap struct {
	m map[int]Type
	L *sync.RWMutex
}

func (cm *IntTypeConcurrentMap) Get(k int) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntTypeConcurrentMap) GetDefault(k int, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntTypeConcurrentMap) GetOK(k int) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntTypeConcurrentMap) Set(k int, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntTypeConcurrentMap) Delete(k int) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntTypeConcurrentMap) SetKeyValues(kvs ...IntTypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntTypeConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntTypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntTypeConcurrentMap) KeyValues() []IntTypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntTypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntTypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntTypeConcurrentMap) ToUnsafeMap() map[int]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntBoolKeyValue struct {
	Key   int
	Value bool
}

type IntBoolConcurrentMapOption func(*IntBoolConcurrentMap)

func WithUnsafeIntBoolMap(m map[int]bool) IntBoolConcurrentMapOption {
	return func(cm *IntBoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntBoolMap(m map[int]bool) IntBoolConcurrentMapOption {
	return func(cm *IntBoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntBoolConcurrentMap(opts ...IntBoolConcurrentMapOption) *IntBoolConcurrentMap {
	cm := &IntBoolConcurrentMap{
		m: make(map[int]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntBoolMapKeyValue struct {
	Key   int
	Value bool
}

type IntBoolConcurrentMap struct {
	m map[int]bool
	L *sync.RWMutex
}

func (cm *IntBoolConcurrentMap) Get(k int) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntBoolConcurrentMap) GetDefault(k int, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntBoolConcurrentMap) GetOK(k int) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntBoolConcurrentMap) Set(k int, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntBoolConcurrentMap) Delete(k int) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntBoolConcurrentMap) SetKeyValues(kvs ...IntBoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntBoolConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntBoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntBoolConcurrentMap) KeyValues() []IntBoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntBoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntBoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntBoolConcurrentMap) ToUnsafeMap() map[int]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type IntStringKeyValue struct {
	Key   int
	Value string
}

type IntStringConcurrentMapOption func(*IntStringConcurrentMap)

func WithUnsafeIntStringMap(m map[int]string) IntStringConcurrentMapOption {
	return func(cm *IntStringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithIntStringMap(m map[int]string) IntStringConcurrentMapOption {
	return func(cm *IntStringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewIntStringConcurrentMap(opts ...IntStringConcurrentMapOption) *IntStringConcurrentMap {
	cm := &IntStringConcurrentMap{
		m: make(map[int]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type IntStringMapKeyValue struct {
	Key   int
	Value string
}

type IntStringConcurrentMap struct {
	m map[int]string
	L *sync.RWMutex
}

func (cm *IntStringConcurrentMap) Get(k int) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *IntStringConcurrentMap) GetDefault(k int, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *IntStringConcurrentMap) GetOK(k int) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *IntStringConcurrentMap) Set(k int, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *IntStringConcurrentMap) Delete(k int) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *IntStringConcurrentMap) SetKeyValues(kvs ...IntStringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *IntStringConcurrentMap) Keys() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *IntStringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *IntStringConcurrentMap) KeyValues() []IntStringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []IntStringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, IntStringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *IntStringConcurrentMap) ToUnsafeMap() map[int]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8ByteKeyValue struct {
	Key   int8
	Value byte
}

type Int8ByteConcurrentMapOption func(*Int8ByteConcurrentMap)

func WithUnsafeInt8ByteMap(m map[int8]byte) Int8ByteConcurrentMapOption {
	return func(cm *Int8ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8ByteMap(m map[int8]byte) Int8ByteConcurrentMapOption {
	return func(cm *Int8ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8ByteConcurrentMap(opts ...Int8ByteConcurrentMapOption) *Int8ByteConcurrentMap {
	cm := &Int8ByteConcurrentMap{
		m: make(map[int8]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8ByteMapKeyValue struct {
	Key   int8
	Value byte
}

type Int8ByteConcurrentMap struct {
	m map[int8]byte
	L *sync.RWMutex
}

func (cm *Int8ByteConcurrentMap) Get(k int8) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8ByteConcurrentMap) GetDefault(k int8, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8ByteConcurrentMap) GetOK(k int8) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8ByteConcurrentMap) Set(k int8, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8ByteConcurrentMap) Delete(k int8) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8ByteConcurrentMap) SetKeyValues(kvs ...Int8ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8ByteConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8ByteConcurrentMap) KeyValues() []Int8ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8ByteConcurrentMap) ToUnsafeMap() map[int8]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8RuneKeyValue struct {
	Key   int8
	Value rune
}

type Int8RuneConcurrentMapOption func(*Int8RuneConcurrentMap)

func WithUnsafeInt8RuneMap(m map[int8]rune) Int8RuneConcurrentMapOption {
	return func(cm *Int8RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8RuneMap(m map[int8]rune) Int8RuneConcurrentMapOption {
	return func(cm *Int8RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8RuneConcurrentMap(opts ...Int8RuneConcurrentMapOption) *Int8RuneConcurrentMap {
	cm := &Int8RuneConcurrentMap{
		m: make(map[int8]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8RuneMapKeyValue struct {
	Key   int8
	Value rune
}

type Int8RuneConcurrentMap struct {
	m map[int8]rune
	L *sync.RWMutex
}

func (cm *Int8RuneConcurrentMap) Get(k int8) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8RuneConcurrentMap) GetDefault(k int8, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8RuneConcurrentMap) GetOK(k int8) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8RuneConcurrentMap) Set(k int8, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8RuneConcurrentMap) Delete(k int8) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8RuneConcurrentMap) SetKeyValues(kvs ...Int8RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8RuneConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8RuneConcurrentMap) KeyValues() []Int8RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8RuneConcurrentMap) ToUnsafeMap() map[int8]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8UintKeyValue struct {
	Key   int8
	Value uint
}

type Int8UintConcurrentMapOption func(*Int8UintConcurrentMap)

func WithUnsafeInt8UintMap(m map[int8]uint) Int8UintConcurrentMapOption {
	return func(cm *Int8UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8UintMap(m map[int8]uint) Int8UintConcurrentMapOption {
	return func(cm *Int8UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8UintConcurrentMap(opts ...Int8UintConcurrentMapOption) *Int8UintConcurrentMap {
	cm := &Int8UintConcurrentMap{
		m: make(map[int8]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8UintMapKeyValue struct {
	Key   int8
	Value uint
}

type Int8UintConcurrentMap struct {
	m map[int8]uint
	L *sync.RWMutex
}

func (cm *Int8UintConcurrentMap) Get(k int8) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8UintConcurrentMap) GetDefault(k int8, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8UintConcurrentMap) GetOK(k int8) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8UintConcurrentMap) Set(k int8, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8UintConcurrentMap) Delete(k int8) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8UintConcurrentMap) SetKeyValues(kvs ...Int8UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8UintConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8UintConcurrentMap) KeyValues() []Int8UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8UintConcurrentMap) ToUnsafeMap() map[int8]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Uint8KeyValue struct {
	Key   int8
	Value uint8
}

type Int8Uint8ConcurrentMapOption func(*Int8Uint8ConcurrentMap)

func WithUnsafeInt8Uint8Map(m map[int8]uint8) Int8Uint8ConcurrentMapOption {
	return func(cm *Int8Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Uint8Map(m map[int8]uint8) Int8Uint8ConcurrentMapOption {
	return func(cm *Int8Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Uint8ConcurrentMap(opts ...Int8Uint8ConcurrentMapOption) *Int8Uint8ConcurrentMap {
	cm := &Int8Uint8ConcurrentMap{
		m: make(map[int8]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Uint8MapKeyValue struct {
	Key   int8
	Value uint8
}

type Int8Uint8ConcurrentMap struct {
	m map[int8]uint8
	L *sync.RWMutex
}

func (cm *Int8Uint8ConcurrentMap) Get(k int8) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Uint8ConcurrentMap) GetDefault(k int8, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Uint8ConcurrentMap) GetOK(k int8) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Uint8ConcurrentMap) Set(k int8, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Uint8ConcurrentMap) Delete(k int8) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Uint8ConcurrentMap) SetKeyValues(kvs ...Int8Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Uint8ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Uint8ConcurrentMap) KeyValues() []Int8Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Uint8ConcurrentMap) ToUnsafeMap() map[int8]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Uint16KeyValue struct {
	Key   int8
	Value uint16
}

type Int8Uint16ConcurrentMapOption func(*Int8Uint16ConcurrentMap)

func WithUnsafeInt8Uint16Map(m map[int8]uint16) Int8Uint16ConcurrentMapOption {
	return func(cm *Int8Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Uint16Map(m map[int8]uint16) Int8Uint16ConcurrentMapOption {
	return func(cm *Int8Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Uint16ConcurrentMap(opts ...Int8Uint16ConcurrentMapOption) *Int8Uint16ConcurrentMap {
	cm := &Int8Uint16ConcurrentMap{
		m: make(map[int8]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Uint16MapKeyValue struct {
	Key   int8
	Value uint16
}

type Int8Uint16ConcurrentMap struct {
	m map[int8]uint16
	L *sync.RWMutex
}

func (cm *Int8Uint16ConcurrentMap) Get(k int8) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Uint16ConcurrentMap) GetDefault(k int8, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Uint16ConcurrentMap) GetOK(k int8) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Uint16ConcurrentMap) Set(k int8, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Uint16ConcurrentMap) Delete(k int8) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Uint16ConcurrentMap) SetKeyValues(kvs ...Int8Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Uint16ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Uint16ConcurrentMap) KeyValues() []Int8Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Uint16ConcurrentMap) ToUnsafeMap() map[int8]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8InterfaceKeyValue struct {
	Key   int8
	Value Interface
}

type Int8InterfaceConcurrentMapOption func(*Int8InterfaceConcurrentMap)

func WithUnsafeInt8InterfaceMap(m map[int8]Interface) Int8InterfaceConcurrentMapOption {
	return func(cm *Int8InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8InterfaceMap(m map[int8]Interface) Int8InterfaceConcurrentMapOption {
	return func(cm *Int8InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8InterfaceConcurrentMap(opts ...Int8InterfaceConcurrentMapOption) *Int8InterfaceConcurrentMap {
	cm := &Int8InterfaceConcurrentMap{
		m: make(map[int8]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8InterfaceMapKeyValue struct {
	Key   int8
	Value Interface
}

type Int8InterfaceConcurrentMap struct {
	m map[int8]Interface
	L *sync.RWMutex
}

func (cm *Int8InterfaceConcurrentMap) Get(k int8) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8InterfaceConcurrentMap) GetDefault(k int8, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8InterfaceConcurrentMap) GetOK(k int8) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8InterfaceConcurrentMap) Set(k int8, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8InterfaceConcurrentMap) Delete(k int8) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8InterfaceConcurrentMap) SetKeyValues(kvs ...Int8InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8InterfaceConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8InterfaceConcurrentMap) KeyValues() []Int8InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8InterfaceConcurrentMap) ToUnsafeMap() map[int8]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Uint32KeyValue struct {
	Key   int8
	Value uint32
}

type Int8Uint32ConcurrentMapOption func(*Int8Uint32ConcurrentMap)

func WithUnsafeInt8Uint32Map(m map[int8]uint32) Int8Uint32ConcurrentMapOption {
	return func(cm *Int8Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Uint32Map(m map[int8]uint32) Int8Uint32ConcurrentMapOption {
	return func(cm *Int8Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Uint32ConcurrentMap(opts ...Int8Uint32ConcurrentMapOption) *Int8Uint32ConcurrentMap {
	cm := &Int8Uint32ConcurrentMap{
		m: make(map[int8]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Uint32MapKeyValue struct {
	Key   int8
	Value uint32
}

type Int8Uint32ConcurrentMap struct {
	m map[int8]uint32
	L *sync.RWMutex
}

func (cm *Int8Uint32ConcurrentMap) Get(k int8) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Uint32ConcurrentMap) GetDefault(k int8, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Uint32ConcurrentMap) GetOK(k int8) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Uint32ConcurrentMap) Set(k int8, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Uint32ConcurrentMap) Delete(k int8) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Uint32ConcurrentMap) SetKeyValues(kvs ...Int8Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Uint32ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Uint32ConcurrentMap) KeyValues() []Int8Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Uint32ConcurrentMap) ToUnsafeMap() map[int8]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Uint64KeyValue struct {
	Key   int8
	Value uint64
}

type Int8Uint64ConcurrentMapOption func(*Int8Uint64ConcurrentMap)

func WithUnsafeInt8Uint64Map(m map[int8]uint64) Int8Uint64ConcurrentMapOption {
	return func(cm *Int8Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Uint64Map(m map[int8]uint64) Int8Uint64ConcurrentMapOption {
	return func(cm *Int8Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Uint64ConcurrentMap(opts ...Int8Uint64ConcurrentMapOption) *Int8Uint64ConcurrentMap {
	cm := &Int8Uint64ConcurrentMap{
		m: make(map[int8]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Uint64MapKeyValue struct {
	Key   int8
	Value uint64
}

type Int8Uint64ConcurrentMap struct {
	m map[int8]uint64
	L *sync.RWMutex
}

func (cm *Int8Uint64ConcurrentMap) Get(k int8) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Uint64ConcurrentMap) GetDefault(k int8, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Uint64ConcurrentMap) GetOK(k int8) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Uint64ConcurrentMap) Set(k int8, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Uint64ConcurrentMap) Delete(k int8) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Uint64ConcurrentMap) SetKeyValues(kvs ...Int8Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Uint64ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Uint64ConcurrentMap) KeyValues() []Int8Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Uint64ConcurrentMap) ToUnsafeMap() map[int8]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8IntKeyValue struct {
	Key   int8
	Value int
}

type Int8IntConcurrentMapOption func(*Int8IntConcurrentMap)

func WithUnsafeInt8IntMap(m map[int8]int) Int8IntConcurrentMapOption {
	return func(cm *Int8IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8IntMap(m map[int8]int) Int8IntConcurrentMapOption {
	return func(cm *Int8IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8IntConcurrentMap(opts ...Int8IntConcurrentMapOption) *Int8IntConcurrentMap {
	cm := &Int8IntConcurrentMap{
		m: make(map[int8]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8IntMapKeyValue struct {
	Key   int8
	Value int
}

type Int8IntConcurrentMap struct {
	m map[int8]int
	L *sync.RWMutex
}

func (cm *Int8IntConcurrentMap) Get(k int8) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8IntConcurrentMap) GetDefault(k int8, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8IntConcurrentMap) GetOK(k int8) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8IntConcurrentMap) Set(k int8, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8IntConcurrentMap) Delete(k int8) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8IntConcurrentMap) SetKeyValues(kvs ...Int8IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8IntConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8IntConcurrentMap) KeyValues() []Int8IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8IntConcurrentMap) ToUnsafeMap() map[int8]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Int8KeyValue struct {
	Key   int8
	Value int8
}

type Int8Int8ConcurrentMapOption func(*Int8Int8ConcurrentMap)

func WithUnsafeInt8Int8Map(m map[int8]int8) Int8Int8ConcurrentMapOption {
	return func(cm *Int8Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Int8Map(m map[int8]int8) Int8Int8ConcurrentMapOption {
	return func(cm *Int8Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Int8ConcurrentMap(opts ...Int8Int8ConcurrentMapOption) *Int8Int8ConcurrentMap {
	cm := &Int8Int8ConcurrentMap{
		m: make(map[int8]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Int8MapKeyValue struct {
	Key   int8
	Value int8
}

type Int8Int8ConcurrentMap struct {
	m map[int8]int8
	L *sync.RWMutex
}

func (cm *Int8Int8ConcurrentMap) Get(k int8) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Int8ConcurrentMap) GetDefault(k int8, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Int8ConcurrentMap) GetOK(k int8) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Int8ConcurrentMap) Set(k int8, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Int8ConcurrentMap) Delete(k int8) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Int8ConcurrentMap) SetKeyValues(kvs ...Int8Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Int8ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Int8ConcurrentMap) KeyValues() []Int8Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Int8ConcurrentMap) ToUnsafeMap() map[int8]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Int16KeyValue struct {
	Key   int8
	Value int16
}

type Int8Int16ConcurrentMapOption func(*Int8Int16ConcurrentMap)

func WithUnsafeInt8Int16Map(m map[int8]int16) Int8Int16ConcurrentMapOption {
	return func(cm *Int8Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Int16Map(m map[int8]int16) Int8Int16ConcurrentMapOption {
	return func(cm *Int8Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Int16ConcurrentMap(opts ...Int8Int16ConcurrentMapOption) *Int8Int16ConcurrentMap {
	cm := &Int8Int16ConcurrentMap{
		m: make(map[int8]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Int16MapKeyValue struct {
	Key   int8
	Value int16
}

type Int8Int16ConcurrentMap struct {
	m map[int8]int16
	L *sync.RWMutex
}

func (cm *Int8Int16ConcurrentMap) Get(k int8) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Int16ConcurrentMap) GetDefault(k int8, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Int16ConcurrentMap) GetOK(k int8) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Int16ConcurrentMap) Set(k int8, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Int16ConcurrentMap) Delete(k int8) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Int16ConcurrentMap) SetKeyValues(kvs ...Int8Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Int16ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Int16ConcurrentMap) KeyValues() []Int8Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Int16ConcurrentMap) ToUnsafeMap() map[int8]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Int32KeyValue struct {
	Key   int8
	Value int32
}

type Int8Int32ConcurrentMapOption func(*Int8Int32ConcurrentMap)

func WithUnsafeInt8Int32Map(m map[int8]int32) Int8Int32ConcurrentMapOption {
	return func(cm *Int8Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Int32Map(m map[int8]int32) Int8Int32ConcurrentMapOption {
	return func(cm *Int8Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Int32ConcurrentMap(opts ...Int8Int32ConcurrentMapOption) *Int8Int32ConcurrentMap {
	cm := &Int8Int32ConcurrentMap{
		m: make(map[int8]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Int32MapKeyValue struct {
	Key   int8
	Value int32
}

type Int8Int32ConcurrentMap struct {
	m map[int8]int32
	L *sync.RWMutex
}

func (cm *Int8Int32ConcurrentMap) Get(k int8) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Int32ConcurrentMap) GetDefault(k int8, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Int32ConcurrentMap) GetOK(k int8) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Int32ConcurrentMap) Set(k int8, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Int32ConcurrentMap) Delete(k int8) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Int32ConcurrentMap) SetKeyValues(kvs ...Int8Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Int32ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Int32ConcurrentMap) KeyValues() []Int8Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Int32ConcurrentMap) ToUnsafeMap() map[int8]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Int64KeyValue struct {
	Key   int8
	Value int64
}

type Int8Int64ConcurrentMapOption func(*Int8Int64ConcurrentMap)

func WithUnsafeInt8Int64Map(m map[int8]int64) Int8Int64ConcurrentMapOption {
	return func(cm *Int8Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Int64Map(m map[int8]int64) Int8Int64ConcurrentMapOption {
	return func(cm *Int8Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Int64ConcurrentMap(opts ...Int8Int64ConcurrentMapOption) *Int8Int64ConcurrentMap {
	cm := &Int8Int64ConcurrentMap{
		m: make(map[int8]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Int64MapKeyValue struct {
	Key   int8
	Value int64
}

type Int8Int64ConcurrentMap struct {
	m map[int8]int64
	L *sync.RWMutex
}

func (cm *Int8Int64ConcurrentMap) Get(k int8) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Int64ConcurrentMap) GetDefault(k int8, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Int64ConcurrentMap) GetOK(k int8) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Int64ConcurrentMap) Set(k int8, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Int64ConcurrentMap) Delete(k int8) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Int64ConcurrentMap) SetKeyValues(kvs ...Int8Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Int64ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Int64ConcurrentMap) KeyValues() []Int8Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Int64ConcurrentMap) ToUnsafeMap() map[int8]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Float32KeyValue struct {
	Key   int8
	Value float32
}

type Int8Float32ConcurrentMapOption func(*Int8Float32ConcurrentMap)

func WithUnsafeInt8Float32Map(m map[int8]float32) Int8Float32ConcurrentMapOption {
	return func(cm *Int8Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Float32Map(m map[int8]float32) Int8Float32ConcurrentMapOption {
	return func(cm *Int8Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Float32ConcurrentMap(opts ...Int8Float32ConcurrentMapOption) *Int8Float32ConcurrentMap {
	cm := &Int8Float32ConcurrentMap{
		m: make(map[int8]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Float32MapKeyValue struct {
	Key   int8
	Value float32
}

type Int8Float32ConcurrentMap struct {
	m map[int8]float32
	L *sync.RWMutex
}

func (cm *Int8Float32ConcurrentMap) Get(k int8) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Float32ConcurrentMap) GetDefault(k int8, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Float32ConcurrentMap) GetOK(k int8) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Float32ConcurrentMap) Set(k int8, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Float32ConcurrentMap) Delete(k int8) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Float32ConcurrentMap) SetKeyValues(kvs ...Int8Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Float32ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Float32ConcurrentMap) KeyValues() []Int8Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Float32ConcurrentMap) ToUnsafeMap() map[int8]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8Float64KeyValue struct {
	Key   int8
	Value float64
}

type Int8Float64ConcurrentMapOption func(*Int8Float64ConcurrentMap)

func WithUnsafeInt8Float64Map(m map[int8]float64) Int8Float64ConcurrentMapOption {
	return func(cm *Int8Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8Float64Map(m map[int8]float64) Int8Float64ConcurrentMapOption {
	return func(cm *Int8Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8Float64ConcurrentMap(opts ...Int8Float64ConcurrentMapOption) *Int8Float64ConcurrentMap {
	cm := &Int8Float64ConcurrentMap{
		m: make(map[int8]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8Float64MapKeyValue struct {
	Key   int8
	Value float64
}

type Int8Float64ConcurrentMap struct {
	m map[int8]float64
	L *sync.RWMutex
}

func (cm *Int8Float64ConcurrentMap) Get(k int8) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8Float64ConcurrentMap) GetDefault(k int8, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8Float64ConcurrentMap) GetOK(k int8) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8Float64ConcurrentMap) Set(k int8, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8Float64ConcurrentMap) Delete(k int8) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8Float64ConcurrentMap) SetKeyValues(kvs ...Int8Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8Float64ConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8Float64ConcurrentMap) KeyValues() []Int8Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8Float64ConcurrentMap) ToUnsafeMap() map[int8]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8TypeKeyValue struct {
	Key   int8
	Value Type
}

type Int8TypeConcurrentMapOption func(*Int8TypeConcurrentMap)

func WithUnsafeInt8TypeMap(m map[int8]Type) Int8TypeConcurrentMapOption {
	return func(cm *Int8TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8TypeMap(m map[int8]Type) Int8TypeConcurrentMapOption {
	return func(cm *Int8TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8TypeConcurrentMap(opts ...Int8TypeConcurrentMapOption) *Int8TypeConcurrentMap {
	cm := &Int8TypeConcurrentMap{
		m: make(map[int8]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8TypeMapKeyValue struct {
	Key   int8
	Value Type
}

type Int8TypeConcurrentMap struct {
	m map[int8]Type
	L *sync.RWMutex
}

func (cm *Int8TypeConcurrentMap) Get(k int8) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8TypeConcurrentMap) GetDefault(k int8, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8TypeConcurrentMap) GetOK(k int8) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8TypeConcurrentMap) Set(k int8, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8TypeConcurrentMap) Delete(k int8) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8TypeConcurrentMap) SetKeyValues(kvs ...Int8TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8TypeConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8TypeConcurrentMap) KeyValues() []Int8TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8TypeConcurrentMap) ToUnsafeMap() map[int8]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8BoolKeyValue struct {
	Key   int8
	Value bool
}

type Int8BoolConcurrentMapOption func(*Int8BoolConcurrentMap)

func WithUnsafeInt8BoolMap(m map[int8]bool) Int8BoolConcurrentMapOption {
	return func(cm *Int8BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8BoolMap(m map[int8]bool) Int8BoolConcurrentMapOption {
	return func(cm *Int8BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8BoolConcurrentMap(opts ...Int8BoolConcurrentMapOption) *Int8BoolConcurrentMap {
	cm := &Int8BoolConcurrentMap{
		m: make(map[int8]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8BoolMapKeyValue struct {
	Key   int8
	Value bool
}

type Int8BoolConcurrentMap struct {
	m map[int8]bool
	L *sync.RWMutex
}

func (cm *Int8BoolConcurrentMap) Get(k int8) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8BoolConcurrentMap) GetDefault(k int8, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8BoolConcurrentMap) GetOK(k int8) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8BoolConcurrentMap) Set(k int8, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8BoolConcurrentMap) Delete(k int8) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8BoolConcurrentMap) SetKeyValues(kvs ...Int8BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8BoolConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8BoolConcurrentMap) KeyValues() []Int8BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8BoolConcurrentMap) ToUnsafeMap() map[int8]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int8StringKeyValue struct {
	Key   int8
	Value string
}

type Int8StringConcurrentMapOption func(*Int8StringConcurrentMap)

func WithUnsafeInt8StringMap(m map[int8]string) Int8StringConcurrentMapOption {
	return func(cm *Int8StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt8StringMap(m map[int8]string) Int8StringConcurrentMapOption {
	return func(cm *Int8StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt8StringConcurrentMap(opts ...Int8StringConcurrentMapOption) *Int8StringConcurrentMap {
	cm := &Int8StringConcurrentMap{
		m: make(map[int8]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int8StringMapKeyValue struct {
	Key   int8
	Value string
}

type Int8StringConcurrentMap struct {
	m map[int8]string
	L *sync.RWMutex
}

func (cm *Int8StringConcurrentMap) Get(k int8) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int8StringConcurrentMap) GetDefault(k int8, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int8StringConcurrentMap) GetOK(k int8) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int8StringConcurrentMap) Set(k int8, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int8StringConcurrentMap) Delete(k int8) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int8StringConcurrentMap) SetKeyValues(kvs ...Int8StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int8StringConcurrentMap) Keys() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int8
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int8StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int8StringConcurrentMap) KeyValues() []Int8StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int8StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int8StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int8StringConcurrentMap) ToUnsafeMap() map[int8]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int8]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16ByteKeyValue struct {
	Key   int16
	Value byte
}

type Int16ByteConcurrentMapOption func(*Int16ByteConcurrentMap)

func WithUnsafeInt16ByteMap(m map[int16]byte) Int16ByteConcurrentMapOption {
	return func(cm *Int16ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16ByteMap(m map[int16]byte) Int16ByteConcurrentMapOption {
	return func(cm *Int16ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16ByteConcurrentMap(opts ...Int16ByteConcurrentMapOption) *Int16ByteConcurrentMap {
	cm := &Int16ByteConcurrentMap{
		m: make(map[int16]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16ByteMapKeyValue struct {
	Key   int16
	Value byte
}

type Int16ByteConcurrentMap struct {
	m map[int16]byte
	L *sync.RWMutex
}

func (cm *Int16ByteConcurrentMap) Get(k int16) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16ByteConcurrentMap) GetDefault(k int16, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16ByteConcurrentMap) GetOK(k int16) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16ByteConcurrentMap) Set(k int16, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16ByteConcurrentMap) Delete(k int16) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16ByteConcurrentMap) SetKeyValues(kvs ...Int16ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16ByteConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16ByteConcurrentMap) KeyValues() []Int16ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16ByteConcurrentMap) ToUnsafeMap() map[int16]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16RuneKeyValue struct {
	Key   int16
	Value rune
}

type Int16RuneConcurrentMapOption func(*Int16RuneConcurrentMap)

func WithUnsafeInt16RuneMap(m map[int16]rune) Int16RuneConcurrentMapOption {
	return func(cm *Int16RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16RuneMap(m map[int16]rune) Int16RuneConcurrentMapOption {
	return func(cm *Int16RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16RuneConcurrentMap(opts ...Int16RuneConcurrentMapOption) *Int16RuneConcurrentMap {
	cm := &Int16RuneConcurrentMap{
		m: make(map[int16]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16RuneMapKeyValue struct {
	Key   int16
	Value rune
}

type Int16RuneConcurrentMap struct {
	m map[int16]rune
	L *sync.RWMutex
}

func (cm *Int16RuneConcurrentMap) Get(k int16) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16RuneConcurrentMap) GetDefault(k int16, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16RuneConcurrentMap) GetOK(k int16) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16RuneConcurrentMap) Set(k int16, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16RuneConcurrentMap) Delete(k int16) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16RuneConcurrentMap) SetKeyValues(kvs ...Int16RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16RuneConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16RuneConcurrentMap) KeyValues() []Int16RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16RuneConcurrentMap) ToUnsafeMap() map[int16]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16UintKeyValue struct {
	Key   int16
	Value uint
}

type Int16UintConcurrentMapOption func(*Int16UintConcurrentMap)

func WithUnsafeInt16UintMap(m map[int16]uint) Int16UintConcurrentMapOption {
	return func(cm *Int16UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16UintMap(m map[int16]uint) Int16UintConcurrentMapOption {
	return func(cm *Int16UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16UintConcurrentMap(opts ...Int16UintConcurrentMapOption) *Int16UintConcurrentMap {
	cm := &Int16UintConcurrentMap{
		m: make(map[int16]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16UintMapKeyValue struct {
	Key   int16
	Value uint
}

type Int16UintConcurrentMap struct {
	m map[int16]uint
	L *sync.RWMutex
}

func (cm *Int16UintConcurrentMap) Get(k int16) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16UintConcurrentMap) GetDefault(k int16, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16UintConcurrentMap) GetOK(k int16) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16UintConcurrentMap) Set(k int16, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16UintConcurrentMap) Delete(k int16) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16UintConcurrentMap) SetKeyValues(kvs ...Int16UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16UintConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16UintConcurrentMap) KeyValues() []Int16UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16UintConcurrentMap) ToUnsafeMap() map[int16]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Uint8KeyValue struct {
	Key   int16
	Value uint8
}

type Int16Uint8ConcurrentMapOption func(*Int16Uint8ConcurrentMap)

func WithUnsafeInt16Uint8Map(m map[int16]uint8) Int16Uint8ConcurrentMapOption {
	return func(cm *Int16Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Uint8Map(m map[int16]uint8) Int16Uint8ConcurrentMapOption {
	return func(cm *Int16Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Uint8ConcurrentMap(opts ...Int16Uint8ConcurrentMapOption) *Int16Uint8ConcurrentMap {
	cm := &Int16Uint8ConcurrentMap{
		m: make(map[int16]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Uint8MapKeyValue struct {
	Key   int16
	Value uint8
}

type Int16Uint8ConcurrentMap struct {
	m map[int16]uint8
	L *sync.RWMutex
}

func (cm *Int16Uint8ConcurrentMap) Get(k int16) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Uint8ConcurrentMap) GetDefault(k int16, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Uint8ConcurrentMap) GetOK(k int16) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Uint8ConcurrentMap) Set(k int16, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Uint8ConcurrentMap) Delete(k int16) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Uint8ConcurrentMap) SetKeyValues(kvs ...Int16Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Uint8ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Uint8ConcurrentMap) KeyValues() []Int16Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Uint8ConcurrentMap) ToUnsafeMap() map[int16]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Uint16KeyValue struct {
	Key   int16
	Value uint16
}

type Int16Uint16ConcurrentMapOption func(*Int16Uint16ConcurrentMap)

func WithUnsafeInt16Uint16Map(m map[int16]uint16) Int16Uint16ConcurrentMapOption {
	return func(cm *Int16Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Uint16Map(m map[int16]uint16) Int16Uint16ConcurrentMapOption {
	return func(cm *Int16Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Uint16ConcurrentMap(opts ...Int16Uint16ConcurrentMapOption) *Int16Uint16ConcurrentMap {
	cm := &Int16Uint16ConcurrentMap{
		m: make(map[int16]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Uint16MapKeyValue struct {
	Key   int16
	Value uint16
}

type Int16Uint16ConcurrentMap struct {
	m map[int16]uint16
	L *sync.RWMutex
}

func (cm *Int16Uint16ConcurrentMap) Get(k int16) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Uint16ConcurrentMap) GetDefault(k int16, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Uint16ConcurrentMap) GetOK(k int16) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Uint16ConcurrentMap) Set(k int16, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Uint16ConcurrentMap) Delete(k int16) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Uint16ConcurrentMap) SetKeyValues(kvs ...Int16Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Uint16ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Uint16ConcurrentMap) KeyValues() []Int16Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Uint16ConcurrentMap) ToUnsafeMap() map[int16]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16InterfaceKeyValue struct {
	Key   int16
	Value Interface
}

type Int16InterfaceConcurrentMapOption func(*Int16InterfaceConcurrentMap)

func WithUnsafeInt16InterfaceMap(m map[int16]Interface) Int16InterfaceConcurrentMapOption {
	return func(cm *Int16InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16InterfaceMap(m map[int16]Interface) Int16InterfaceConcurrentMapOption {
	return func(cm *Int16InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16InterfaceConcurrentMap(opts ...Int16InterfaceConcurrentMapOption) *Int16InterfaceConcurrentMap {
	cm := &Int16InterfaceConcurrentMap{
		m: make(map[int16]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16InterfaceMapKeyValue struct {
	Key   int16
	Value Interface
}

type Int16InterfaceConcurrentMap struct {
	m map[int16]Interface
	L *sync.RWMutex
}

func (cm *Int16InterfaceConcurrentMap) Get(k int16) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16InterfaceConcurrentMap) GetDefault(k int16, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16InterfaceConcurrentMap) GetOK(k int16) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16InterfaceConcurrentMap) Set(k int16, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16InterfaceConcurrentMap) Delete(k int16) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16InterfaceConcurrentMap) SetKeyValues(kvs ...Int16InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16InterfaceConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16InterfaceConcurrentMap) KeyValues() []Int16InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16InterfaceConcurrentMap) ToUnsafeMap() map[int16]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Uint32KeyValue struct {
	Key   int16
	Value uint32
}

type Int16Uint32ConcurrentMapOption func(*Int16Uint32ConcurrentMap)

func WithUnsafeInt16Uint32Map(m map[int16]uint32) Int16Uint32ConcurrentMapOption {
	return func(cm *Int16Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Uint32Map(m map[int16]uint32) Int16Uint32ConcurrentMapOption {
	return func(cm *Int16Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Uint32ConcurrentMap(opts ...Int16Uint32ConcurrentMapOption) *Int16Uint32ConcurrentMap {
	cm := &Int16Uint32ConcurrentMap{
		m: make(map[int16]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Uint32MapKeyValue struct {
	Key   int16
	Value uint32
}

type Int16Uint32ConcurrentMap struct {
	m map[int16]uint32
	L *sync.RWMutex
}

func (cm *Int16Uint32ConcurrentMap) Get(k int16) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Uint32ConcurrentMap) GetDefault(k int16, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Uint32ConcurrentMap) GetOK(k int16) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Uint32ConcurrentMap) Set(k int16, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Uint32ConcurrentMap) Delete(k int16) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Uint32ConcurrentMap) SetKeyValues(kvs ...Int16Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Uint32ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Uint32ConcurrentMap) KeyValues() []Int16Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Uint32ConcurrentMap) ToUnsafeMap() map[int16]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Uint64KeyValue struct {
	Key   int16
	Value uint64
}

type Int16Uint64ConcurrentMapOption func(*Int16Uint64ConcurrentMap)

func WithUnsafeInt16Uint64Map(m map[int16]uint64) Int16Uint64ConcurrentMapOption {
	return func(cm *Int16Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Uint64Map(m map[int16]uint64) Int16Uint64ConcurrentMapOption {
	return func(cm *Int16Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Uint64ConcurrentMap(opts ...Int16Uint64ConcurrentMapOption) *Int16Uint64ConcurrentMap {
	cm := &Int16Uint64ConcurrentMap{
		m: make(map[int16]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Uint64MapKeyValue struct {
	Key   int16
	Value uint64
}

type Int16Uint64ConcurrentMap struct {
	m map[int16]uint64
	L *sync.RWMutex
}

func (cm *Int16Uint64ConcurrentMap) Get(k int16) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Uint64ConcurrentMap) GetDefault(k int16, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Uint64ConcurrentMap) GetOK(k int16) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Uint64ConcurrentMap) Set(k int16, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Uint64ConcurrentMap) Delete(k int16) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Uint64ConcurrentMap) SetKeyValues(kvs ...Int16Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Uint64ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Uint64ConcurrentMap) KeyValues() []Int16Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Uint64ConcurrentMap) ToUnsafeMap() map[int16]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16IntKeyValue struct {
	Key   int16
	Value int
}

type Int16IntConcurrentMapOption func(*Int16IntConcurrentMap)

func WithUnsafeInt16IntMap(m map[int16]int) Int16IntConcurrentMapOption {
	return func(cm *Int16IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16IntMap(m map[int16]int) Int16IntConcurrentMapOption {
	return func(cm *Int16IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16IntConcurrentMap(opts ...Int16IntConcurrentMapOption) *Int16IntConcurrentMap {
	cm := &Int16IntConcurrentMap{
		m: make(map[int16]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16IntMapKeyValue struct {
	Key   int16
	Value int
}

type Int16IntConcurrentMap struct {
	m map[int16]int
	L *sync.RWMutex
}

func (cm *Int16IntConcurrentMap) Get(k int16) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16IntConcurrentMap) GetDefault(k int16, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16IntConcurrentMap) GetOK(k int16) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16IntConcurrentMap) Set(k int16, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16IntConcurrentMap) Delete(k int16) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16IntConcurrentMap) SetKeyValues(kvs ...Int16IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16IntConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16IntConcurrentMap) KeyValues() []Int16IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16IntConcurrentMap) ToUnsafeMap() map[int16]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Int8KeyValue struct {
	Key   int16
	Value int8
}

type Int16Int8ConcurrentMapOption func(*Int16Int8ConcurrentMap)

func WithUnsafeInt16Int8Map(m map[int16]int8) Int16Int8ConcurrentMapOption {
	return func(cm *Int16Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Int8Map(m map[int16]int8) Int16Int8ConcurrentMapOption {
	return func(cm *Int16Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Int8ConcurrentMap(opts ...Int16Int8ConcurrentMapOption) *Int16Int8ConcurrentMap {
	cm := &Int16Int8ConcurrentMap{
		m: make(map[int16]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Int8MapKeyValue struct {
	Key   int16
	Value int8
}

type Int16Int8ConcurrentMap struct {
	m map[int16]int8
	L *sync.RWMutex
}

func (cm *Int16Int8ConcurrentMap) Get(k int16) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Int8ConcurrentMap) GetDefault(k int16, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Int8ConcurrentMap) GetOK(k int16) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Int8ConcurrentMap) Set(k int16, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Int8ConcurrentMap) Delete(k int16) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Int8ConcurrentMap) SetKeyValues(kvs ...Int16Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Int8ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Int8ConcurrentMap) KeyValues() []Int16Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Int8ConcurrentMap) ToUnsafeMap() map[int16]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Int16KeyValue struct {
	Key   int16
	Value int16
}

type Int16Int16ConcurrentMapOption func(*Int16Int16ConcurrentMap)

func WithUnsafeInt16Int16Map(m map[int16]int16) Int16Int16ConcurrentMapOption {
	return func(cm *Int16Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Int16Map(m map[int16]int16) Int16Int16ConcurrentMapOption {
	return func(cm *Int16Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Int16ConcurrentMap(opts ...Int16Int16ConcurrentMapOption) *Int16Int16ConcurrentMap {
	cm := &Int16Int16ConcurrentMap{
		m: make(map[int16]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Int16MapKeyValue struct {
	Key   int16
	Value int16
}

type Int16Int16ConcurrentMap struct {
	m map[int16]int16
	L *sync.RWMutex
}

func (cm *Int16Int16ConcurrentMap) Get(k int16) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Int16ConcurrentMap) GetDefault(k int16, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Int16ConcurrentMap) GetOK(k int16) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Int16ConcurrentMap) Set(k int16, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Int16ConcurrentMap) Delete(k int16) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Int16ConcurrentMap) SetKeyValues(kvs ...Int16Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Int16ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Int16ConcurrentMap) KeyValues() []Int16Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Int16ConcurrentMap) ToUnsafeMap() map[int16]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Int32KeyValue struct {
	Key   int16
	Value int32
}

type Int16Int32ConcurrentMapOption func(*Int16Int32ConcurrentMap)

func WithUnsafeInt16Int32Map(m map[int16]int32) Int16Int32ConcurrentMapOption {
	return func(cm *Int16Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Int32Map(m map[int16]int32) Int16Int32ConcurrentMapOption {
	return func(cm *Int16Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Int32ConcurrentMap(opts ...Int16Int32ConcurrentMapOption) *Int16Int32ConcurrentMap {
	cm := &Int16Int32ConcurrentMap{
		m: make(map[int16]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Int32MapKeyValue struct {
	Key   int16
	Value int32
}

type Int16Int32ConcurrentMap struct {
	m map[int16]int32
	L *sync.RWMutex
}

func (cm *Int16Int32ConcurrentMap) Get(k int16) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Int32ConcurrentMap) GetDefault(k int16, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Int32ConcurrentMap) GetOK(k int16) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Int32ConcurrentMap) Set(k int16, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Int32ConcurrentMap) Delete(k int16) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Int32ConcurrentMap) SetKeyValues(kvs ...Int16Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Int32ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Int32ConcurrentMap) KeyValues() []Int16Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Int32ConcurrentMap) ToUnsafeMap() map[int16]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Int64KeyValue struct {
	Key   int16
	Value int64
}

type Int16Int64ConcurrentMapOption func(*Int16Int64ConcurrentMap)

func WithUnsafeInt16Int64Map(m map[int16]int64) Int16Int64ConcurrentMapOption {
	return func(cm *Int16Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Int64Map(m map[int16]int64) Int16Int64ConcurrentMapOption {
	return func(cm *Int16Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Int64ConcurrentMap(opts ...Int16Int64ConcurrentMapOption) *Int16Int64ConcurrentMap {
	cm := &Int16Int64ConcurrentMap{
		m: make(map[int16]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Int64MapKeyValue struct {
	Key   int16
	Value int64
}

type Int16Int64ConcurrentMap struct {
	m map[int16]int64
	L *sync.RWMutex
}

func (cm *Int16Int64ConcurrentMap) Get(k int16) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Int64ConcurrentMap) GetDefault(k int16, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Int64ConcurrentMap) GetOK(k int16) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Int64ConcurrentMap) Set(k int16, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Int64ConcurrentMap) Delete(k int16) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Int64ConcurrentMap) SetKeyValues(kvs ...Int16Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Int64ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Int64ConcurrentMap) KeyValues() []Int16Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Int64ConcurrentMap) ToUnsafeMap() map[int16]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Float32KeyValue struct {
	Key   int16
	Value float32
}

type Int16Float32ConcurrentMapOption func(*Int16Float32ConcurrentMap)

func WithUnsafeInt16Float32Map(m map[int16]float32) Int16Float32ConcurrentMapOption {
	return func(cm *Int16Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Float32Map(m map[int16]float32) Int16Float32ConcurrentMapOption {
	return func(cm *Int16Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Float32ConcurrentMap(opts ...Int16Float32ConcurrentMapOption) *Int16Float32ConcurrentMap {
	cm := &Int16Float32ConcurrentMap{
		m: make(map[int16]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Float32MapKeyValue struct {
	Key   int16
	Value float32
}

type Int16Float32ConcurrentMap struct {
	m map[int16]float32
	L *sync.RWMutex
}

func (cm *Int16Float32ConcurrentMap) Get(k int16) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Float32ConcurrentMap) GetDefault(k int16, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Float32ConcurrentMap) GetOK(k int16) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Float32ConcurrentMap) Set(k int16, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Float32ConcurrentMap) Delete(k int16) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Float32ConcurrentMap) SetKeyValues(kvs ...Int16Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Float32ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Float32ConcurrentMap) KeyValues() []Int16Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Float32ConcurrentMap) ToUnsafeMap() map[int16]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16Float64KeyValue struct {
	Key   int16
	Value float64
}

type Int16Float64ConcurrentMapOption func(*Int16Float64ConcurrentMap)

func WithUnsafeInt16Float64Map(m map[int16]float64) Int16Float64ConcurrentMapOption {
	return func(cm *Int16Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16Float64Map(m map[int16]float64) Int16Float64ConcurrentMapOption {
	return func(cm *Int16Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16Float64ConcurrentMap(opts ...Int16Float64ConcurrentMapOption) *Int16Float64ConcurrentMap {
	cm := &Int16Float64ConcurrentMap{
		m: make(map[int16]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16Float64MapKeyValue struct {
	Key   int16
	Value float64
}

type Int16Float64ConcurrentMap struct {
	m map[int16]float64
	L *sync.RWMutex
}

func (cm *Int16Float64ConcurrentMap) Get(k int16) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16Float64ConcurrentMap) GetDefault(k int16, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16Float64ConcurrentMap) GetOK(k int16) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16Float64ConcurrentMap) Set(k int16, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16Float64ConcurrentMap) Delete(k int16) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16Float64ConcurrentMap) SetKeyValues(kvs ...Int16Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16Float64ConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16Float64ConcurrentMap) KeyValues() []Int16Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16Float64ConcurrentMap) ToUnsafeMap() map[int16]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16TypeKeyValue struct {
	Key   int16
	Value Type
}

type Int16TypeConcurrentMapOption func(*Int16TypeConcurrentMap)

func WithUnsafeInt16TypeMap(m map[int16]Type) Int16TypeConcurrentMapOption {
	return func(cm *Int16TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16TypeMap(m map[int16]Type) Int16TypeConcurrentMapOption {
	return func(cm *Int16TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16TypeConcurrentMap(opts ...Int16TypeConcurrentMapOption) *Int16TypeConcurrentMap {
	cm := &Int16TypeConcurrentMap{
		m: make(map[int16]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16TypeMapKeyValue struct {
	Key   int16
	Value Type
}

type Int16TypeConcurrentMap struct {
	m map[int16]Type
	L *sync.RWMutex
}

func (cm *Int16TypeConcurrentMap) Get(k int16) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16TypeConcurrentMap) GetDefault(k int16, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16TypeConcurrentMap) GetOK(k int16) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16TypeConcurrentMap) Set(k int16, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16TypeConcurrentMap) Delete(k int16) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16TypeConcurrentMap) SetKeyValues(kvs ...Int16TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16TypeConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16TypeConcurrentMap) KeyValues() []Int16TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16TypeConcurrentMap) ToUnsafeMap() map[int16]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16BoolKeyValue struct {
	Key   int16
	Value bool
}

type Int16BoolConcurrentMapOption func(*Int16BoolConcurrentMap)

func WithUnsafeInt16BoolMap(m map[int16]bool) Int16BoolConcurrentMapOption {
	return func(cm *Int16BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16BoolMap(m map[int16]bool) Int16BoolConcurrentMapOption {
	return func(cm *Int16BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16BoolConcurrentMap(opts ...Int16BoolConcurrentMapOption) *Int16BoolConcurrentMap {
	cm := &Int16BoolConcurrentMap{
		m: make(map[int16]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16BoolMapKeyValue struct {
	Key   int16
	Value bool
}

type Int16BoolConcurrentMap struct {
	m map[int16]bool
	L *sync.RWMutex
}

func (cm *Int16BoolConcurrentMap) Get(k int16) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16BoolConcurrentMap) GetDefault(k int16, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16BoolConcurrentMap) GetOK(k int16) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16BoolConcurrentMap) Set(k int16, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16BoolConcurrentMap) Delete(k int16) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16BoolConcurrentMap) SetKeyValues(kvs ...Int16BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16BoolConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16BoolConcurrentMap) KeyValues() []Int16BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16BoolConcurrentMap) ToUnsafeMap() map[int16]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int16StringKeyValue struct {
	Key   int16
	Value string
}

type Int16StringConcurrentMapOption func(*Int16StringConcurrentMap)

func WithUnsafeInt16StringMap(m map[int16]string) Int16StringConcurrentMapOption {
	return func(cm *Int16StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt16StringMap(m map[int16]string) Int16StringConcurrentMapOption {
	return func(cm *Int16StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt16StringConcurrentMap(opts ...Int16StringConcurrentMapOption) *Int16StringConcurrentMap {
	cm := &Int16StringConcurrentMap{
		m: make(map[int16]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int16StringMapKeyValue struct {
	Key   int16
	Value string
}

type Int16StringConcurrentMap struct {
	m map[int16]string
	L *sync.RWMutex
}

func (cm *Int16StringConcurrentMap) Get(k int16) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int16StringConcurrentMap) GetDefault(k int16, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int16StringConcurrentMap) GetOK(k int16) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int16StringConcurrentMap) Set(k int16, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int16StringConcurrentMap) Delete(k int16) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int16StringConcurrentMap) SetKeyValues(kvs ...Int16StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int16StringConcurrentMap) Keys() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int16
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int16StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int16StringConcurrentMap) KeyValues() []Int16StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int16StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int16StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int16StringConcurrentMap) ToUnsafeMap() map[int16]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int16]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32ByteKeyValue struct {
	Key   int32
	Value byte
}

type Int32ByteConcurrentMapOption func(*Int32ByteConcurrentMap)

func WithUnsafeInt32ByteMap(m map[int32]byte) Int32ByteConcurrentMapOption {
	return func(cm *Int32ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32ByteMap(m map[int32]byte) Int32ByteConcurrentMapOption {
	return func(cm *Int32ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32ByteConcurrentMap(opts ...Int32ByteConcurrentMapOption) *Int32ByteConcurrentMap {
	cm := &Int32ByteConcurrentMap{
		m: make(map[int32]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32ByteMapKeyValue struct {
	Key   int32
	Value byte
}

type Int32ByteConcurrentMap struct {
	m map[int32]byte
	L *sync.RWMutex
}

func (cm *Int32ByteConcurrentMap) Get(k int32) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32ByteConcurrentMap) GetDefault(k int32, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32ByteConcurrentMap) GetOK(k int32) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32ByteConcurrentMap) Set(k int32, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32ByteConcurrentMap) Delete(k int32) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32ByteConcurrentMap) SetKeyValues(kvs ...Int32ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32ByteConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32ByteConcurrentMap) KeyValues() []Int32ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32ByteConcurrentMap) ToUnsafeMap() map[int32]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32RuneKeyValue struct {
	Key   int32
	Value rune
}

type Int32RuneConcurrentMapOption func(*Int32RuneConcurrentMap)

func WithUnsafeInt32RuneMap(m map[int32]rune) Int32RuneConcurrentMapOption {
	return func(cm *Int32RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32RuneMap(m map[int32]rune) Int32RuneConcurrentMapOption {
	return func(cm *Int32RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32RuneConcurrentMap(opts ...Int32RuneConcurrentMapOption) *Int32RuneConcurrentMap {
	cm := &Int32RuneConcurrentMap{
		m: make(map[int32]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32RuneMapKeyValue struct {
	Key   int32
	Value rune
}

type Int32RuneConcurrentMap struct {
	m map[int32]rune
	L *sync.RWMutex
}

func (cm *Int32RuneConcurrentMap) Get(k int32) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32RuneConcurrentMap) GetDefault(k int32, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32RuneConcurrentMap) GetOK(k int32) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32RuneConcurrentMap) Set(k int32, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32RuneConcurrentMap) Delete(k int32) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32RuneConcurrentMap) SetKeyValues(kvs ...Int32RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32RuneConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32RuneConcurrentMap) KeyValues() []Int32RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32RuneConcurrentMap) ToUnsafeMap() map[int32]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32UintKeyValue struct {
	Key   int32
	Value uint
}

type Int32UintConcurrentMapOption func(*Int32UintConcurrentMap)

func WithUnsafeInt32UintMap(m map[int32]uint) Int32UintConcurrentMapOption {
	return func(cm *Int32UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32UintMap(m map[int32]uint) Int32UintConcurrentMapOption {
	return func(cm *Int32UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32UintConcurrentMap(opts ...Int32UintConcurrentMapOption) *Int32UintConcurrentMap {
	cm := &Int32UintConcurrentMap{
		m: make(map[int32]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32UintMapKeyValue struct {
	Key   int32
	Value uint
}

type Int32UintConcurrentMap struct {
	m map[int32]uint
	L *sync.RWMutex
}

func (cm *Int32UintConcurrentMap) Get(k int32) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32UintConcurrentMap) GetDefault(k int32, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32UintConcurrentMap) GetOK(k int32) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32UintConcurrentMap) Set(k int32, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32UintConcurrentMap) Delete(k int32) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32UintConcurrentMap) SetKeyValues(kvs ...Int32UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32UintConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32UintConcurrentMap) KeyValues() []Int32UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32UintConcurrentMap) ToUnsafeMap() map[int32]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Uint8KeyValue struct {
	Key   int32
	Value uint8
}

type Int32Uint8ConcurrentMapOption func(*Int32Uint8ConcurrentMap)

func WithUnsafeInt32Uint8Map(m map[int32]uint8) Int32Uint8ConcurrentMapOption {
	return func(cm *Int32Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Uint8Map(m map[int32]uint8) Int32Uint8ConcurrentMapOption {
	return func(cm *Int32Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Uint8ConcurrentMap(opts ...Int32Uint8ConcurrentMapOption) *Int32Uint8ConcurrentMap {
	cm := &Int32Uint8ConcurrentMap{
		m: make(map[int32]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Uint8MapKeyValue struct {
	Key   int32
	Value uint8
}

type Int32Uint8ConcurrentMap struct {
	m map[int32]uint8
	L *sync.RWMutex
}

func (cm *Int32Uint8ConcurrentMap) Get(k int32) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Uint8ConcurrentMap) GetDefault(k int32, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Uint8ConcurrentMap) GetOK(k int32) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Uint8ConcurrentMap) Set(k int32, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Uint8ConcurrentMap) Delete(k int32) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Uint8ConcurrentMap) SetKeyValues(kvs ...Int32Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Uint8ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Uint8ConcurrentMap) KeyValues() []Int32Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Uint8ConcurrentMap) ToUnsafeMap() map[int32]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Uint16KeyValue struct {
	Key   int32
	Value uint16
}

type Int32Uint16ConcurrentMapOption func(*Int32Uint16ConcurrentMap)

func WithUnsafeInt32Uint16Map(m map[int32]uint16) Int32Uint16ConcurrentMapOption {
	return func(cm *Int32Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Uint16Map(m map[int32]uint16) Int32Uint16ConcurrentMapOption {
	return func(cm *Int32Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Uint16ConcurrentMap(opts ...Int32Uint16ConcurrentMapOption) *Int32Uint16ConcurrentMap {
	cm := &Int32Uint16ConcurrentMap{
		m: make(map[int32]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Uint16MapKeyValue struct {
	Key   int32
	Value uint16
}

type Int32Uint16ConcurrentMap struct {
	m map[int32]uint16
	L *sync.RWMutex
}

func (cm *Int32Uint16ConcurrentMap) Get(k int32) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Uint16ConcurrentMap) GetDefault(k int32, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Uint16ConcurrentMap) GetOK(k int32) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Uint16ConcurrentMap) Set(k int32, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Uint16ConcurrentMap) Delete(k int32) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Uint16ConcurrentMap) SetKeyValues(kvs ...Int32Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Uint16ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Uint16ConcurrentMap) KeyValues() []Int32Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Uint16ConcurrentMap) ToUnsafeMap() map[int32]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32InterfaceKeyValue struct {
	Key   int32
	Value Interface
}

type Int32InterfaceConcurrentMapOption func(*Int32InterfaceConcurrentMap)

func WithUnsafeInt32InterfaceMap(m map[int32]Interface) Int32InterfaceConcurrentMapOption {
	return func(cm *Int32InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32InterfaceMap(m map[int32]Interface) Int32InterfaceConcurrentMapOption {
	return func(cm *Int32InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32InterfaceConcurrentMap(opts ...Int32InterfaceConcurrentMapOption) *Int32InterfaceConcurrentMap {
	cm := &Int32InterfaceConcurrentMap{
		m: make(map[int32]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32InterfaceMapKeyValue struct {
	Key   int32
	Value Interface
}

type Int32InterfaceConcurrentMap struct {
	m map[int32]Interface
	L *sync.RWMutex
}

func (cm *Int32InterfaceConcurrentMap) Get(k int32) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32InterfaceConcurrentMap) GetDefault(k int32, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32InterfaceConcurrentMap) GetOK(k int32) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32InterfaceConcurrentMap) Set(k int32, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32InterfaceConcurrentMap) Delete(k int32) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32InterfaceConcurrentMap) SetKeyValues(kvs ...Int32InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32InterfaceConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32InterfaceConcurrentMap) KeyValues() []Int32InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32InterfaceConcurrentMap) ToUnsafeMap() map[int32]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Uint32KeyValue struct {
	Key   int32
	Value uint32
}

type Int32Uint32ConcurrentMapOption func(*Int32Uint32ConcurrentMap)

func WithUnsafeInt32Uint32Map(m map[int32]uint32) Int32Uint32ConcurrentMapOption {
	return func(cm *Int32Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Uint32Map(m map[int32]uint32) Int32Uint32ConcurrentMapOption {
	return func(cm *Int32Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Uint32ConcurrentMap(opts ...Int32Uint32ConcurrentMapOption) *Int32Uint32ConcurrentMap {
	cm := &Int32Uint32ConcurrentMap{
		m: make(map[int32]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Uint32MapKeyValue struct {
	Key   int32
	Value uint32
}

type Int32Uint32ConcurrentMap struct {
	m map[int32]uint32
	L *sync.RWMutex
}

func (cm *Int32Uint32ConcurrentMap) Get(k int32) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Uint32ConcurrentMap) GetDefault(k int32, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Uint32ConcurrentMap) GetOK(k int32) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Uint32ConcurrentMap) Set(k int32, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Uint32ConcurrentMap) Delete(k int32) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Uint32ConcurrentMap) SetKeyValues(kvs ...Int32Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Uint32ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Uint32ConcurrentMap) KeyValues() []Int32Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Uint32ConcurrentMap) ToUnsafeMap() map[int32]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Uint64KeyValue struct {
	Key   int32
	Value uint64
}

type Int32Uint64ConcurrentMapOption func(*Int32Uint64ConcurrentMap)

func WithUnsafeInt32Uint64Map(m map[int32]uint64) Int32Uint64ConcurrentMapOption {
	return func(cm *Int32Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Uint64Map(m map[int32]uint64) Int32Uint64ConcurrentMapOption {
	return func(cm *Int32Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Uint64ConcurrentMap(opts ...Int32Uint64ConcurrentMapOption) *Int32Uint64ConcurrentMap {
	cm := &Int32Uint64ConcurrentMap{
		m: make(map[int32]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Uint64MapKeyValue struct {
	Key   int32
	Value uint64
}

type Int32Uint64ConcurrentMap struct {
	m map[int32]uint64
	L *sync.RWMutex
}

func (cm *Int32Uint64ConcurrentMap) Get(k int32) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Uint64ConcurrentMap) GetDefault(k int32, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Uint64ConcurrentMap) GetOK(k int32) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Uint64ConcurrentMap) Set(k int32, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Uint64ConcurrentMap) Delete(k int32) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Uint64ConcurrentMap) SetKeyValues(kvs ...Int32Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Uint64ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Uint64ConcurrentMap) KeyValues() []Int32Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Uint64ConcurrentMap) ToUnsafeMap() map[int32]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32IntKeyValue struct {
	Key   int32
	Value int
}

type Int32IntConcurrentMapOption func(*Int32IntConcurrentMap)

func WithUnsafeInt32IntMap(m map[int32]int) Int32IntConcurrentMapOption {
	return func(cm *Int32IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32IntMap(m map[int32]int) Int32IntConcurrentMapOption {
	return func(cm *Int32IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32IntConcurrentMap(opts ...Int32IntConcurrentMapOption) *Int32IntConcurrentMap {
	cm := &Int32IntConcurrentMap{
		m: make(map[int32]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32IntMapKeyValue struct {
	Key   int32
	Value int
}

type Int32IntConcurrentMap struct {
	m map[int32]int
	L *sync.RWMutex
}

func (cm *Int32IntConcurrentMap) Get(k int32) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32IntConcurrentMap) GetDefault(k int32, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32IntConcurrentMap) GetOK(k int32) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32IntConcurrentMap) Set(k int32, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32IntConcurrentMap) Delete(k int32) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32IntConcurrentMap) SetKeyValues(kvs ...Int32IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32IntConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32IntConcurrentMap) KeyValues() []Int32IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32IntConcurrentMap) ToUnsafeMap() map[int32]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Int8KeyValue struct {
	Key   int32
	Value int8
}

type Int32Int8ConcurrentMapOption func(*Int32Int8ConcurrentMap)

func WithUnsafeInt32Int8Map(m map[int32]int8) Int32Int8ConcurrentMapOption {
	return func(cm *Int32Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Int8Map(m map[int32]int8) Int32Int8ConcurrentMapOption {
	return func(cm *Int32Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Int8ConcurrentMap(opts ...Int32Int8ConcurrentMapOption) *Int32Int8ConcurrentMap {
	cm := &Int32Int8ConcurrentMap{
		m: make(map[int32]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Int8MapKeyValue struct {
	Key   int32
	Value int8
}

type Int32Int8ConcurrentMap struct {
	m map[int32]int8
	L *sync.RWMutex
}

func (cm *Int32Int8ConcurrentMap) Get(k int32) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Int8ConcurrentMap) GetDefault(k int32, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Int8ConcurrentMap) GetOK(k int32) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Int8ConcurrentMap) Set(k int32, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Int8ConcurrentMap) Delete(k int32) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Int8ConcurrentMap) SetKeyValues(kvs ...Int32Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Int8ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Int8ConcurrentMap) KeyValues() []Int32Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Int8ConcurrentMap) ToUnsafeMap() map[int32]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Int16KeyValue struct {
	Key   int32
	Value int16
}

type Int32Int16ConcurrentMapOption func(*Int32Int16ConcurrentMap)

func WithUnsafeInt32Int16Map(m map[int32]int16) Int32Int16ConcurrentMapOption {
	return func(cm *Int32Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Int16Map(m map[int32]int16) Int32Int16ConcurrentMapOption {
	return func(cm *Int32Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Int16ConcurrentMap(opts ...Int32Int16ConcurrentMapOption) *Int32Int16ConcurrentMap {
	cm := &Int32Int16ConcurrentMap{
		m: make(map[int32]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Int16MapKeyValue struct {
	Key   int32
	Value int16
}

type Int32Int16ConcurrentMap struct {
	m map[int32]int16
	L *sync.RWMutex
}

func (cm *Int32Int16ConcurrentMap) Get(k int32) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Int16ConcurrentMap) GetDefault(k int32, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Int16ConcurrentMap) GetOK(k int32) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Int16ConcurrentMap) Set(k int32, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Int16ConcurrentMap) Delete(k int32) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Int16ConcurrentMap) SetKeyValues(kvs ...Int32Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Int16ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Int16ConcurrentMap) KeyValues() []Int32Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Int16ConcurrentMap) ToUnsafeMap() map[int32]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Int32KeyValue struct {
	Key   int32
	Value int32
}

type Int32Int32ConcurrentMapOption func(*Int32Int32ConcurrentMap)

func WithUnsafeInt32Int32Map(m map[int32]int32) Int32Int32ConcurrentMapOption {
	return func(cm *Int32Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Int32Map(m map[int32]int32) Int32Int32ConcurrentMapOption {
	return func(cm *Int32Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Int32ConcurrentMap(opts ...Int32Int32ConcurrentMapOption) *Int32Int32ConcurrentMap {
	cm := &Int32Int32ConcurrentMap{
		m: make(map[int32]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Int32MapKeyValue struct {
	Key   int32
	Value int32
}

type Int32Int32ConcurrentMap struct {
	m map[int32]int32
	L *sync.RWMutex
}

func (cm *Int32Int32ConcurrentMap) Get(k int32) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Int32ConcurrentMap) GetDefault(k int32, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Int32ConcurrentMap) GetOK(k int32) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Int32ConcurrentMap) Set(k int32, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Int32ConcurrentMap) Delete(k int32) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Int32ConcurrentMap) SetKeyValues(kvs ...Int32Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Int32ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Int32ConcurrentMap) KeyValues() []Int32Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Int32ConcurrentMap) ToUnsafeMap() map[int32]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Int64KeyValue struct {
	Key   int32
	Value int64
}

type Int32Int64ConcurrentMapOption func(*Int32Int64ConcurrentMap)

func WithUnsafeInt32Int64Map(m map[int32]int64) Int32Int64ConcurrentMapOption {
	return func(cm *Int32Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Int64Map(m map[int32]int64) Int32Int64ConcurrentMapOption {
	return func(cm *Int32Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Int64ConcurrentMap(opts ...Int32Int64ConcurrentMapOption) *Int32Int64ConcurrentMap {
	cm := &Int32Int64ConcurrentMap{
		m: make(map[int32]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Int64MapKeyValue struct {
	Key   int32
	Value int64
}

type Int32Int64ConcurrentMap struct {
	m map[int32]int64
	L *sync.RWMutex
}

func (cm *Int32Int64ConcurrentMap) Get(k int32) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Int64ConcurrentMap) GetDefault(k int32, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Int64ConcurrentMap) GetOK(k int32) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Int64ConcurrentMap) Set(k int32, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Int64ConcurrentMap) Delete(k int32) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Int64ConcurrentMap) SetKeyValues(kvs ...Int32Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Int64ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Int64ConcurrentMap) KeyValues() []Int32Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Int64ConcurrentMap) ToUnsafeMap() map[int32]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Float32KeyValue struct {
	Key   int32
	Value float32
}

type Int32Float32ConcurrentMapOption func(*Int32Float32ConcurrentMap)

func WithUnsafeInt32Float32Map(m map[int32]float32) Int32Float32ConcurrentMapOption {
	return func(cm *Int32Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Float32Map(m map[int32]float32) Int32Float32ConcurrentMapOption {
	return func(cm *Int32Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Float32ConcurrentMap(opts ...Int32Float32ConcurrentMapOption) *Int32Float32ConcurrentMap {
	cm := &Int32Float32ConcurrentMap{
		m: make(map[int32]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Float32MapKeyValue struct {
	Key   int32
	Value float32
}

type Int32Float32ConcurrentMap struct {
	m map[int32]float32
	L *sync.RWMutex
}

func (cm *Int32Float32ConcurrentMap) Get(k int32) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Float32ConcurrentMap) GetDefault(k int32, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Float32ConcurrentMap) GetOK(k int32) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Float32ConcurrentMap) Set(k int32, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Float32ConcurrentMap) Delete(k int32) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Float32ConcurrentMap) SetKeyValues(kvs ...Int32Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Float32ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Float32ConcurrentMap) KeyValues() []Int32Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Float32ConcurrentMap) ToUnsafeMap() map[int32]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32Float64KeyValue struct {
	Key   int32
	Value float64
}

type Int32Float64ConcurrentMapOption func(*Int32Float64ConcurrentMap)

func WithUnsafeInt32Float64Map(m map[int32]float64) Int32Float64ConcurrentMapOption {
	return func(cm *Int32Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32Float64Map(m map[int32]float64) Int32Float64ConcurrentMapOption {
	return func(cm *Int32Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32Float64ConcurrentMap(opts ...Int32Float64ConcurrentMapOption) *Int32Float64ConcurrentMap {
	cm := &Int32Float64ConcurrentMap{
		m: make(map[int32]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32Float64MapKeyValue struct {
	Key   int32
	Value float64
}

type Int32Float64ConcurrentMap struct {
	m map[int32]float64
	L *sync.RWMutex
}

func (cm *Int32Float64ConcurrentMap) Get(k int32) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32Float64ConcurrentMap) GetDefault(k int32, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32Float64ConcurrentMap) GetOK(k int32) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32Float64ConcurrentMap) Set(k int32, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32Float64ConcurrentMap) Delete(k int32) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32Float64ConcurrentMap) SetKeyValues(kvs ...Int32Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32Float64ConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32Float64ConcurrentMap) KeyValues() []Int32Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32Float64ConcurrentMap) ToUnsafeMap() map[int32]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32TypeKeyValue struct {
	Key   int32
	Value Type
}

type Int32TypeConcurrentMapOption func(*Int32TypeConcurrentMap)

func WithUnsafeInt32TypeMap(m map[int32]Type) Int32TypeConcurrentMapOption {
	return func(cm *Int32TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32TypeMap(m map[int32]Type) Int32TypeConcurrentMapOption {
	return func(cm *Int32TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32TypeConcurrentMap(opts ...Int32TypeConcurrentMapOption) *Int32TypeConcurrentMap {
	cm := &Int32TypeConcurrentMap{
		m: make(map[int32]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32TypeMapKeyValue struct {
	Key   int32
	Value Type
}

type Int32TypeConcurrentMap struct {
	m map[int32]Type
	L *sync.RWMutex
}

func (cm *Int32TypeConcurrentMap) Get(k int32) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32TypeConcurrentMap) GetDefault(k int32, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32TypeConcurrentMap) GetOK(k int32) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32TypeConcurrentMap) Set(k int32, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32TypeConcurrentMap) Delete(k int32) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32TypeConcurrentMap) SetKeyValues(kvs ...Int32TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32TypeConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32TypeConcurrentMap) KeyValues() []Int32TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32TypeConcurrentMap) ToUnsafeMap() map[int32]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32BoolKeyValue struct {
	Key   int32
	Value bool
}

type Int32BoolConcurrentMapOption func(*Int32BoolConcurrentMap)

func WithUnsafeInt32BoolMap(m map[int32]bool) Int32BoolConcurrentMapOption {
	return func(cm *Int32BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32BoolMap(m map[int32]bool) Int32BoolConcurrentMapOption {
	return func(cm *Int32BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32BoolConcurrentMap(opts ...Int32BoolConcurrentMapOption) *Int32BoolConcurrentMap {
	cm := &Int32BoolConcurrentMap{
		m: make(map[int32]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32BoolMapKeyValue struct {
	Key   int32
	Value bool
}

type Int32BoolConcurrentMap struct {
	m map[int32]bool
	L *sync.RWMutex
}

func (cm *Int32BoolConcurrentMap) Get(k int32) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32BoolConcurrentMap) GetDefault(k int32, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32BoolConcurrentMap) GetOK(k int32) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32BoolConcurrentMap) Set(k int32, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32BoolConcurrentMap) Delete(k int32) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32BoolConcurrentMap) SetKeyValues(kvs ...Int32BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32BoolConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32BoolConcurrentMap) KeyValues() []Int32BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32BoolConcurrentMap) ToUnsafeMap() map[int32]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int32StringKeyValue struct {
	Key   int32
	Value string
}

type Int32StringConcurrentMapOption func(*Int32StringConcurrentMap)

func WithUnsafeInt32StringMap(m map[int32]string) Int32StringConcurrentMapOption {
	return func(cm *Int32StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt32StringMap(m map[int32]string) Int32StringConcurrentMapOption {
	return func(cm *Int32StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt32StringConcurrentMap(opts ...Int32StringConcurrentMapOption) *Int32StringConcurrentMap {
	cm := &Int32StringConcurrentMap{
		m: make(map[int32]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int32StringMapKeyValue struct {
	Key   int32
	Value string
}

type Int32StringConcurrentMap struct {
	m map[int32]string
	L *sync.RWMutex
}

func (cm *Int32StringConcurrentMap) Get(k int32) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int32StringConcurrentMap) GetDefault(k int32, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int32StringConcurrentMap) GetOK(k int32) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int32StringConcurrentMap) Set(k int32, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int32StringConcurrentMap) Delete(k int32) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int32StringConcurrentMap) SetKeyValues(kvs ...Int32StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int32StringConcurrentMap) Keys() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int32StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int32StringConcurrentMap) KeyValues() []Int32StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int32StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int32StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int32StringConcurrentMap) ToUnsafeMap() map[int32]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int32]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64ByteKeyValue struct {
	Key   int64
	Value byte
}

type Int64ByteConcurrentMapOption func(*Int64ByteConcurrentMap)

func WithUnsafeInt64ByteMap(m map[int64]byte) Int64ByteConcurrentMapOption {
	return func(cm *Int64ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64ByteMap(m map[int64]byte) Int64ByteConcurrentMapOption {
	return func(cm *Int64ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64ByteConcurrentMap(opts ...Int64ByteConcurrentMapOption) *Int64ByteConcurrentMap {
	cm := &Int64ByteConcurrentMap{
		m: make(map[int64]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64ByteMapKeyValue struct {
	Key   int64
	Value byte
}

type Int64ByteConcurrentMap struct {
	m map[int64]byte
	L *sync.RWMutex
}

func (cm *Int64ByteConcurrentMap) Get(k int64) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64ByteConcurrentMap) GetDefault(k int64, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64ByteConcurrentMap) GetOK(k int64) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64ByteConcurrentMap) Set(k int64, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64ByteConcurrentMap) Delete(k int64) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64ByteConcurrentMap) SetKeyValues(kvs ...Int64ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64ByteConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64ByteConcurrentMap) KeyValues() []Int64ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64ByteConcurrentMap) ToUnsafeMap() map[int64]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64RuneKeyValue struct {
	Key   int64
	Value rune
}

type Int64RuneConcurrentMapOption func(*Int64RuneConcurrentMap)

func WithUnsafeInt64RuneMap(m map[int64]rune) Int64RuneConcurrentMapOption {
	return func(cm *Int64RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64RuneMap(m map[int64]rune) Int64RuneConcurrentMapOption {
	return func(cm *Int64RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64RuneConcurrentMap(opts ...Int64RuneConcurrentMapOption) *Int64RuneConcurrentMap {
	cm := &Int64RuneConcurrentMap{
		m: make(map[int64]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64RuneMapKeyValue struct {
	Key   int64
	Value rune
}

type Int64RuneConcurrentMap struct {
	m map[int64]rune
	L *sync.RWMutex
}

func (cm *Int64RuneConcurrentMap) Get(k int64) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64RuneConcurrentMap) GetDefault(k int64, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64RuneConcurrentMap) GetOK(k int64) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64RuneConcurrentMap) Set(k int64, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64RuneConcurrentMap) Delete(k int64) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64RuneConcurrentMap) SetKeyValues(kvs ...Int64RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64RuneConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64RuneConcurrentMap) KeyValues() []Int64RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64RuneConcurrentMap) ToUnsafeMap() map[int64]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64UintKeyValue struct {
	Key   int64
	Value uint
}

type Int64UintConcurrentMapOption func(*Int64UintConcurrentMap)

func WithUnsafeInt64UintMap(m map[int64]uint) Int64UintConcurrentMapOption {
	return func(cm *Int64UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64UintMap(m map[int64]uint) Int64UintConcurrentMapOption {
	return func(cm *Int64UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64UintConcurrentMap(opts ...Int64UintConcurrentMapOption) *Int64UintConcurrentMap {
	cm := &Int64UintConcurrentMap{
		m: make(map[int64]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64UintMapKeyValue struct {
	Key   int64
	Value uint
}

type Int64UintConcurrentMap struct {
	m map[int64]uint
	L *sync.RWMutex
}

func (cm *Int64UintConcurrentMap) Get(k int64) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64UintConcurrentMap) GetDefault(k int64, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64UintConcurrentMap) GetOK(k int64) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64UintConcurrentMap) Set(k int64, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64UintConcurrentMap) Delete(k int64) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64UintConcurrentMap) SetKeyValues(kvs ...Int64UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64UintConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64UintConcurrentMap) KeyValues() []Int64UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64UintConcurrentMap) ToUnsafeMap() map[int64]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Uint8KeyValue struct {
	Key   int64
	Value uint8
}

type Int64Uint8ConcurrentMapOption func(*Int64Uint8ConcurrentMap)

func WithUnsafeInt64Uint8Map(m map[int64]uint8) Int64Uint8ConcurrentMapOption {
	return func(cm *Int64Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Uint8Map(m map[int64]uint8) Int64Uint8ConcurrentMapOption {
	return func(cm *Int64Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Uint8ConcurrentMap(opts ...Int64Uint8ConcurrentMapOption) *Int64Uint8ConcurrentMap {
	cm := &Int64Uint8ConcurrentMap{
		m: make(map[int64]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Uint8MapKeyValue struct {
	Key   int64
	Value uint8
}

type Int64Uint8ConcurrentMap struct {
	m map[int64]uint8
	L *sync.RWMutex
}

func (cm *Int64Uint8ConcurrentMap) Get(k int64) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Uint8ConcurrentMap) GetDefault(k int64, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Uint8ConcurrentMap) GetOK(k int64) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Uint8ConcurrentMap) Set(k int64, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Uint8ConcurrentMap) Delete(k int64) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Uint8ConcurrentMap) SetKeyValues(kvs ...Int64Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Uint8ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Uint8ConcurrentMap) KeyValues() []Int64Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Uint8ConcurrentMap) ToUnsafeMap() map[int64]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Uint16KeyValue struct {
	Key   int64
	Value uint16
}

type Int64Uint16ConcurrentMapOption func(*Int64Uint16ConcurrentMap)

func WithUnsafeInt64Uint16Map(m map[int64]uint16) Int64Uint16ConcurrentMapOption {
	return func(cm *Int64Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Uint16Map(m map[int64]uint16) Int64Uint16ConcurrentMapOption {
	return func(cm *Int64Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Uint16ConcurrentMap(opts ...Int64Uint16ConcurrentMapOption) *Int64Uint16ConcurrentMap {
	cm := &Int64Uint16ConcurrentMap{
		m: make(map[int64]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Uint16MapKeyValue struct {
	Key   int64
	Value uint16
}

type Int64Uint16ConcurrentMap struct {
	m map[int64]uint16
	L *sync.RWMutex
}

func (cm *Int64Uint16ConcurrentMap) Get(k int64) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Uint16ConcurrentMap) GetDefault(k int64, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Uint16ConcurrentMap) GetOK(k int64) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Uint16ConcurrentMap) Set(k int64, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Uint16ConcurrentMap) Delete(k int64) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Uint16ConcurrentMap) SetKeyValues(kvs ...Int64Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Uint16ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Uint16ConcurrentMap) KeyValues() []Int64Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Uint16ConcurrentMap) ToUnsafeMap() map[int64]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64InterfaceKeyValue struct {
	Key   int64
	Value Interface
}

type Int64InterfaceConcurrentMapOption func(*Int64InterfaceConcurrentMap)

func WithUnsafeInt64InterfaceMap(m map[int64]Interface) Int64InterfaceConcurrentMapOption {
	return func(cm *Int64InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64InterfaceMap(m map[int64]Interface) Int64InterfaceConcurrentMapOption {
	return func(cm *Int64InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64InterfaceConcurrentMap(opts ...Int64InterfaceConcurrentMapOption) *Int64InterfaceConcurrentMap {
	cm := &Int64InterfaceConcurrentMap{
		m: make(map[int64]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64InterfaceMapKeyValue struct {
	Key   int64
	Value Interface
}

type Int64InterfaceConcurrentMap struct {
	m map[int64]Interface
	L *sync.RWMutex
}

func (cm *Int64InterfaceConcurrentMap) Get(k int64) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64InterfaceConcurrentMap) GetDefault(k int64, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64InterfaceConcurrentMap) GetOK(k int64) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64InterfaceConcurrentMap) Set(k int64, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64InterfaceConcurrentMap) Delete(k int64) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64InterfaceConcurrentMap) SetKeyValues(kvs ...Int64InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64InterfaceConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64InterfaceConcurrentMap) KeyValues() []Int64InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64InterfaceConcurrentMap) ToUnsafeMap() map[int64]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Uint32KeyValue struct {
	Key   int64
	Value uint32
}

type Int64Uint32ConcurrentMapOption func(*Int64Uint32ConcurrentMap)

func WithUnsafeInt64Uint32Map(m map[int64]uint32) Int64Uint32ConcurrentMapOption {
	return func(cm *Int64Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Uint32Map(m map[int64]uint32) Int64Uint32ConcurrentMapOption {
	return func(cm *Int64Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Uint32ConcurrentMap(opts ...Int64Uint32ConcurrentMapOption) *Int64Uint32ConcurrentMap {
	cm := &Int64Uint32ConcurrentMap{
		m: make(map[int64]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Uint32MapKeyValue struct {
	Key   int64
	Value uint32
}

type Int64Uint32ConcurrentMap struct {
	m map[int64]uint32
	L *sync.RWMutex
}

func (cm *Int64Uint32ConcurrentMap) Get(k int64) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Uint32ConcurrentMap) GetDefault(k int64, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Uint32ConcurrentMap) GetOK(k int64) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Uint32ConcurrentMap) Set(k int64, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Uint32ConcurrentMap) Delete(k int64) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Uint32ConcurrentMap) SetKeyValues(kvs ...Int64Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Uint32ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Uint32ConcurrentMap) KeyValues() []Int64Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Uint32ConcurrentMap) ToUnsafeMap() map[int64]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Uint64KeyValue struct {
	Key   int64
	Value uint64
}

type Int64Uint64ConcurrentMapOption func(*Int64Uint64ConcurrentMap)

func WithUnsafeInt64Uint64Map(m map[int64]uint64) Int64Uint64ConcurrentMapOption {
	return func(cm *Int64Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Uint64Map(m map[int64]uint64) Int64Uint64ConcurrentMapOption {
	return func(cm *Int64Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Uint64ConcurrentMap(opts ...Int64Uint64ConcurrentMapOption) *Int64Uint64ConcurrentMap {
	cm := &Int64Uint64ConcurrentMap{
		m: make(map[int64]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Uint64MapKeyValue struct {
	Key   int64
	Value uint64
}

type Int64Uint64ConcurrentMap struct {
	m map[int64]uint64
	L *sync.RWMutex
}

func (cm *Int64Uint64ConcurrentMap) Get(k int64) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Uint64ConcurrentMap) GetDefault(k int64, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Uint64ConcurrentMap) GetOK(k int64) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Uint64ConcurrentMap) Set(k int64, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Uint64ConcurrentMap) Delete(k int64) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Uint64ConcurrentMap) SetKeyValues(kvs ...Int64Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Uint64ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Uint64ConcurrentMap) KeyValues() []Int64Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Uint64ConcurrentMap) ToUnsafeMap() map[int64]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64IntKeyValue struct {
	Key   int64
	Value int
}

type Int64IntConcurrentMapOption func(*Int64IntConcurrentMap)

func WithUnsafeInt64IntMap(m map[int64]int) Int64IntConcurrentMapOption {
	return func(cm *Int64IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64IntMap(m map[int64]int) Int64IntConcurrentMapOption {
	return func(cm *Int64IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64IntConcurrentMap(opts ...Int64IntConcurrentMapOption) *Int64IntConcurrentMap {
	cm := &Int64IntConcurrentMap{
		m: make(map[int64]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64IntMapKeyValue struct {
	Key   int64
	Value int
}

type Int64IntConcurrentMap struct {
	m map[int64]int
	L *sync.RWMutex
}

func (cm *Int64IntConcurrentMap) Get(k int64) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64IntConcurrentMap) GetDefault(k int64, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64IntConcurrentMap) GetOK(k int64) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64IntConcurrentMap) Set(k int64, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64IntConcurrentMap) Delete(k int64) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64IntConcurrentMap) SetKeyValues(kvs ...Int64IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64IntConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64IntConcurrentMap) KeyValues() []Int64IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64IntConcurrentMap) ToUnsafeMap() map[int64]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Int8KeyValue struct {
	Key   int64
	Value int8
}

type Int64Int8ConcurrentMapOption func(*Int64Int8ConcurrentMap)

func WithUnsafeInt64Int8Map(m map[int64]int8) Int64Int8ConcurrentMapOption {
	return func(cm *Int64Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Int8Map(m map[int64]int8) Int64Int8ConcurrentMapOption {
	return func(cm *Int64Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Int8ConcurrentMap(opts ...Int64Int8ConcurrentMapOption) *Int64Int8ConcurrentMap {
	cm := &Int64Int8ConcurrentMap{
		m: make(map[int64]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Int8MapKeyValue struct {
	Key   int64
	Value int8
}

type Int64Int8ConcurrentMap struct {
	m map[int64]int8
	L *sync.RWMutex
}

func (cm *Int64Int8ConcurrentMap) Get(k int64) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Int8ConcurrentMap) GetDefault(k int64, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Int8ConcurrentMap) GetOK(k int64) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Int8ConcurrentMap) Set(k int64, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Int8ConcurrentMap) Delete(k int64) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Int8ConcurrentMap) SetKeyValues(kvs ...Int64Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Int8ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Int8ConcurrentMap) KeyValues() []Int64Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Int8ConcurrentMap) ToUnsafeMap() map[int64]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Int16KeyValue struct {
	Key   int64
	Value int16
}

type Int64Int16ConcurrentMapOption func(*Int64Int16ConcurrentMap)

func WithUnsafeInt64Int16Map(m map[int64]int16) Int64Int16ConcurrentMapOption {
	return func(cm *Int64Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Int16Map(m map[int64]int16) Int64Int16ConcurrentMapOption {
	return func(cm *Int64Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Int16ConcurrentMap(opts ...Int64Int16ConcurrentMapOption) *Int64Int16ConcurrentMap {
	cm := &Int64Int16ConcurrentMap{
		m: make(map[int64]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Int16MapKeyValue struct {
	Key   int64
	Value int16
}

type Int64Int16ConcurrentMap struct {
	m map[int64]int16
	L *sync.RWMutex
}

func (cm *Int64Int16ConcurrentMap) Get(k int64) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Int16ConcurrentMap) GetDefault(k int64, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Int16ConcurrentMap) GetOK(k int64) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Int16ConcurrentMap) Set(k int64, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Int16ConcurrentMap) Delete(k int64) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Int16ConcurrentMap) SetKeyValues(kvs ...Int64Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Int16ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Int16ConcurrentMap) KeyValues() []Int64Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Int16ConcurrentMap) ToUnsafeMap() map[int64]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Int32KeyValue struct {
	Key   int64
	Value int32
}

type Int64Int32ConcurrentMapOption func(*Int64Int32ConcurrentMap)

func WithUnsafeInt64Int32Map(m map[int64]int32) Int64Int32ConcurrentMapOption {
	return func(cm *Int64Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Int32Map(m map[int64]int32) Int64Int32ConcurrentMapOption {
	return func(cm *Int64Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Int32ConcurrentMap(opts ...Int64Int32ConcurrentMapOption) *Int64Int32ConcurrentMap {
	cm := &Int64Int32ConcurrentMap{
		m: make(map[int64]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Int32MapKeyValue struct {
	Key   int64
	Value int32
}

type Int64Int32ConcurrentMap struct {
	m map[int64]int32
	L *sync.RWMutex
}

func (cm *Int64Int32ConcurrentMap) Get(k int64) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Int32ConcurrentMap) GetDefault(k int64, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Int32ConcurrentMap) GetOK(k int64) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Int32ConcurrentMap) Set(k int64, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Int32ConcurrentMap) Delete(k int64) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Int32ConcurrentMap) SetKeyValues(kvs ...Int64Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Int32ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Int32ConcurrentMap) KeyValues() []Int64Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Int32ConcurrentMap) ToUnsafeMap() map[int64]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Int64KeyValue struct {
	Key   int64
	Value int64
}

type Int64Int64ConcurrentMapOption func(*Int64Int64ConcurrentMap)

func WithUnsafeInt64Int64Map(m map[int64]int64) Int64Int64ConcurrentMapOption {
	return func(cm *Int64Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Int64Map(m map[int64]int64) Int64Int64ConcurrentMapOption {
	return func(cm *Int64Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Int64ConcurrentMap(opts ...Int64Int64ConcurrentMapOption) *Int64Int64ConcurrentMap {
	cm := &Int64Int64ConcurrentMap{
		m: make(map[int64]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Int64MapKeyValue struct {
	Key   int64
	Value int64
}

type Int64Int64ConcurrentMap struct {
	m map[int64]int64
	L *sync.RWMutex
}

func (cm *Int64Int64ConcurrentMap) Get(k int64) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Int64ConcurrentMap) GetDefault(k int64, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Int64ConcurrentMap) GetOK(k int64) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Int64ConcurrentMap) Set(k int64, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Int64ConcurrentMap) Delete(k int64) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Int64ConcurrentMap) SetKeyValues(kvs ...Int64Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Int64ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Int64ConcurrentMap) KeyValues() []Int64Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Int64ConcurrentMap) ToUnsafeMap() map[int64]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Float32KeyValue struct {
	Key   int64
	Value float32
}

type Int64Float32ConcurrentMapOption func(*Int64Float32ConcurrentMap)

func WithUnsafeInt64Float32Map(m map[int64]float32) Int64Float32ConcurrentMapOption {
	return func(cm *Int64Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Float32Map(m map[int64]float32) Int64Float32ConcurrentMapOption {
	return func(cm *Int64Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Float32ConcurrentMap(opts ...Int64Float32ConcurrentMapOption) *Int64Float32ConcurrentMap {
	cm := &Int64Float32ConcurrentMap{
		m: make(map[int64]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Float32MapKeyValue struct {
	Key   int64
	Value float32
}

type Int64Float32ConcurrentMap struct {
	m map[int64]float32
	L *sync.RWMutex
}

func (cm *Int64Float32ConcurrentMap) Get(k int64) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Float32ConcurrentMap) GetDefault(k int64, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Float32ConcurrentMap) GetOK(k int64) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Float32ConcurrentMap) Set(k int64, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Float32ConcurrentMap) Delete(k int64) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Float32ConcurrentMap) SetKeyValues(kvs ...Int64Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Float32ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Float32ConcurrentMap) KeyValues() []Int64Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Float32ConcurrentMap) ToUnsafeMap() map[int64]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64Float64KeyValue struct {
	Key   int64
	Value float64
}

type Int64Float64ConcurrentMapOption func(*Int64Float64ConcurrentMap)

func WithUnsafeInt64Float64Map(m map[int64]float64) Int64Float64ConcurrentMapOption {
	return func(cm *Int64Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64Float64Map(m map[int64]float64) Int64Float64ConcurrentMapOption {
	return func(cm *Int64Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64Float64ConcurrentMap(opts ...Int64Float64ConcurrentMapOption) *Int64Float64ConcurrentMap {
	cm := &Int64Float64ConcurrentMap{
		m: make(map[int64]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64Float64MapKeyValue struct {
	Key   int64
	Value float64
}

type Int64Float64ConcurrentMap struct {
	m map[int64]float64
	L *sync.RWMutex
}

func (cm *Int64Float64ConcurrentMap) Get(k int64) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64Float64ConcurrentMap) GetDefault(k int64, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64Float64ConcurrentMap) GetOK(k int64) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64Float64ConcurrentMap) Set(k int64, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64Float64ConcurrentMap) Delete(k int64) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64Float64ConcurrentMap) SetKeyValues(kvs ...Int64Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64Float64ConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64Float64ConcurrentMap) KeyValues() []Int64Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64Float64ConcurrentMap) ToUnsafeMap() map[int64]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64TypeKeyValue struct {
	Key   int64
	Value Type
}

type Int64TypeConcurrentMapOption func(*Int64TypeConcurrentMap)

func WithUnsafeInt64TypeMap(m map[int64]Type) Int64TypeConcurrentMapOption {
	return func(cm *Int64TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64TypeMap(m map[int64]Type) Int64TypeConcurrentMapOption {
	return func(cm *Int64TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64TypeConcurrentMap(opts ...Int64TypeConcurrentMapOption) *Int64TypeConcurrentMap {
	cm := &Int64TypeConcurrentMap{
		m: make(map[int64]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64TypeMapKeyValue struct {
	Key   int64
	Value Type
}

type Int64TypeConcurrentMap struct {
	m map[int64]Type
	L *sync.RWMutex
}

func (cm *Int64TypeConcurrentMap) Get(k int64) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64TypeConcurrentMap) GetDefault(k int64, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64TypeConcurrentMap) GetOK(k int64) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64TypeConcurrentMap) Set(k int64, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64TypeConcurrentMap) Delete(k int64) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64TypeConcurrentMap) SetKeyValues(kvs ...Int64TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64TypeConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64TypeConcurrentMap) KeyValues() []Int64TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64TypeConcurrentMap) ToUnsafeMap() map[int64]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64BoolKeyValue struct {
	Key   int64
	Value bool
}

type Int64BoolConcurrentMapOption func(*Int64BoolConcurrentMap)

func WithUnsafeInt64BoolMap(m map[int64]bool) Int64BoolConcurrentMapOption {
	return func(cm *Int64BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64BoolMap(m map[int64]bool) Int64BoolConcurrentMapOption {
	return func(cm *Int64BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64BoolConcurrentMap(opts ...Int64BoolConcurrentMapOption) *Int64BoolConcurrentMap {
	cm := &Int64BoolConcurrentMap{
		m: make(map[int64]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64BoolMapKeyValue struct {
	Key   int64
	Value bool
}

type Int64BoolConcurrentMap struct {
	m map[int64]bool
	L *sync.RWMutex
}

func (cm *Int64BoolConcurrentMap) Get(k int64) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64BoolConcurrentMap) GetDefault(k int64, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64BoolConcurrentMap) GetOK(k int64) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64BoolConcurrentMap) Set(k int64, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64BoolConcurrentMap) Delete(k int64) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64BoolConcurrentMap) SetKeyValues(kvs ...Int64BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64BoolConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64BoolConcurrentMap) KeyValues() []Int64BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64BoolConcurrentMap) ToUnsafeMap() map[int64]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Int64StringKeyValue struct {
	Key   int64
	Value string
}

type Int64StringConcurrentMapOption func(*Int64StringConcurrentMap)

func WithUnsafeInt64StringMap(m map[int64]string) Int64StringConcurrentMapOption {
	return func(cm *Int64StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithInt64StringMap(m map[int64]string) Int64StringConcurrentMapOption {
	return func(cm *Int64StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewInt64StringConcurrentMap(opts ...Int64StringConcurrentMapOption) *Int64StringConcurrentMap {
	cm := &Int64StringConcurrentMap{
		m: make(map[int64]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Int64StringMapKeyValue struct {
	Key   int64
	Value string
}

type Int64StringConcurrentMap struct {
	m map[int64]string
	L *sync.RWMutex
}

func (cm *Int64StringConcurrentMap) Get(k int64) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Int64StringConcurrentMap) GetDefault(k int64, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Int64StringConcurrentMap) GetOK(k int64) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Int64StringConcurrentMap) Set(k int64, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Int64StringConcurrentMap) Delete(k int64) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Int64StringConcurrentMap) SetKeyValues(kvs ...Int64StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Int64StringConcurrentMap) Keys() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []int64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Int64StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Int64StringConcurrentMap) KeyValues() []Int64StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Int64StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Int64StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Int64StringConcurrentMap) ToUnsafeMap() map[int64]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[int64]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32ByteKeyValue struct {
	Key   float32
	Value byte
}

type Float32ByteConcurrentMapOption func(*Float32ByteConcurrentMap)

func WithUnsafeFloat32ByteMap(m map[float32]byte) Float32ByteConcurrentMapOption {
	return func(cm *Float32ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32ByteMap(m map[float32]byte) Float32ByteConcurrentMapOption {
	return func(cm *Float32ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32ByteConcurrentMap(opts ...Float32ByteConcurrentMapOption) *Float32ByteConcurrentMap {
	cm := &Float32ByteConcurrentMap{
		m: make(map[float32]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32ByteMapKeyValue struct {
	Key   float32
	Value byte
}

type Float32ByteConcurrentMap struct {
	m map[float32]byte
	L *sync.RWMutex
}

func (cm *Float32ByteConcurrentMap) Get(k float32) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32ByteConcurrentMap) GetDefault(k float32, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32ByteConcurrentMap) GetOK(k float32) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32ByteConcurrentMap) Set(k float32, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32ByteConcurrentMap) Delete(k float32) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32ByteConcurrentMap) SetKeyValues(kvs ...Float32ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32ByteConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32ByteConcurrentMap) KeyValues() []Float32ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32ByteConcurrentMap) ToUnsafeMap() map[float32]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32RuneKeyValue struct {
	Key   float32
	Value rune
}

type Float32RuneConcurrentMapOption func(*Float32RuneConcurrentMap)

func WithUnsafeFloat32RuneMap(m map[float32]rune) Float32RuneConcurrentMapOption {
	return func(cm *Float32RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32RuneMap(m map[float32]rune) Float32RuneConcurrentMapOption {
	return func(cm *Float32RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32RuneConcurrentMap(opts ...Float32RuneConcurrentMapOption) *Float32RuneConcurrentMap {
	cm := &Float32RuneConcurrentMap{
		m: make(map[float32]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32RuneMapKeyValue struct {
	Key   float32
	Value rune
}

type Float32RuneConcurrentMap struct {
	m map[float32]rune
	L *sync.RWMutex
}

func (cm *Float32RuneConcurrentMap) Get(k float32) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32RuneConcurrentMap) GetDefault(k float32, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32RuneConcurrentMap) GetOK(k float32) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32RuneConcurrentMap) Set(k float32, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32RuneConcurrentMap) Delete(k float32) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32RuneConcurrentMap) SetKeyValues(kvs ...Float32RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32RuneConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32RuneConcurrentMap) KeyValues() []Float32RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32RuneConcurrentMap) ToUnsafeMap() map[float32]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32UintKeyValue struct {
	Key   float32
	Value uint
}

type Float32UintConcurrentMapOption func(*Float32UintConcurrentMap)

func WithUnsafeFloat32UintMap(m map[float32]uint) Float32UintConcurrentMapOption {
	return func(cm *Float32UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32UintMap(m map[float32]uint) Float32UintConcurrentMapOption {
	return func(cm *Float32UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32UintConcurrentMap(opts ...Float32UintConcurrentMapOption) *Float32UintConcurrentMap {
	cm := &Float32UintConcurrentMap{
		m: make(map[float32]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32UintMapKeyValue struct {
	Key   float32
	Value uint
}

type Float32UintConcurrentMap struct {
	m map[float32]uint
	L *sync.RWMutex
}

func (cm *Float32UintConcurrentMap) Get(k float32) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32UintConcurrentMap) GetDefault(k float32, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32UintConcurrentMap) GetOK(k float32) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32UintConcurrentMap) Set(k float32, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32UintConcurrentMap) Delete(k float32) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32UintConcurrentMap) SetKeyValues(kvs ...Float32UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32UintConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32UintConcurrentMap) KeyValues() []Float32UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32UintConcurrentMap) ToUnsafeMap() map[float32]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Uint8KeyValue struct {
	Key   float32
	Value uint8
}

type Float32Uint8ConcurrentMapOption func(*Float32Uint8ConcurrentMap)

func WithUnsafeFloat32Uint8Map(m map[float32]uint8) Float32Uint8ConcurrentMapOption {
	return func(cm *Float32Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Uint8Map(m map[float32]uint8) Float32Uint8ConcurrentMapOption {
	return func(cm *Float32Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Uint8ConcurrentMap(opts ...Float32Uint8ConcurrentMapOption) *Float32Uint8ConcurrentMap {
	cm := &Float32Uint8ConcurrentMap{
		m: make(map[float32]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Uint8MapKeyValue struct {
	Key   float32
	Value uint8
}

type Float32Uint8ConcurrentMap struct {
	m map[float32]uint8
	L *sync.RWMutex
}

func (cm *Float32Uint8ConcurrentMap) Get(k float32) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Uint8ConcurrentMap) GetDefault(k float32, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Uint8ConcurrentMap) GetOK(k float32) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Uint8ConcurrentMap) Set(k float32, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Uint8ConcurrentMap) Delete(k float32) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Uint8ConcurrentMap) SetKeyValues(kvs ...Float32Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Uint8ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Uint8ConcurrentMap) KeyValues() []Float32Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Uint8ConcurrentMap) ToUnsafeMap() map[float32]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Uint16KeyValue struct {
	Key   float32
	Value uint16
}

type Float32Uint16ConcurrentMapOption func(*Float32Uint16ConcurrentMap)

func WithUnsafeFloat32Uint16Map(m map[float32]uint16) Float32Uint16ConcurrentMapOption {
	return func(cm *Float32Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Uint16Map(m map[float32]uint16) Float32Uint16ConcurrentMapOption {
	return func(cm *Float32Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Uint16ConcurrentMap(opts ...Float32Uint16ConcurrentMapOption) *Float32Uint16ConcurrentMap {
	cm := &Float32Uint16ConcurrentMap{
		m: make(map[float32]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Uint16MapKeyValue struct {
	Key   float32
	Value uint16
}

type Float32Uint16ConcurrentMap struct {
	m map[float32]uint16
	L *sync.RWMutex
}

func (cm *Float32Uint16ConcurrentMap) Get(k float32) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Uint16ConcurrentMap) GetDefault(k float32, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Uint16ConcurrentMap) GetOK(k float32) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Uint16ConcurrentMap) Set(k float32, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Uint16ConcurrentMap) Delete(k float32) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Uint16ConcurrentMap) SetKeyValues(kvs ...Float32Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Uint16ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Uint16ConcurrentMap) KeyValues() []Float32Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Uint16ConcurrentMap) ToUnsafeMap() map[float32]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32InterfaceKeyValue struct {
	Key   float32
	Value Interface
}

type Float32InterfaceConcurrentMapOption func(*Float32InterfaceConcurrentMap)

func WithUnsafeFloat32InterfaceMap(m map[float32]Interface) Float32InterfaceConcurrentMapOption {
	return func(cm *Float32InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32InterfaceMap(m map[float32]Interface) Float32InterfaceConcurrentMapOption {
	return func(cm *Float32InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32InterfaceConcurrentMap(opts ...Float32InterfaceConcurrentMapOption) *Float32InterfaceConcurrentMap {
	cm := &Float32InterfaceConcurrentMap{
		m: make(map[float32]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32InterfaceMapKeyValue struct {
	Key   float32
	Value Interface
}

type Float32InterfaceConcurrentMap struct {
	m map[float32]Interface
	L *sync.RWMutex
}

func (cm *Float32InterfaceConcurrentMap) Get(k float32) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32InterfaceConcurrentMap) GetDefault(k float32, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32InterfaceConcurrentMap) GetOK(k float32) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32InterfaceConcurrentMap) Set(k float32, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32InterfaceConcurrentMap) Delete(k float32) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32InterfaceConcurrentMap) SetKeyValues(kvs ...Float32InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32InterfaceConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32InterfaceConcurrentMap) KeyValues() []Float32InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32InterfaceConcurrentMap) ToUnsafeMap() map[float32]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Uint32KeyValue struct {
	Key   float32
	Value uint32
}

type Float32Uint32ConcurrentMapOption func(*Float32Uint32ConcurrentMap)

func WithUnsafeFloat32Uint32Map(m map[float32]uint32) Float32Uint32ConcurrentMapOption {
	return func(cm *Float32Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Uint32Map(m map[float32]uint32) Float32Uint32ConcurrentMapOption {
	return func(cm *Float32Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Uint32ConcurrentMap(opts ...Float32Uint32ConcurrentMapOption) *Float32Uint32ConcurrentMap {
	cm := &Float32Uint32ConcurrentMap{
		m: make(map[float32]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Uint32MapKeyValue struct {
	Key   float32
	Value uint32
}

type Float32Uint32ConcurrentMap struct {
	m map[float32]uint32
	L *sync.RWMutex
}

func (cm *Float32Uint32ConcurrentMap) Get(k float32) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Uint32ConcurrentMap) GetDefault(k float32, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Uint32ConcurrentMap) GetOK(k float32) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Uint32ConcurrentMap) Set(k float32, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Uint32ConcurrentMap) Delete(k float32) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Uint32ConcurrentMap) SetKeyValues(kvs ...Float32Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Uint32ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Uint32ConcurrentMap) KeyValues() []Float32Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Uint32ConcurrentMap) ToUnsafeMap() map[float32]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Uint64KeyValue struct {
	Key   float32
	Value uint64
}

type Float32Uint64ConcurrentMapOption func(*Float32Uint64ConcurrentMap)

func WithUnsafeFloat32Uint64Map(m map[float32]uint64) Float32Uint64ConcurrentMapOption {
	return func(cm *Float32Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Uint64Map(m map[float32]uint64) Float32Uint64ConcurrentMapOption {
	return func(cm *Float32Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Uint64ConcurrentMap(opts ...Float32Uint64ConcurrentMapOption) *Float32Uint64ConcurrentMap {
	cm := &Float32Uint64ConcurrentMap{
		m: make(map[float32]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Uint64MapKeyValue struct {
	Key   float32
	Value uint64
}

type Float32Uint64ConcurrentMap struct {
	m map[float32]uint64
	L *sync.RWMutex
}

func (cm *Float32Uint64ConcurrentMap) Get(k float32) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Uint64ConcurrentMap) GetDefault(k float32, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Uint64ConcurrentMap) GetOK(k float32) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Uint64ConcurrentMap) Set(k float32, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Uint64ConcurrentMap) Delete(k float32) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Uint64ConcurrentMap) SetKeyValues(kvs ...Float32Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Uint64ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Uint64ConcurrentMap) KeyValues() []Float32Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Uint64ConcurrentMap) ToUnsafeMap() map[float32]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32IntKeyValue struct {
	Key   float32
	Value int
}

type Float32IntConcurrentMapOption func(*Float32IntConcurrentMap)

func WithUnsafeFloat32IntMap(m map[float32]int) Float32IntConcurrentMapOption {
	return func(cm *Float32IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32IntMap(m map[float32]int) Float32IntConcurrentMapOption {
	return func(cm *Float32IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32IntConcurrentMap(opts ...Float32IntConcurrentMapOption) *Float32IntConcurrentMap {
	cm := &Float32IntConcurrentMap{
		m: make(map[float32]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32IntMapKeyValue struct {
	Key   float32
	Value int
}

type Float32IntConcurrentMap struct {
	m map[float32]int
	L *sync.RWMutex
}

func (cm *Float32IntConcurrentMap) Get(k float32) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32IntConcurrentMap) GetDefault(k float32, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32IntConcurrentMap) GetOK(k float32) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32IntConcurrentMap) Set(k float32, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32IntConcurrentMap) Delete(k float32) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32IntConcurrentMap) SetKeyValues(kvs ...Float32IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32IntConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32IntConcurrentMap) KeyValues() []Float32IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32IntConcurrentMap) ToUnsafeMap() map[float32]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Int8KeyValue struct {
	Key   float32
	Value int8
}

type Float32Int8ConcurrentMapOption func(*Float32Int8ConcurrentMap)

func WithUnsafeFloat32Int8Map(m map[float32]int8) Float32Int8ConcurrentMapOption {
	return func(cm *Float32Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Int8Map(m map[float32]int8) Float32Int8ConcurrentMapOption {
	return func(cm *Float32Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Int8ConcurrentMap(opts ...Float32Int8ConcurrentMapOption) *Float32Int8ConcurrentMap {
	cm := &Float32Int8ConcurrentMap{
		m: make(map[float32]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Int8MapKeyValue struct {
	Key   float32
	Value int8
}

type Float32Int8ConcurrentMap struct {
	m map[float32]int8
	L *sync.RWMutex
}

func (cm *Float32Int8ConcurrentMap) Get(k float32) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Int8ConcurrentMap) GetDefault(k float32, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Int8ConcurrentMap) GetOK(k float32) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Int8ConcurrentMap) Set(k float32, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Int8ConcurrentMap) Delete(k float32) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Int8ConcurrentMap) SetKeyValues(kvs ...Float32Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Int8ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Int8ConcurrentMap) KeyValues() []Float32Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Int8ConcurrentMap) ToUnsafeMap() map[float32]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Int16KeyValue struct {
	Key   float32
	Value int16
}

type Float32Int16ConcurrentMapOption func(*Float32Int16ConcurrentMap)

func WithUnsafeFloat32Int16Map(m map[float32]int16) Float32Int16ConcurrentMapOption {
	return func(cm *Float32Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Int16Map(m map[float32]int16) Float32Int16ConcurrentMapOption {
	return func(cm *Float32Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Int16ConcurrentMap(opts ...Float32Int16ConcurrentMapOption) *Float32Int16ConcurrentMap {
	cm := &Float32Int16ConcurrentMap{
		m: make(map[float32]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Int16MapKeyValue struct {
	Key   float32
	Value int16
}

type Float32Int16ConcurrentMap struct {
	m map[float32]int16
	L *sync.RWMutex
}

func (cm *Float32Int16ConcurrentMap) Get(k float32) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Int16ConcurrentMap) GetDefault(k float32, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Int16ConcurrentMap) GetOK(k float32) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Int16ConcurrentMap) Set(k float32, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Int16ConcurrentMap) Delete(k float32) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Int16ConcurrentMap) SetKeyValues(kvs ...Float32Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Int16ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Int16ConcurrentMap) KeyValues() []Float32Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Int16ConcurrentMap) ToUnsafeMap() map[float32]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Int32KeyValue struct {
	Key   float32
	Value int32
}

type Float32Int32ConcurrentMapOption func(*Float32Int32ConcurrentMap)

func WithUnsafeFloat32Int32Map(m map[float32]int32) Float32Int32ConcurrentMapOption {
	return func(cm *Float32Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Int32Map(m map[float32]int32) Float32Int32ConcurrentMapOption {
	return func(cm *Float32Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Int32ConcurrentMap(opts ...Float32Int32ConcurrentMapOption) *Float32Int32ConcurrentMap {
	cm := &Float32Int32ConcurrentMap{
		m: make(map[float32]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Int32MapKeyValue struct {
	Key   float32
	Value int32
}

type Float32Int32ConcurrentMap struct {
	m map[float32]int32
	L *sync.RWMutex
}

func (cm *Float32Int32ConcurrentMap) Get(k float32) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Int32ConcurrentMap) GetDefault(k float32, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Int32ConcurrentMap) GetOK(k float32) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Int32ConcurrentMap) Set(k float32, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Int32ConcurrentMap) Delete(k float32) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Int32ConcurrentMap) SetKeyValues(kvs ...Float32Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Int32ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Int32ConcurrentMap) KeyValues() []Float32Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Int32ConcurrentMap) ToUnsafeMap() map[float32]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Int64KeyValue struct {
	Key   float32
	Value int64
}

type Float32Int64ConcurrentMapOption func(*Float32Int64ConcurrentMap)

func WithUnsafeFloat32Int64Map(m map[float32]int64) Float32Int64ConcurrentMapOption {
	return func(cm *Float32Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Int64Map(m map[float32]int64) Float32Int64ConcurrentMapOption {
	return func(cm *Float32Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Int64ConcurrentMap(opts ...Float32Int64ConcurrentMapOption) *Float32Int64ConcurrentMap {
	cm := &Float32Int64ConcurrentMap{
		m: make(map[float32]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Int64MapKeyValue struct {
	Key   float32
	Value int64
}

type Float32Int64ConcurrentMap struct {
	m map[float32]int64
	L *sync.RWMutex
}

func (cm *Float32Int64ConcurrentMap) Get(k float32) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Int64ConcurrentMap) GetDefault(k float32, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Int64ConcurrentMap) GetOK(k float32) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Int64ConcurrentMap) Set(k float32, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Int64ConcurrentMap) Delete(k float32) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Int64ConcurrentMap) SetKeyValues(kvs ...Float32Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Int64ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Int64ConcurrentMap) KeyValues() []Float32Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Int64ConcurrentMap) ToUnsafeMap() map[float32]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Float32KeyValue struct {
	Key   float32
	Value float32
}

type Float32Float32ConcurrentMapOption func(*Float32Float32ConcurrentMap)

func WithUnsafeFloat32Float32Map(m map[float32]float32) Float32Float32ConcurrentMapOption {
	return func(cm *Float32Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Float32Map(m map[float32]float32) Float32Float32ConcurrentMapOption {
	return func(cm *Float32Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Float32ConcurrentMap(opts ...Float32Float32ConcurrentMapOption) *Float32Float32ConcurrentMap {
	cm := &Float32Float32ConcurrentMap{
		m: make(map[float32]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Float32MapKeyValue struct {
	Key   float32
	Value float32
}

type Float32Float32ConcurrentMap struct {
	m map[float32]float32
	L *sync.RWMutex
}

func (cm *Float32Float32ConcurrentMap) Get(k float32) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Float32ConcurrentMap) GetDefault(k float32, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Float32ConcurrentMap) GetOK(k float32) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Float32ConcurrentMap) Set(k float32, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Float32ConcurrentMap) Delete(k float32) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Float32ConcurrentMap) SetKeyValues(kvs ...Float32Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Float32ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Float32ConcurrentMap) KeyValues() []Float32Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Float32ConcurrentMap) ToUnsafeMap() map[float32]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32Float64KeyValue struct {
	Key   float32
	Value float64
}

type Float32Float64ConcurrentMapOption func(*Float32Float64ConcurrentMap)

func WithUnsafeFloat32Float64Map(m map[float32]float64) Float32Float64ConcurrentMapOption {
	return func(cm *Float32Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32Float64Map(m map[float32]float64) Float32Float64ConcurrentMapOption {
	return func(cm *Float32Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32Float64ConcurrentMap(opts ...Float32Float64ConcurrentMapOption) *Float32Float64ConcurrentMap {
	cm := &Float32Float64ConcurrentMap{
		m: make(map[float32]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32Float64MapKeyValue struct {
	Key   float32
	Value float64
}

type Float32Float64ConcurrentMap struct {
	m map[float32]float64
	L *sync.RWMutex
}

func (cm *Float32Float64ConcurrentMap) Get(k float32) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32Float64ConcurrentMap) GetDefault(k float32, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32Float64ConcurrentMap) GetOK(k float32) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32Float64ConcurrentMap) Set(k float32, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32Float64ConcurrentMap) Delete(k float32) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32Float64ConcurrentMap) SetKeyValues(kvs ...Float32Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32Float64ConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32Float64ConcurrentMap) KeyValues() []Float32Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32Float64ConcurrentMap) ToUnsafeMap() map[float32]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32TypeKeyValue struct {
	Key   float32
	Value Type
}

type Float32TypeConcurrentMapOption func(*Float32TypeConcurrentMap)

func WithUnsafeFloat32TypeMap(m map[float32]Type) Float32TypeConcurrentMapOption {
	return func(cm *Float32TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32TypeMap(m map[float32]Type) Float32TypeConcurrentMapOption {
	return func(cm *Float32TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32TypeConcurrentMap(opts ...Float32TypeConcurrentMapOption) *Float32TypeConcurrentMap {
	cm := &Float32TypeConcurrentMap{
		m: make(map[float32]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32TypeMapKeyValue struct {
	Key   float32
	Value Type
}

type Float32TypeConcurrentMap struct {
	m map[float32]Type
	L *sync.RWMutex
}

func (cm *Float32TypeConcurrentMap) Get(k float32) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32TypeConcurrentMap) GetDefault(k float32, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32TypeConcurrentMap) GetOK(k float32) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32TypeConcurrentMap) Set(k float32, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32TypeConcurrentMap) Delete(k float32) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32TypeConcurrentMap) SetKeyValues(kvs ...Float32TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32TypeConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32TypeConcurrentMap) KeyValues() []Float32TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32TypeConcurrentMap) ToUnsafeMap() map[float32]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32BoolKeyValue struct {
	Key   float32
	Value bool
}

type Float32BoolConcurrentMapOption func(*Float32BoolConcurrentMap)

func WithUnsafeFloat32BoolMap(m map[float32]bool) Float32BoolConcurrentMapOption {
	return func(cm *Float32BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32BoolMap(m map[float32]bool) Float32BoolConcurrentMapOption {
	return func(cm *Float32BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32BoolConcurrentMap(opts ...Float32BoolConcurrentMapOption) *Float32BoolConcurrentMap {
	cm := &Float32BoolConcurrentMap{
		m: make(map[float32]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32BoolMapKeyValue struct {
	Key   float32
	Value bool
}

type Float32BoolConcurrentMap struct {
	m map[float32]bool
	L *sync.RWMutex
}

func (cm *Float32BoolConcurrentMap) Get(k float32) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32BoolConcurrentMap) GetDefault(k float32, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32BoolConcurrentMap) GetOK(k float32) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32BoolConcurrentMap) Set(k float32, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32BoolConcurrentMap) Delete(k float32) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32BoolConcurrentMap) SetKeyValues(kvs ...Float32BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32BoolConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32BoolConcurrentMap) KeyValues() []Float32BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32BoolConcurrentMap) ToUnsafeMap() map[float32]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float32StringKeyValue struct {
	Key   float32
	Value string
}

type Float32StringConcurrentMapOption func(*Float32StringConcurrentMap)

func WithUnsafeFloat32StringMap(m map[float32]string) Float32StringConcurrentMapOption {
	return func(cm *Float32StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat32StringMap(m map[float32]string) Float32StringConcurrentMapOption {
	return func(cm *Float32StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat32StringConcurrentMap(opts ...Float32StringConcurrentMapOption) *Float32StringConcurrentMap {
	cm := &Float32StringConcurrentMap{
		m: make(map[float32]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float32StringMapKeyValue struct {
	Key   float32
	Value string
}

type Float32StringConcurrentMap struct {
	m map[float32]string
	L *sync.RWMutex
}

func (cm *Float32StringConcurrentMap) Get(k float32) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float32StringConcurrentMap) GetDefault(k float32, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float32StringConcurrentMap) GetOK(k float32) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float32StringConcurrentMap) Set(k float32, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float32StringConcurrentMap) Delete(k float32) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float32StringConcurrentMap) SetKeyValues(kvs ...Float32StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float32StringConcurrentMap) Keys() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float32
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float32StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float32StringConcurrentMap) KeyValues() []Float32StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float32StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float32StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float32StringConcurrentMap) ToUnsafeMap() map[float32]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float32]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64ByteKeyValue struct {
	Key   float64
	Value byte
}

type Float64ByteConcurrentMapOption func(*Float64ByteConcurrentMap)

func WithUnsafeFloat64ByteMap(m map[float64]byte) Float64ByteConcurrentMapOption {
	return func(cm *Float64ByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64ByteMap(m map[float64]byte) Float64ByteConcurrentMapOption {
	return func(cm *Float64ByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64ByteConcurrentMap(opts ...Float64ByteConcurrentMapOption) *Float64ByteConcurrentMap {
	cm := &Float64ByteConcurrentMap{
		m: make(map[float64]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64ByteMapKeyValue struct {
	Key   float64
	Value byte
}

type Float64ByteConcurrentMap struct {
	m map[float64]byte
	L *sync.RWMutex
}

func (cm *Float64ByteConcurrentMap) Get(k float64) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64ByteConcurrentMap) GetDefault(k float64, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64ByteConcurrentMap) GetOK(k float64) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64ByteConcurrentMap) Set(k float64, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64ByteConcurrentMap) Delete(k float64) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64ByteConcurrentMap) SetKeyValues(kvs ...Float64ByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64ByteConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64ByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64ByteConcurrentMap) KeyValues() []Float64ByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64ByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64ByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64ByteConcurrentMap) ToUnsafeMap() map[float64]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64RuneKeyValue struct {
	Key   float64
	Value rune
}

type Float64RuneConcurrentMapOption func(*Float64RuneConcurrentMap)

func WithUnsafeFloat64RuneMap(m map[float64]rune) Float64RuneConcurrentMapOption {
	return func(cm *Float64RuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64RuneMap(m map[float64]rune) Float64RuneConcurrentMapOption {
	return func(cm *Float64RuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64RuneConcurrentMap(opts ...Float64RuneConcurrentMapOption) *Float64RuneConcurrentMap {
	cm := &Float64RuneConcurrentMap{
		m: make(map[float64]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64RuneMapKeyValue struct {
	Key   float64
	Value rune
}

type Float64RuneConcurrentMap struct {
	m map[float64]rune
	L *sync.RWMutex
}

func (cm *Float64RuneConcurrentMap) Get(k float64) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64RuneConcurrentMap) GetDefault(k float64, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64RuneConcurrentMap) GetOK(k float64) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64RuneConcurrentMap) Set(k float64, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64RuneConcurrentMap) Delete(k float64) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64RuneConcurrentMap) SetKeyValues(kvs ...Float64RuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64RuneConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64RuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64RuneConcurrentMap) KeyValues() []Float64RuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64RuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64RuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64RuneConcurrentMap) ToUnsafeMap() map[float64]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64UintKeyValue struct {
	Key   float64
	Value uint
}

type Float64UintConcurrentMapOption func(*Float64UintConcurrentMap)

func WithUnsafeFloat64UintMap(m map[float64]uint) Float64UintConcurrentMapOption {
	return func(cm *Float64UintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64UintMap(m map[float64]uint) Float64UintConcurrentMapOption {
	return func(cm *Float64UintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64UintConcurrentMap(opts ...Float64UintConcurrentMapOption) *Float64UintConcurrentMap {
	cm := &Float64UintConcurrentMap{
		m: make(map[float64]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64UintMapKeyValue struct {
	Key   float64
	Value uint
}

type Float64UintConcurrentMap struct {
	m map[float64]uint
	L *sync.RWMutex
}

func (cm *Float64UintConcurrentMap) Get(k float64) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64UintConcurrentMap) GetDefault(k float64, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64UintConcurrentMap) GetOK(k float64) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64UintConcurrentMap) Set(k float64, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64UintConcurrentMap) Delete(k float64) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64UintConcurrentMap) SetKeyValues(kvs ...Float64UintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64UintConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64UintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64UintConcurrentMap) KeyValues() []Float64UintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64UintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64UintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64UintConcurrentMap) ToUnsafeMap() map[float64]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Uint8KeyValue struct {
	Key   float64
	Value uint8
}

type Float64Uint8ConcurrentMapOption func(*Float64Uint8ConcurrentMap)

func WithUnsafeFloat64Uint8Map(m map[float64]uint8) Float64Uint8ConcurrentMapOption {
	return func(cm *Float64Uint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Uint8Map(m map[float64]uint8) Float64Uint8ConcurrentMapOption {
	return func(cm *Float64Uint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Uint8ConcurrentMap(opts ...Float64Uint8ConcurrentMapOption) *Float64Uint8ConcurrentMap {
	cm := &Float64Uint8ConcurrentMap{
		m: make(map[float64]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Uint8MapKeyValue struct {
	Key   float64
	Value uint8
}

type Float64Uint8ConcurrentMap struct {
	m map[float64]uint8
	L *sync.RWMutex
}

func (cm *Float64Uint8ConcurrentMap) Get(k float64) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Uint8ConcurrentMap) GetDefault(k float64, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Uint8ConcurrentMap) GetOK(k float64) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Uint8ConcurrentMap) Set(k float64, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Uint8ConcurrentMap) Delete(k float64) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Uint8ConcurrentMap) SetKeyValues(kvs ...Float64Uint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Uint8ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Uint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Uint8ConcurrentMap) KeyValues() []Float64Uint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Uint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Uint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Uint8ConcurrentMap) ToUnsafeMap() map[float64]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Uint16KeyValue struct {
	Key   float64
	Value uint16
}

type Float64Uint16ConcurrentMapOption func(*Float64Uint16ConcurrentMap)

func WithUnsafeFloat64Uint16Map(m map[float64]uint16) Float64Uint16ConcurrentMapOption {
	return func(cm *Float64Uint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Uint16Map(m map[float64]uint16) Float64Uint16ConcurrentMapOption {
	return func(cm *Float64Uint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Uint16ConcurrentMap(opts ...Float64Uint16ConcurrentMapOption) *Float64Uint16ConcurrentMap {
	cm := &Float64Uint16ConcurrentMap{
		m: make(map[float64]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Uint16MapKeyValue struct {
	Key   float64
	Value uint16
}

type Float64Uint16ConcurrentMap struct {
	m map[float64]uint16
	L *sync.RWMutex
}

func (cm *Float64Uint16ConcurrentMap) Get(k float64) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Uint16ConcurrentMap) GetDefault(k float64, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Uint16ConcurrentMap) GetOK(k float64) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Uint16ConcurrentMap) Set(k float64, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Uint16ConcurrentMap) Delete(k float64) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Uint16ConcurrentMap) SetKeyValues(kvs ...Float64Uint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Uint16ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Uint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Uint16ConcurrentMap) KeyValues() []Float64Uint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Uint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Uint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Uint16ConcurrentMap) ToUnsafeMap() map[float64]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64InterfaceKeyValue struct {
	Key   float64
	Value Interface
}

type Float64InterfaceConcurrentMapOption func(*Float64InterfaceConcurrentMap)

func WithUnsafeFloat64InterfaceMap(m map[float64]Interface) Float64InterfaceConcurrentMapOption {
	return func(cm *Float64InterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64InterfaceMap(m map[float64]Interface) Float64InterfaceConcurrentMapOption {
	return func(cm *Float64InterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64InterfaceConcurrentMap(opts ...Float64InterfaceConcurrentMapOption) *Float64InterfaceConcurrentMap {
	cm := &Float64InterfaceConcurrentMap{
		m: make(map[float64]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64InterfaceMapKeyValue struct {
	Key   float64
	Value Interface
}

type Float64InterfaceConcurrentMap struct {
	m map[float64]Interface
	L *sync.RWMutex
}

func (cm *Float64InterfaceConcurrentMap) Get(k float64) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64InterfaceConcurrentMap) GetDefault(k float64, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64InterfaceConcurrentMap) GetOK(k float64) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64InterfaceConcurrentMap) Set(k float64, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64InterfaceConcurrentMap) Delete(k float64) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64InterfaceConcurrentMap) SetKeyValues(kvs ...Float64InterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64InterfaceConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64InterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64InterfaceConcurrentMap) KeyValues() []Float64InterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64InterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64InterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64InterfaceConcurrentMap) ToUnsafeMap() map[float64]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Uint32KeyValue struct {
	Key   float64
	Value uint32
}

type Float64Uint32ConcurrentMapOption func(*Float64Uint32ConcurrentMap)

func WithUnsafeFloat64Uint32Map(m map[float64]uint32) Float64Uint32ConcurrentMapOption {
	return func(cm *Float64Uint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Uint32Map(m map[float64]uint32) Float64Uint32ConcurrentMapOption {
	return func(cm *Float64Uint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Uint32ConcurrentMap(opts ...Float64Uint32ConcurrentMapOption) *Float64Uint32ConcurrentMap {
	cm := &Float64Uint32ConcurrentMap{
		m: make(map[float64]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Uint32MapKeyValue struct {
	Key   float64
	Value uint32
}

type Float64Uint32ConcurrentMap struct {
	m map[float64]uint32
	L *sync.RWMutex
}

func (cm *Float64Uint32ConcurrentMap) Get(k float64) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Uint32ConcurrentMap) GetDefault(k float64, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Uint32ConcurrentMap) GetOK(k float64) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Uint32ConcurrentMap) Set(k float64, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Uint32ConcurrentMap) Delete(k float64) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Uint32ConcurrentMap) SetKeyValues(kvs ...Float64Uint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Uint32ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Uint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Uint32ConcurrentMap) KeyValues() []Float64Uint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Uint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Uint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Uint32ConcurrentMap) ToUnsafeMap() map[float64]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Uint64KeyValue struct {
	Key   float64
	Value uint64
}

type Float64Uint64ConcurrentMapOption func(*Float64Uint64ConcurrentMap)

func WithUnsafeFloat64Uint64Map(m map[float64]uint64) Float64Uint64ConcurrentMapOption {
	return func(cm *Float64Uint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Uint64Map(m map[float64]uint64) Float64Uint64ConcurrentMapOption {
	return func(cm *Float64Uint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Uint64ConcurrentMap(opts ...Float64Uint64ConcurrentMapOption) *Float64Uint64ConcurrentMap {
	cm := &Float64Uint64ConcurrentMap{
		m: make(map[float64]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Uint64MapKeyValue struct {
	Key   float64
	Value uint64
}

type Float64Uint64ConcurrentMap struct {
	m map[float64]uint64
	L *sync.RWMutex
}

func (cm *Float64Uint64ConcurrentMap) Get(k float64) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Uint64ConcurrentMap) GetDefault(k float64, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Uint64ConcurrentMap) GetOK(k float64) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Uint64ConcurrentMap) Set(k float64, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Uint64ConcurrentMap) Delete(k float64) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Uint64ConcurrentMap) SetKeyValues(kvs ...Float64Uint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Uint64ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Uint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Uint64ConcurrentMap) KeyValues() []Float64Uint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Uint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Uint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Uint64ConcurrentMap) ToUnsafeMap() map[float64]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64IntKeyValue struct {
	Key   float64
	Value int
}

type Float64IntConcurrentMapOption func(*Float64IntConcurrentMap)

func WithUnsafeFloat64IntMap(m map[float64]int) Float64IntConcurrentMapOption {
	return func(cm *Float64IntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64IntMap(m map[float64]int) Float64IntConcurrentMapOption {
	return func(cm *Float64IntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64IntConcurrentMap(opts ...Float64IntConcurrentMapOption) *Float64IntConcurrentMap {
	cm := &Float64IntConcurrentMap{
		m: make(map[float64]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64IntMapKeyValue struct {
	Key   float64
	Value int
}

type Float64IntConcurrentMap struct {
	m map[float64]int
	L *sync.RWMutex
}

func (cm *Float64IntConcurrentMap) Get(k float64) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64IntConcurrentMap) GetDefault(k float64, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64IntConcurrentMap) GetOK(k float64) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64IntConcurrentMap) Set(k float64, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64IntConcurrentMap) Delete(k float64) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64IntConcurrentMap) SetKeyValues(kvs ...Float64IntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64IntConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64IntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64IntConcurrentMap) KeyValues() []Float64IntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64IntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64IntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64IntConcurrentMap) ToUnsafeMap() map[float64]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Int8KeyValue struct {
	Key   float64
	Value int8
}

type Float64Int8ConcurrentMapOption func(*Float64Int8ConcurrentMap)

func WithUnsafeFloat64Int8Map(m map[float64]int8) Float64Int8ConcurrentMapOption {
	return func(cm *Float64Int8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Int8Map(m map[float64]int8) Float64Int8ConcurrentMapOption {
	return func(cm *Float64Int8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Int8ConcurrentMap(opts ...Float64Int8ConcurrentMapOption) *Float64Int8ConcurrentMap {
	cm := &Float64Int8ConcurrentMap{
		m: make(map[float64]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Int8MapKeyValue struct {
	Key   float64
	Value int8
}

type Float64Int8ConcurrentMap struct {
	m map[float64]int8
	L *sync.RWMutex
}

func (cm *Float64Int8ConcurrentMap) Get(k float64) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Int8ConcurrentMap) GetDefault(k float64, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Int8ConcurrentMap) GetOK(k float64) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Int8ConcurrentMap) Set(k float64, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Int8ConcurrentMap) Delete(k float64) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Int8ConcurrentMap) SetKeyValues(kvs ...Float64Int8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Int8ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Int8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Int8ConcurrentMap) KeyValues() []Float64Int8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Int8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Int8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Int8ConcurrentMap) ToUnsafeMap() map[float64]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Int16KeyValue struct {
	Key   float64
	Value int16
}

type Float64Int16ConcurrentMapOption func(*Float64Int16ConcurrentMap)

func WithUnsafeFloat64Int16Map(m map[float64]int16) Float64Int16ConcurrentMapOption {
	return func(cm *Float64Int16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Int16Map(m map[float64]int16) Float64Int16ConcurrentMapOption {
	return func(cm *Float64Int16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Int16ConcurrentMap(opts ...Float64Int16ConcurrentMapOption) *Float64Int16ConcurrentMap {
	cm := &Float64Int16ConcurrentMap{
		m: make(map[float64]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Int16MapKeyValue struct {
	Key   float64
	Value int16
}

type Float64Int16ConcurrentMap struct {
	m map[float64]int16
	L *sync.RWMutex
}

func (cm *Float64Int16ConcurrentMap) Get(k float64) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Int16ConcurrentMap) GetDefault(k float64, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Int16ConcurrentMap) GetOK(k float64) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Int16ConcurrentMap) Set(k float64, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Int16ConcurrentMap) Delete(k float64) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Int16ConcurrentMap) SetKeyValues(kvs ...Float64Int16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Int16ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Int16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Int16ConcurrentMap) KeyValues() []Float64Int16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Int16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Int16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Int16ConcurrentMap) ToUnsafeMap() map[float64]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Int32KeyValue struct {
	Key   float64
	Value int32
}

type Float64Int32ConcurrentMapOption func(*Float64Int32ConcurrentMap)

func WithUnsafeFloat64Int32Map(m map[float64]int32) Float64Int32ConcurrentMapOption {
	return func(cm *Float64Int32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Int32Map(m map[float64]int32) Float64Int32ConcurrentMapOption {
	return func(cm *Float64Int32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Int32ConcurrentMap(opts ...Float64Int32ConcurrentMapOption) *Float64Int32ConcurrentMap {
	cm := &Float64Int32ConcurrentMap{
		m: make(map[float64]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Int32MapKeyValue struct {
	Key   float64
	Value int32
}

type Float64Int32ConcurrentMap struct {
	m map[float64]int32
	L *sync.RWMutex
}

func (cm *Float64Int32ConcurrentMap) Get(k float64) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Int32ConcurrentMap) GetDefault(k float64, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Int32ConcurrentMap) GetOK(k float64) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Int32ConcurrentMap) Set(k float64, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Int32ConcurrentMap) Delete(k float64) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Int32ConcurrentMap) SetKeyValues(kvs ...Float64Int32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Int32ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Int32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Int32ConcurrentMap) KeyValues() []Float64Int32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Int32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Int32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Int32ConcurrentMap) ToUnsafeMap() map[float64]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Int64KeyValue struct {
	Key   float64
	Value int64
}

type Float64Int64ConcurrentMapOption func(*Float64Int64ConcurrentMap)

func WithUnsafeFloat64Int64Map(m map[float64]int64) Float64Int64ConcurrentMapOption {
	return func(cm *Float64Int64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Int64Map(m map[float64]int64) Float64Int64ConcurrentMapOption {
	return func(cm *Float64Int64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Int64ConcurrentMap(opts ...Float64Int64ConcurrentMapOption) *Float64Int64ConcurrentMap {
	cm := &Float64Int64ConcurrentMap{
		m: make(map[float64]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Int64MapKeyValue struct {
	Key   float64
	Value int64
}

type Float64Int64ConcurrentMap struct {
	m map[float64]int64
	L *sync.RWMutex
}

func (cm *Float64Int64ConcurrentMap) Get(k float64) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Int64ConcurrentMap) GetDefault(k float64, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Int64ConcurrentMap) GetOK(k float64) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Int64ConcurrentMap) Set(k float64, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Int64ConcurrentMap) Delete(k float64) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Int64ConcurrentMap) SetKeyValues(kvs ...Float64Int64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Int64ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Int64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Int64ConcurrentMap) KeyValues() []Float64Int64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Int64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Int64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Int64ConcurrentMap) ToUnsafeMap() map[float64]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Float32KeyValue struct {
	Key   float64
	Value float32
}

type Float64Float32ConcurrentMapOption func(*Float64Float32ConcurrentMap)

func WithUnsafeFloat64Float32Map(m map[float64]float32) Float64Float32ConcurrentMapOption {
	return func(cm *Float64Float32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Float32Map(m map[float64]float32) Float64Float32ConcurrentMapOption {
	return func(cm *Float64Float32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Float32ConcurrentMap(opts ...Float64Float32ConcurrentMapOption) *Float64Float32ConcurrentMap {
	cm := &Float64Float32ConcurrentMap{
		m: make(map[float64]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Float32MapKeyValue struct {
	Key   float64
	Value float32
}

type Float64Float32ConcurrentMap struct {
	m map[float64]float32
	L *sync.RWMutex
}

func (cm *Float64Float32ConcurrentMap) Get(k float64) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Float32ConcurrentMap) GetDefault(k float64, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Float32ConcurrentMap) GetOK(k float64) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Float32ConcurrentMap) Set(k float64, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Float32ConcurrentMap) Delete(k float64) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Float32ConcurrentMap) SetKeyValues(kvs ...Float64Float32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Float32ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Float32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Float32ConcurrentMap) KeyValues() []Float64Float32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Float32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Float32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Float32ConcurrentMap) ToUnsafeMap() map[float64]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64Float64KeyValue struct {
	Key   float64
	Value float64
}

type Float64Float64ConcurrentMapOption func(*Float64Float64ConcurrentMap)

func WithUnsafeFloat64Float64Map(m map[float64]float64) Float64Float64ConcurrentMapOption {
	return func(cm *Float64Float64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64Float64Map(m map[float64]float64) Float64Float64ConcurrentMapOption {
	return func(cm *Float64Float64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64Float64ConcurrentMap(opts ...Float64Float64ConcurrentMapOption) *Float64Float64ConcurrentMap {
	cm := &Float64Float64ConcurrentMap{
		m: make(map[float64]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64Float64MapKeyValue struct {
	Key   float64
	Value float64
}

type Float64Float64ConcurrentMap struct {
	m map[float64]float64
	L *sync.RWMutex
}

func (cm *Float64Float64ConcurrentMap) Get(k float64) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64Float64ConcurrentMap) GetDefault(k float64, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64Float64ConcurrentMap) GetOK(k float64) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64Float64ConcurrentMap) Set(k float64, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64Float64ConcurrentMap) Delete(k float64) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64Float64ConcurrentMap) SetKeyValues(kvs ...Float64Float64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64Float64ConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64Float64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64Float64ConcurrentMap) KeyValues() []Float64Float64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64Float64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64Float64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64Float64ConcurrentMap) ToUnsafeMap() map[float64]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64TypeKeyValue struct {
	Key   float64
	Value Type
}

type Float64TypeConcurrentMapOption func(*Float64TypeConcurrentMap)

func WithUnsafeFloat64TypeMap(m map[float64]Type) Float64TypeConcurrentMapOption {
	return func(cm *Float64TypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64TypeMap(m map[float64]Type) Float64TypeConcurrentMapOption {
	return func(cm *Float64TypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64TypeConcurrentMap(opts ...Float64TypeConcurrentMapOption) *Float64TypeConcurrentMap {
	cm := &Float64TypeConcurrentMap{
		m: make(map[float64]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64TypeMapKeyValue struct {
	Key   float64
	Value Type
}

type Float64TypeConcurrentMap struct {
	m map[float64]Type
	L *sync.RWMutex
}

func (cm *Float64TypeConcurrentMap) Get(k float64) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64TypeConcurrentMap) GetDefault(k float64, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64TypeConcurrentMap) GetOK(k float64) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64TypeConcurrentMap) Set(k float64, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64TypeConcurrentMap) Delete(k float64) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64TypeConcurrentMap) SetKeyValues(kvs ...Float64TypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64TypeConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64TypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64TypeConcurrentMap) KeyValues() []Float64TypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64TypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64TypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64TypeConcurrentMap) ToUnsafeMap() map[float64]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64BoolKeyValue struct {
	Key   float64
	Value bool
}

type Float64BoolConcurrentMapOption func(*Float64BoolConcurrentMap)

func WithUnsafeFloat64BoolMap(m map[float64]bool) Float64BoolConcurrentMapOption {
	return func(cm *Float64BoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64BoolMap(m map[float64]bool) Float64BoolConcurrentMapOption {
	return func(cm *Float64BoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64BoolConcurrentMap(opts ...Float64BoolConcurrentMapOption) *Float64BoolConcurrentMap {
	cm := &Float64BoolConcurrentMap{
		m: make(map[float64]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64BoolMapKeyValue struct {
	Key   float64
	Value bool
}

type Float64BoolConcurrentMap struct {
	m map[float64]bool
	L *sync.RWMutex
}

func (cm *Float64BoolConcurrentMap) Get(k float64) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64BoolConcurrentMap) GetDefault(k float64, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64BoolConcurrentMap) GetOK(k float64) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64BoolConcurrentMap) Set(k float64, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64BoolConcurrentMap) Delete(k float64) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64BoolConcurrentMap) SetKeyValues(kvs ...Float64BoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64BoolConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64BoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64BoolConcurrentMap) KeyValues() []Float64BoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64BoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64BoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64BoolConcurrentMap) ToUnsafeMap() map[float64]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type Float64StringKeyValue struct {
	Key   float64
	Value string
}

type Float64StringConcurrentMapOption func(*Float64StringConcurrentMap)

func WithUnsafeFloat64StringMap(m map[float64]string) Float64StringConcurrentMapOption {
	return func(cm *Float64StringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithFloat64StringMap(m map[float64]string) Float64StringConcurrentMapOption {
	return func(cm *Float64StringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewFloat64StringConcurrentMap(opts ...Float64StringConcurrentMapOption) *Float64StringConcurrentMap {
	cm := &Float64StringConcurrentMap{
		m: make(map[float64]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type Float64StringMapKeyValue struct {
	Key   float64
	Value string
}

type Float64StringConcurrentMap struct {
	m map[float64]string
	L *sync.RWMutex
}

func (cm *Float64StringConcurrentMap) Get(k float64) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *Float64StringConcurrentMap) GetDefault(k float64, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *Float64StringConcurrentMap) GetOK(k float64) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *Float64StringConcurrentMap) Set(k float64, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *Float64StringConcurrentMap) Delete(k float64) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *Float64StringConcurrentMap) SetKeyValues(kvs ...Float64StringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *Float64StringConcurrentMap) Keys() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []float64
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *Float64StringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *Float64StringConcurrentMap) KeyValues() []Float64StringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []Float64StringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, Float64StringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *Float64StringConcurrentMap) ToUnsafeMap() map[float64]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[float64]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringByteKeyValue struct {
	Key   string
	Value byte
}

type StringByteConcurrentMapOption func(*StringByteConcurrentMap)

func WithUnsafeStringByteMap(m map[string]byte) StringByteConcurrentMapOption {
	return func(cm *StringByteConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringByteMap(m map[string]byte) StringByteConcurrentMapOption {
	return func(cm *StringByteConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringByteConcurrentMap(opts ...StringByteConcurrentMapOption) *StringByteConcurrentMap {
	cm := &StringByteConcurrentMap{
		m: make(map[string]byte),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringByteMapKeyValue struct {
	Key   string
	Value byte
}

type StringByteConcurrentMap struct {
	m map[string]byte
	L *sync.RWMutex
}

func (cm *StringByteConcurrentMap) Get(k string) byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringByteConcurrentMap) GetDefault(k string, create func() (byte, error)) (byte, error) {
	var v byte
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringByteConcurrentMap) GetOK(k string) (byte, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringByteConcurrentMap) Set(k string, v byte) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringByteConcurrentMap) Delete(k string) (byte, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringByteConcurrentMap) SetKeyValues(kvs ...StringByteKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringByteConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringByteConcurrentMap) Values() []byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []byte
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringByteConcurrentMap) KeyValues() []StringByteKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringByteKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringByteKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringByteConcurrentMap) ToUnsafeMap() map[string]byte {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]byte)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringRuneKeyValue struct {
	Key   string
	Value rune
}

type StringRuneConcurrentMapOption func(*StringRuneConcurrentMap)

func WithUnsafeStringRuneMap(m map[string]rune) StringRuneConcurrentMapOption {
	return func(cm *StringRuneConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringRuneMap(m map[string]rune) StringRuneConcurrentMapOption {
	return func(cm *StringRuneConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringRuneConcurrentMap(opts ...StringRuneConcurrentMapOption) *StringRuneConcurrentMap {
	cm := &StringRuneConcurrentMap{
		m: make(map[string]rune),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringRuneMapKeyValue struct {
	Key   string
	Value rune
}

type StringRuneConcurrentMap struct {
	m map[string]rune
	L *sync.RWMutex
}

func (cm *StringRuneConcurrentMap) Get(k string) rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringRuneConcurrentMap) GetDefault(k string, create func() (rune, error)) (rune, error) {
	var v rune
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringRuneConcurrentMap) GetOK(k string) (rune, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringRuneConcurrentMap) Set(k string, v rune) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringRuneConcurrentMap) Delete(k string) (rune, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringRuneConcurrentMap) SetKeyValues(kvs ...StringRuneKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringRuneConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringRuneConcurrentMap) Values() []rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []rune
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringRuneConcurrentMap) KeyValues() []StringRuneKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringRuneKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringRuneKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringRuneConcurrentMap) ToUnsafeMap() map[string]rune {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]rune)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringUintKeyValue struct {
	Key   string
	Value uint
}

type StringUintConcurrentMapOption func(*StringUintConcurrentMap)

func WithUnsafeStringUintMap(m map[string]uint) StringUintConcurrentMapOption {
	return func(cm *StringUintConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringUintMap(m map[string]uint) StringUintConcurrentMapOption {
	return func(cm *StringUintConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringUintConcurrentMap(opts ...StringUintConcurrentMapOption) *StringUintConcurrentMap {
	cm := &StringUintConcurrentMap{
		m: make(map[string]uint),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringUintMapKeyValue struct {
	Key   string
	Value uint
}

type StringUintConcurrentMap struct {
	m map[string]uint
	L *sync.RWMutex
}

func (cm *StringUintConcurrentMap) Get(k string) uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringUintConcurrentMap) GetDefault(k string, create func() (uint, error)) (uint, error) {
	var v uint
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringUintConcurrentMap) GetOK(k string) (uint, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringUintConcurrentMap) Set(k string, v uint) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringUintConcurrentMap) Delete(k string) (uint, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringUintConcurrentMap) SetKeyValues(kvs ...StringUintKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringUintConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringUintConcurrentMap) Values() []uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringUintConcurrentMap) KeyValues() []StringUintKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringUintKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringUintKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringUintConcurrentMap) ToUnsafeMap() map[string]uint {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]uint)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringUint8KeyValue struct {
	Key   string
	Value uint8
}

type StringUint8ConcurrentMapOption func(*StringUint8ConcurrentMap)

func WithUnsafeStringUint8Map(m map[string]uint8) StringUint8ConcurrentMapOption {
	return func(cm *StringUint8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringUint8Map(m map[string]uint8) StringUint8ConcurrentMapOption {
	return func(cm *StringUint8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringUint8ConcurrentMap(opts ...StringUint8ConcurrentMapOption) *StringUint8ConcurrentMap {
	cm := &StringUint8ConcurrentMap{
		m: make(map[string]uint8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringUint8MapKeyValue struct {
	Key   string
	Value uint8
}

type StringUint8ConcurrentMap struct {
	m map[string]uint8
	L *sync.RWMutex
}

func (cm *StringUint8ConcurrentMap) Get(k string) uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringUint8ConcurrentMap) GetDefault(k string, create func() (uint8, error)) (uint8, error) {
	var v uint8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringUint8ConcurrentMap) GetOK(k string) (uint8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringUint8ConcurrentMap) Set(k string, v uint8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringUint8ConcurrentMap) Delete(k string) (uint8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringUint8ConcurrentMap) SetKeyValues(kvs ...StringUint8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringUint8ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringUint8ConcurrentMap) Values() []uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringUint8ConcurrentMap) KeyValues() []StringUint8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringUint8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringUint8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringUint8ConcurrentMap) ToUnsafeMap() map[string]uint8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]uint8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringUint16KeyValue struct {
	Key   string
	Value uint16
}

type StringUint16ConcurrentMapOption func(*StringUint16ConcurrentMap)

func WithUnsafeStringUint16Map(m map[string]uint16) StringUint16ConcurrentMapOption {
	return func(cm *StringUint16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringUint16Map(m map[string]uint16) StringUint16ConcurrentMapOption {
	return func(cm *StringUint16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringUint16ConcurrentMap(opts ...StringUint16ConcurrentMapOption) *StringUint16ConcurrentMap {
	cm := &StringUint16ConcurrentMap{
		m: make(map[string]uint16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringUint16MapKeyValue struct {
	Key   string
	Value uint16
}

type StringUint16ConcurrentMap struct {
	m map[string]uint16
	L *sync.RWMutex
}

func (cm *StringUint16ConcurrentMap) Get(k string) uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringUint16ConcurrentMap) GetDefault(k string, create func() (uint16, error)) (uint16, error) {
	var v uint16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringUint16ConcurrentMap) GetOK(k string) (uint16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringUint16ConcurrentMap) Set(k string, v uint16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringUint16ConcurrentMap) Delete(k string) (uint16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringUint16ConcurrentMap) SetKeyValues(kvs ...StringUint16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringUint16ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringUint16ConcurrentMap) Values() []uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringUint16ConcurrentMap) KeyValues() []StringUint16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringUint16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringUint16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringUint16ConcurrentMap) ToUnsafeMap() map[string]uint16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]uint16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringInterfaceKeyValue struct {
	Key   string
	Value Interface
}

type StringInterfaceConcurrentMapOption func(*StringInterfaceConcurrentMap)

func WithUnsafeStringInterfaceMap(m map[string]Interface) StringInterfaceConcurrentMapOption {
	return func(cm *StringInterfaceConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringInterfaceMap(m map[string]Interface) StringInterfaceConcurrentMapOption {
	return func(cm *StringInterfaceConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringInterfaceConcurrentMap(opts ...StringInterfaceConcurrentMapOption) *StringInterfaceConcurrentMap {
	cm := &StringInterfaceConcurrentMap{
		m: make(map[string]Interface),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringInterfaceMapKeyValue struct {
	Key   string
	Value Interface
}

type StringInterfaceConcurrentMap struct {
	m map[string]Interface
	L *sync.RWMutex
}

func (cm *StringInterfaceConcurrentMap) Get(k string) Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringInterfaceConcurrentMap) GetDefault(k string, create func() (Interface, error)) (Interface, error) {
	var v Interface
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringInterfaceConcurrentMap) GetOK(k string) (Interface, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringInterfaceConcurrentMap) Set(k string, v Interface) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringInterfaceConcurrentMap) Delete(k string) (Interface, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringInterfaceConcurrentMap) SetKeyValues(kvs ...StringInterfaceKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringInterfaceConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringInterfaceConcurrentMap) Values() []Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Interface
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringInterfaceConcurrentMap) KeyValues() []StringInterfaceKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringInterfaceKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringInterfaceKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringInterfaceConcurrentMap) ToUnsafeMap() map[string]Interface {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]Interface)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringUint32KeyValue struct {
	Key   string
	Value uint32
}

type StringUint32ConcurrentMapOption func(*StringUint32ConcurrentMap)

func WithUnsafeStringUint32Map(m map[string]uint32) StringUint32ConcurrentMapOption {
	return func(cm *StringUint32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringUint32Map(m map[string]uint32) StringUint32ConcurrentMapOption {
	return func(cm *StringUint32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringUint32ConcurrentMap(opts ...StringUint32ConcurrentMapOption) *StringUint32ConcurrentMap {
	cm := &StringUint32ConcurrentMap{
		m: make(map[string]uint32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringUint32MapKeyValue struct {
	Key   string
	Value uint32
}

type StringUint32ConcurrentMap struct {
	m map[string]uint32
	L *sync.RWMutex
}

func (cm *StringUint32ConcurrentMap) Get(k string) uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringUint32ConcurrentMap) GetDefault(k string, create func() (uint32, error)) (uint32, error) {
	var v uint32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringUint32ConcurrentMap) GetOK(k string) (uint32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringUint32ConcurrentMap) Set(k string, v uint32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringUint32ConcurrentMap) Delete(k string) (uint32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringUint32ConcurrentMap) SetKeyValues(kvs ...StringUint32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringUint32ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringUint32ConcurrentMap) Values() []uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringUint32ConcurrentMap) KeyValues() []StringUint32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringUint32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringUint32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringUint32ConcurrentMap) ToUnsafeMap() map[string]uint32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]uint32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringUint64KeyValue struct {
	Key   string
	Value uint64
}

type StringUint64ConcurrentMapOption func(*StringUint64ConcurrentMap)

func WithUnsafeStringUint64Map(m map[string]uint64) StringUint64ConcurrentMapOption {
	return func(cm *StringUint64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringUint64Map(m map[string]uint64) StringUint64ConcurrentMapOption {
	return func(cm *StringUint64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringUint64ConcurrentMap(opts ...StringUint64ConcurrentMapOption) *StringUint64ConcurrentMap {
	cm := &StringUint64ConcurrentMap{
		m: make(map[string]uint64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringUint64MapKeyValue struct {
	Key   string
	Value uint64
}

type StringUint64ConcurrentMap struct {
	m map[string]uint64
	L *sync.RWMutex
}

func (cm *StringUint64ConcurrentMap) Get(k string) uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringUint64ConcurrentMap) GetDefault(k string, create func() (uint64, error)) (uint64, error) {
	var v uint64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringUint64ConcurrentMap) GetOK(k string) (uint64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringUint64ConcurrentMap) Set(k string, v uint64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringUint64ConcurrentMap) Delete(k string) (uint64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringUint64ConcurrentMap) SetKeyValues(kvs ...StringUint64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringUint64ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringUint64ConcurrentMap) Values() []uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []uint64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringUint64ConcurrentMap) KeyValues() []StringUint64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringUint64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringUint64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringUint64ConcurrentMap) ToUnsafeMap() map[string]uint64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]uint64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringIntKeyValue struct {
	Key   string
	Value int
}

type StringIntConcurrentMapOption func(*StringIntConcurrentMap)

func WithUnsafeStringIntMap(m map[string]int) StringIntConcurrentMapOption {
	return func(cm *StringIntConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringIntMap(m map[string]int) StringIntConcurrentMapOption {
	return func(cm *StringIntConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringIntConcurrentMap(opts ...StringIntConcurrentMapOption) *StringIntConcurrentMap {
	cm := &StringIntConcurrentMap{
		m: make(map[string]int),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringIntMapKeyValue struct {
	Key   string
	Value int
}

type StringIntConcurrentMap struct {
	m map[string]int
	L *sync.RWMutex
}

func (cm *StringIntConcurrentMap) Get(k string) int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringIntConcurrentMap) GetDefault(k string, create func() (int, error)) (int, error) {
	var v int
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringIntConcurrentMap) GetOK(k string) (int, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringIntConcurrentMap) Set(k string, v int) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringIntConcurrentMap) Delete(k string) (int, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringIntConcurrentMap) SetKeyValues(kvs ...StringIntKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringIntConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringIntConcurrentMap) Values() []int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringIntConcurrentMap) KeyValues() []StringIntKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringIntKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringIntKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringIntConcurrentMap) ToUnsafeMap() map[string]int {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]int)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringInt8KeyValue struct {
	Key   string
	Value int8
}

type StringInt8ConcurrentMapOption func(*StringInt8ConcurrentMap)

func WithUnsafeStringInt8Map(m map[string]int8) StringInt8ConcurrentMapOption {
	return func(cm *StringInt8ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringInt8Map(m map[string]int8) StringInt8ConcurrentMapOption {
	return func(cm *StringInt8ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringInt8ConcurrentMap(opts ...StringInt8ConcurrentMapOption) *StringInt8ConcurrentMap {
	cm := &StringInt8ConcurrentMap{
		m: make(map[string]int8),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringInt8MapKeyValue struct {
	Key   string
	Value int8
}

type StringInt8ConcurrentMap struct {
	m map[string]int8
	L *sync.RWMutex
}

func (cm *StringInt8ConcurrentMap) Get(k string) int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringInt8ConcurrentMap) GetDefault(k string, create func() (int8, error)) (int8, error) {
	var v int8
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringInt8ConcurrentMap) GetOK(k string) (int8, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringInt8ConcurrentMap) Set(k string, v int8) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringInt8ConcurrentMap) Delete(k string) (int8, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringInt8ConcurrentMap) SetKeyValues(kvs ...StringInt8KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringInt8ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringInt8ConcurrentMap) Values() []int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int8
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringInt8ConcurrentMap) KeyValues() []StringInt8KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringInt8KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringInt8KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringInt8ConcurrentMap) ToUnsafeMap() map[string]int8 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]int8)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringInt16KeyValue struct {
	Key   string
	Value int16
}

type StringInt16ConcurrentMapOption func(*StringInt16ConcurrentMap)

func WithUnsafeStringInt16Map(m map[string]int16) StringInt16ConcurrentMapOption {
	return func(cm *StringInt16ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringInt16Map(m map[string]int16) StringInt16ConcurrentMapOption {
	return func(cm *StringInt16ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringInt16ConcurrentMap(opts ...StringInt16ConcurrentMapOption) *StringInt16ConcurrentMap {
	cm := &StringInt16ConcurrentMap{
		m: make(map[string]int16),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringInt16MapKeyValue struct {
	Key   string
	Value int16
}

type StringInt16ConcurrentMap struct {
	m map[string]int16
	L *sync.RWMutex
}

func (cm *StringInt16ConcurrentMap) Get(k string) int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringInt16ConcurrentMap) GetDefault(k string, create func() (int16, error)) (int16, error) {
	var v int16
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringInt16ConcurrentMap) GetOK(k string) (int16, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringInt16ConcurrentMap) Set(k string, v int16) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringInt16ConcurrentMap) Delete(k string) (int16, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringInt16ConcurrentMap) SetKeyValues(kvs ...StringInt16KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringInt16ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringInt16ConcurrentMap) Values() []int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int16
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringInt16ConcurrentMap) KeyValues() []StringInt16KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringInt16KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringInt16KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringInt16ConcurrentMap) ToUnsafeMap() map[string]int16 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]int16)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringInt32KeyValue struct {
	Key   string
	Value int32
}

type StringInt32ConcurrentMapOption func(*StringInt32ConcurrentMap)

func WithUnsafeStringInt32Map(m map[string]int32) StringInt32ConcurrentMapOption {
	return func(cm *StringInt32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringInt32Map(m map[string]int32) StringInt32ConcurrentMapOption {
	return func(cm *StringInt32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringInt32ConcurrentMap(opts ...StringInt32ConcurrentMapOption) *StringInt32ConcurrentMap {
	cm := &StringInt32ConcurrentMap{
		m: make(map[string]int32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringInt32MapKeyValue struct {
	Key   string
	Value int32
}

type StringInt32ConcurrentMap struct {
	m map[string]int32
	L *sync.RWMutex
}

func (cm *StringInt32ConcurrentMap) Get(k string) int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringInt32ConcurrentMap) GetDefault(k string, create func() (int32, error)) (int32, error) {
	var v int32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringInt32ConcurrentMap) GetOK(k string) (int32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringInt32ConcurrentMap) Set(k string, v int32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringInt32ConcurrentMap) Delete(k string) (int32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringInt32ConcurrentMap) SetKeyValues(kvs ...StringInt32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringInt32ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringInt32ConcurrentMap) Values() []int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringInt32ConcurrentMap) KeyValues() []StringInt32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringInt32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringInt32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringInt32ConcurrentMap) ToUnsafeMap() map[string]int32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]int32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringInt64KeyValue struct {
	Key   string
	Value int64
}

type StringInt64ConcurrentMapOption func(*StringInt64ConcurrentMap)

func WithUnsafeStringInt64Map(m map[string]int64) StringInt64ConcurrentMapOption {
	return func(cm *StringInt64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringInt64Map(m map[string]int64) StringInt64ConcurrentMapOption {
	return func(cm *StringInt64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringInt64ConcurrentMap(opts ...StringInt64ConcurrentMapOption) *StringInt64ConcurrentMap {
	cm := &StringInt64ConcurrentMap{
		m: make(map[string]int64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringInt64MapKeyValue struct {
	Key   string
	Value int64
}

type StringInt64ConcurrentMap struct {
	m map[string]int64
	L *sync.RWMutex
}

func (cm *StringInt64ConcurrentMap) Get(k string) int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringInt64ConcurrentMap) GetDefault(k string, create func() (int64, error)) (int64, error) {
	var v int64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringInt64ConcurrentMap) GetOK(k string) (int64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringInt64ConcurrentMap) Set(k string, v int64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringInt64ConcurrentMap) Delete(k string) (int64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringInt64ConcurrentMap) SetKeyValues(kvs ...StringInt64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringInt64ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringInt64ConcurrentMap) Values() []int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []int64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringInt64ConcurrentMap) KeyValues() []StringInt64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringInt64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringInt64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringInt64ConcurrentMap) ToUnsafeMap() map[string]int64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]int64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringFloat32KeyValue struct {
	Key   string
	Value float32
}

type StringFloat32ConcurrentMapOption func(*StringFloat32ConcurrentMap)

func WithUnsafeStringFloat32Map(m map[string]float32) StringFloat32ConcurrentMapOption {
	return func(cm *StringFloat32ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringFloat32Map(m map[string]float32) StringFloat32ConcurrentMapOption {
	return func(cm *StringFloat32ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringFloat32ConcurrentMap(opts ...StringFloat32ConcurrentMapOption) *StringFloat32ConcurrentMap {
	cm := &StringFloat32ConcurrentMap{
		m: make(map[string]float32),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringFloat32MapKeyValue struct {
	Key   string
	Value float32
}

type StringFloat32ConcurrentMap struct {
	m map[string]float32
	L *sync.RWMutex
}

func (cm *StringFloat32ConcurrentMap) Get(k string) float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringFloat32ConcurrentMap) GetDefault(k string, create func() (float32, error)) (float32, error) {
	var v float32
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringFloat32ConcurrentMap) GetOK(k string) (float32, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringFloat32ConcurrentMap) Set(k string, v float32) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringFloat32ConcurrentMap) Delete(k string) (float32, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringFloat32ConcurrentMap) SetKeyValues(kvs ...StringFloat32KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringFloat32ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringFloat32ConcurrentMap) Values() []float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float32
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringFloat32ConcurrentMap) KeyValues() []StringFloat32KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringFloat32KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringFloat32KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringFloat32ConcurrentMap) ToUnsafeMap() map[string]float32 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]float32)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringFloat64KeyValue struct {
	Key   string
	Value float64
}

type StringFloat64ConcurrentMapOption func(*StringFloat64ConcurrentMap)

func WithUnsafeStringFloat64Map(m map[string]float64) StringFloat64ConcurrentMapOption {
	return func(cm *StringFloat64ConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringFloat64Map(m map[string]float64) StringFloat64ConcurrentMapOption {
	return func(cm *StringFloat64ConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringFloat64ConcurrentMap(opts ...StringFloat64ConcurrentMapOption) *StringFloat64ConcurrentMap {
	cm := &StringFloat64ConcurrentMap{
		m: make(map[string]float64),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringFloat64MapKeyValue struct {
	Key   string
	Value float64
}

type StringFloat64ConcurrentMap struct {
	m map[string]float64
	L *sync.RWMutex
}

func (cm *StringFloat64ConcurrentMap) Get(k string) float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringFloat64ConcurrentMap) GetDefault(k string, create func() (float64, error)) (float64, error) {
	var v float64
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringFloat64ConcurrentMap) GetOK(k string) (float64, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringFloat64ConcurrentMap) Set(k string, v float64) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringFloat64ConcurrentMap) Delete(k string) (float64, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringFloat64ConcurrentMap) SetKeyValues(kvs ...StringFloat64KeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringFloat64ConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringFloat64ConcurrentMap) Values() []float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []float64
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringFloat64ConcurrentMap) KeyValues() []StringFloat64KeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringFloat64KeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringFloat64KeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringFloat64ConcurrentMap) ToUnsafeMap() map[string]float64 {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]float64)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringTypeKeyValue struct {
	Key   string
	Value Type
}

type StringTypeConcurrentMapOption func(*StringTypeConcurrentMap)

func WithUnsafeStringTypeMap(m map[string]Type) StringTypeConcurrentMapOption {
	return func(cm *StringTypeConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringTypeMap(m map[string]Type) StringTypeConcurrentMapOption {
	return func(cm *StringTypeConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringTypeConcurrentMap(opts ...StringTypeConcurrentMapOption) *StringTypeConcurrentMap {
	cm := &StringTypeConcurrentMap{
		m: make(map[string]Type),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringTypeMapKeyValue struct {
	Key   string
	Value Type
}

type StringTypeConcurrentMap struct {
	m map[string]Type
	L *sync.RWMutex
}

func (cm *StringTypeConcurrentMap) Get(k string) Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringTypeConcurrentMap) GetDefault(k string, create func() (Type, error)) (Type, error) {
	var v Type
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringTypeConcurrentMap) GetOK(k string) (Type, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringTypeConcurrentMap) Set(k string, v Type) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringTypeConcurrentMap) Delete(k string) (Type, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringTypeConcurrentMap) SetKeyValues(kvs ...StringTypeKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringTypeConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringTypeConcurrentMap) Values() []Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []Type
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringTypeConcurrentMap) KeyValues() []StringTypeKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringTypeKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringTypeKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringTypeConcurrentMap) ToUnsafeMap() map[string]Type {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]Type)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringBoolKeyValue struct {
	Key   string
	Value bool
}

type StringBoolConcurrentMapOption func(*StringBoolConcurrentMap)

func WithUnsafeStringBoolMap(m map[string]bool) StringBoolConcurrentMapOption {
	return func(cm *StringBoolConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringBoolMap(m map[string]bool) StringBoolConcurrentMapOption {
	return func(cm *StringBoolConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringBoolConcurrentMap(opts ...StringBoolConcurrentMapOption) *StringBoolConcurrentMap {
	cm := &StringBoolConcurrentMap{
		m: make(map[string]bool),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringBoolMapKeyValue struct {
	Key   string
	Value bool
}

type StringBoolConcurrentMap struct {
	m map[string]bool
	L *sync.RWMutex
}

func (cm *StringBoolConcurrentMap) Get(k string) bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringBoolConcurrentMap) GetDefault(k string, create func() (bool, error)) (bool, error) {
	var v bool
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringBoolConcurrentMap) GetOK(k string) (bool, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringBoolConcurrentMap) Set(k string, v bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringBoolConcurrentMap) Delete(k string) (bool, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringBoolConcurrentMap) SetKeyValues(kvs ...StringBoolKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringBoolConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringBoolConcurrentMap) Values() []bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []bool
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringBoolConcurrentMap) KeyValues() []StringBoolKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringBoolKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringBoolKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringBoolConcurrentMap) ToUnsafeMap() map[string]bool {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]bool)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}

type StringStringKeyValue struct {
	Key   string
	Value string
}

type StringStringConcurrentMapOption func(*StringStringConcurrentMap)

func WithUnsafeStringStringMap(m map[string]string) StringStringConcurrentMapOption {
	return func(cm *StringStringConcurrentMap) {
		if cm == nil {
			return
		}
		cm.m = m
	}
}

func WithStringStringMap(m map[string]string) StringStringConcurrentMapOption {
	return func(cm *StringStringConcurrentMap) {
		if cm == nil || m == nil {
			return
		}
		cm.L.Lock()
		for k, v := range m {
			cm.m[k] = v
		}
		cm.L.Unlock()
	}
}

func NewStringStringConcurrentMap(opts ...StringStringConcurrentMapOption) *StringStringConcurrentMap {
	cm := &StringStringConcurrentMap{
		m: make(map[string]string),
		L: &sync.RWMutex{},
	}
	for _, opt := range opts {
		opt(cm)
	}
	return cm
}

type StringStringMapKeyValue struct {
	Key   string
	Value string
}

type StringStringConcurrentMap struct {
	m map[string]string
	L *sync.RWMutex
}

func (cm *StringStringConcurrentMap) Get(k string) string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v := cm.m[k]
	return v
}
func (cm *StringStringConcurrentMap) GetDefault(k string, create func() (string, error)) (string, error) {
	var v string
	var err error
	var ok bool
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok = cm.m[k]
	if ok {
		return v, nil
	}
	v, err = create()
	if err == nil {
		cm.m[k] = v
	}
	return v, err
}

func (cm *StringStringConcurrentMap) GetOK(k string) (string, bool) {
	cm.L.RLock()
	defer cm.L.RUnlock()
	v, ok := cm.m[k]
	return v, ok
}

func (cm *StringStringConcurrentMap) Set(k string, v string) {
	cm.L.Lock()
	defer cm.L.Unlock()
	cm.m[k] = v

}

func (cm *StringStringConcurrentMap) Delete(k string) (string, bool) {
	cm.L.Lock()
	defer cm.L.Unlock()
	v, ok := cm.m[k]
	if ok {
		delete(cm.m, k)
	}
	return v, ok
}

func (cm *StringStringConcurrentMap) SetKeyValues(kvs ...StringStringKeyValue) {
	cm.L.Lock()
	defer cm.L.Unlock()
	for _, kv := range kvs {
		cm.m[kv.Key] = kv.Value
	}
}

func (cm *StringStringConcurrentMap) Keys() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var keys []string
	for k := range cm.m {
		keys = append(keys, k)
	}
	return keys
}

func (cm *StringStringConcurrentMap) Values() []string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var values []string
	for _, v := range cm.m {
		values = append(values, v)
	}
	return values
}

func (cm *StringStringConcurrentMap) KeyValues() []StringStringKeyValue {
	cm.L.RLock()
	defer cm.L.RUnlock()
	var pairs []StringStringKeyValue
	for k, v := range cm.m {
		pairs = append(pairs, StringStringKeyValue{Key: k, Value: v})
	}
	return pairs
}

func (cm *StringStringConcurrentMap) ToUnsafeMap() map[string]string {
	cm.L.RLock()
	defer cm.L.RUnlock()
	m := make(map[string]string)
	for k, v := range cm.m {
		m[k] = v
	}
	return m
}
