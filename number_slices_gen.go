// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/noho-digital/genny

package collex

import (
	"errors"
	"fmt"
	"math/rand"
	"sort"
	"strings"
	"sync"
)

type ByteSlice []byte
type ByteSliceReduceOption func(*ByteSliceReduceOptions)
type ByteSliceReduceOptions struct {
	initial byte
}

type ByteSliceAsyncOption func(options *ByteSliceAsyncOptions)
type ByteSliceAsyncOptions struct {
	PoolSize int
}

func NewByteSlice(items ...byte) ByteSlice {
	slice := make(ByteSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialByte(t byte) ByteSliceReduceOption {
	return func(o *ByteSliceReduceOptions) {
		o.initial = t
	}
}

func WhereByteAll(pl ...func(byte) bool) func(byte) bool {
	return func(t byte) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereByteAny(pl ...func(byte) bool) func(byte) bool {
	return func(t byte) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereByteNot(p func(byte) bool) func(byte) bool {
	return func(t byte) bool {
		return !p(t)
	}
}

func (slice ByteSlice) Index(item byte) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice ByteSlice) Map(fn func(byte) byte) ByteSlice {
	mapped := make(ByteSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice ByteSlice) AsyncMap(fn func(byte) byte, options ...ByteSliceAsyncOption) ByteSlice {
	output := make(ByteSlice, len(slice))
	eachFn := func(t byte, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice ByteSlice) MapString(fn func(byte) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice ByteSlice) AsyncMapString(fn func(byte) string, options ...ByteSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t byte, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice ByteSlice) MapBool(fn func(byte) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice ByteSlice) AsyncMapBool(fn func(byte) bool, options ...ByteSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t byte, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice ByteSlice) Reversed() ByteSlice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice ByteSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice ByteSlice) Item(index int) (item byte, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice ByteSlice) ReverseSelect(where func(byte) bool, ands ...func(byte) bool) ByteSlice {
	if len(ands) > 0 {
		where = WhereByteAll(append([]func(byte) bool{where}, ands...)...)
	}
	var selected ByteSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice ByteSlice) First(where ...func(byte) bool) byte {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereByteAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none byte
	return none
}

func (slice ByteSlice) Last(where ...func(byte) bool) byte {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereByteAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none byte
	return none
}
func (slice ByteSlice) FirstIndex(p func(byte) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice ByteSlice) Filter(p func(byte) bool) ByteSlice {
	var selected ByteSlice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice ByteSlice) IndexSelect(p func(byte) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice ByteSlice) SelectAsync(p func(byte) bool) ByteSlice {
	var selected ByteSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice ByteSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice ByteSlice) Strings() []string {
	return slice.MapString(func(x byte) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice ByteSlice) Reject(p func(byte) bool) ByteSlice {
	return slice.Filter(func(n byte) bool { return !p(n) })
}

func (slice ByteSlice) RejectAsync(p func(byte) bool) ByteSlice {
	return slice.SelectAsync(func(n byte) bool { return !p(n) })
}

func (slice ByteSlice) Reduce(operator func(byte, byte) byte, options ...ByteSliceReduceOption) byte {
	o := &ByteSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice ByteSlice) Append(items ...byte) ByteSlice {
	if slice == nil {
		var empty ByteSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice ByteSlice) Any(pl ...func(byte) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereByteAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice ByteSlice) AnyNot(pl ...func(byte) bool) bool {
	return !slice.Any(pl...)
}

func (slice ByteSlice) All(p func(byte) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice ByteSlice) AllNot(p func(byte) bool) bool {
	return !slice.All(p)
}

func (slice ByteSlice) Copy() ByteSlice {
	cp := make(ByteSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice ByteSlice) Empty() bool {
	return len(slice) == 0
}

func (slice ByteSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice ByteSlice) Count(p func(byte) bool) int {
	return len(slice.Filter(p))
}

func (slice ByteSlice) Max() byte {
	return slice.Reduce(ByteMax)
}

func ByteMax(c1 byte, c2 byte) byte {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice ByteSlice) Min() byte {
	return slice.Reduce(ByteMin)
}

func ByteMin(c1 byte, c2 byte) byte {
	if ByteMax(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of ByteSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice ByteSlice) MaxBy(less func(byte, byte) bool) (result byte, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of ByteSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice ByteSlice) MinBy(less func(byte, byte) bool) (result byte, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice ByteSlice) Average() (byte, error) {
	return ByteAverage(slice)
}

func ByteAverage(slice ByteSlice) (byte, error) {
	var result byte
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / byte(l)
	return result, nil
}

func (slice ByteSlice) AverageFloat64() (float64, error) {
	return ByteAverageFloat64(slice)
}

func ByteAverageFloat64(slice ByteSlice) (float64, error) {
	var result byte
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice ByteSlice) Distinct() ByteSlice {
	var result ByteSlice
	appended := make(map[byte]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice ByteSlice) DistinctBy(fn func(byte, byte) bool) (result ByteSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice ByteSlice) Each(f func(byte)) {
	for _, t := range slice {
		f(t)
	}
}

func WithByteAsyncPoolSize(size int) ByteSliceAsyncOption {
	return func(options *ByteSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newByteSliceAsyncOptions(opts ...ByteSliceAsyncOption) *ByteSliceAsyncOptions {
	o := &ByteSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice ByteSlice) AsyncEachIndex(f func(byte, int), options ...ByteSliceAsyncOption) {
	o := newByteSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item byte, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice ByteSlice, f func(byte, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice ByteSlice) AsyncEach(f func(byte), options ...ByteSliceAsyncOption) {
	slice.AsyncEachIndex(func(t byte, _ int) {
		f(t)
	}, options...)
}

func (slice ByteSlice) EachIndex(f func(byte, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice ByteSlice) Equal(other []byte) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice ByteSlice) Len() int {
	return len(slice)
}

func (slice ByteSlice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice ByteSlice) Replace(fn func(t byte) byte) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice ByteSlice) AsyncReplace(fn func(t byte) byte, options ...ByteSliceAsyncOption) {
	slice.AsyncEachIndex(func(t byte, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice ByteSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice ByteSlice) Sum() (result byte) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of ByteSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice ByteSlice) Shuffled() ByteSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of ByteSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice ByteSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice ByteSlice) Sort() {
	sort.Sort(slice)
}

func (slice ByteSlice) Sorted() ByteSlice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice ByteSlice) SortDesc() {
	sort.Sort(__ByteSliceDesc(slice))
}

func (slice ByteSlice) SortedDesc() ByteSlice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice ByteSlice) SortedBy(less func(byte, byte) bool) ByteSlice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice ByteSlice) SortBy(less func(byte, byte) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortByteSlice(slice, less, 0, n, maxDepth)
}

func (slice ByteSlice) IsSortedBy(less func(byte, byte) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice ByteSlice) SortDescBy(less func(byte, byte) bool) {
	slice.SortBy(func(a byte, b byte) bool { return !less(a, b) })
}

func (slice ByteSlice) SortedDescBy(less func(byte, byte) bool) ByteSlice {
	greater := func(a, b byte) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice ByteSlice) Split(fn func(n byte) bool) (ByteSlice, ByteSlice) {
	var a ByteSlice
	var b ByteSlice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice ByteSlice) IsSortedDescBy(less func(byte, byte) bool) bool {
	greater := func(a, b byte) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice ByteSlice) AnyGreater(n byte) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice ByteSlice) AnyLess(n byte) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice ByteSlice) AnyGreaterEqual(n byte) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice ByteSlice) AnyLessEqual(n byte) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice ByteSlice) AnyEqual(n byte) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice ByteSlice) ContainsAll(items ...byte) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice ByteSlice) ContainsAny(items ...byte) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice ByteSlice) Contains(n byte) bool {
	return slice.AnyEqual(n)
}

func (slice ByteSlice) SkipTake(skip, take int) ByteSlice {
	var out ByteSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapByteSlice(slice ByteSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortByteSlice(slice ByteSlice, less func(byte, byte) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapByteSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownByteSlice(slice ByteSlice, less func(byte, byte) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapByteSlice(slice, first+root, first+child)
		root = child
	}
}
func heapSortByteSlice(slice ByteSlice, less func(byte, byte) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownByteSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapByteSlice(slice, first, first+i)
		siftDownByteSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeByteSlice(slice ByteSlice, less func(byte, byte) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapByteSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapByteSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapByteSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeByteSlice(slice ByteSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapByteSlice(slice, a+i, b+i)
	}
}
func doPivotByteSlice(slice ByteSlice, less func(byte, byte) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeByteSlice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeByteSlice(slice, less, m, m-s, m+s)
		medianOfThreeByteSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeByteSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapByteSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapByteSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapByteSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeByteSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeByteSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortByteSlice(slice ByteSlice, less func(byte, byte) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortByteSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotByteSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortByteSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortByteSlice(slice, mhi, b)
		} else {
			quickSortByteSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortByteSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortByteSlice(slice, less, a, b)
	}
}

type __ByteSliceDesc []byte

func (slice __ByteSliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __ByteSliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __ByteSliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type RuneSlice []rune
type RuneSliceReduceOption func(*RuneSliceReduceOptions)
type RuneSliceReduceOptions struct {
	initial rune
}

type RuneSliceAsyncOption func(options *RuneSliceAsyncOptions)
type RuneSliceAsyncOptions struct {
	PoolSize int
}

func NewRuneSlice(items ...rune) RuneSlice {
	slice := make(RuneSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialRune(t rune) RuneSliceReduceOption {
	return func(o *RuneSliceReduceOptions) {
		o.initial = t
	}
}

func WhereRuneAll(pl ...func(rune) bool) func(rune) bool {
	return func(t rune) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereRuneAny(pl ...func(rune) bool) func(rune) bool {
	return func(t rune) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereRuneNot(p func(rune) bool) func(rune) bool {
	return func(t rune) bool {
		return !p(t)
	}
}

func (slice RuneSlice) Index(item rune) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice RuneSlice) Map(fn func(rune) rune) RuneSlice {
	mapped := make(RuneSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice RuneSlice) AsyncMap(fn func(rune) rune, options ...RuneSliceAsyncOption) RuneSlice {
	output := make(RuneSlice, len(slice))
	eachFn := func(t rune, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice RuneSlice) MapString(fn func(rune) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice RuneSlice) AsyncMapString(fn func(rune) string, options ...RuneSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t rune, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice RuneSlice) MapBool(fn func(rune) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice RuneSlice) AsyncMapBool(fn func(rune) bool, options ...RuneSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t rune, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice RuneSlice) Reversed() RuneSlice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice RuneSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice RuneSlice) Item(index int) (item rune, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice RuneSlice) ReverseSelect(where func(rune) bool, ands ...func(rune) bool) RuneSlice {
	if len(ands) > 0 {
		where = WhereRuneAll(append([]func(rune) bool{where}, ands...)...)
	}
	var selected RuneSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice RuneSlice) First(where ...func(rune) bool) rune {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereRuneAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none rune
	return none
}

func (slice RuneSlice) Last(where ...func(rune) bool) rune {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereRuneAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none rune
	return none
}
func (slice RuneSlice) FirstIndex(p func(rune) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice RuneSlice) Filter(p func(rune) bool) RuneSlice {
	var selected RuneSlice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice RuneSlice) IndexSelect(p func(rune) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice RuneSlice) SelectAsync(p func(rune) bool) RuneSlice {
	var selected RuneSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice RuneSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice RuneSlice) Strings() []string {
	return slice.MapString(func(x rune) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice RuneSlice) Reject(p func(rune) bool) RuneSlice {
	return slice.Filter(func(n rune) bool { return !p(n) })
}

func (slice RuneSlice) RejectAsync(p func(rune) bool) RuneSlice {
	return slice.SelectAsync(func(n rune) bool { return !p(n) })
}

func (slice RuneSlice) Reduce(operator func(rune, rune) rune, options ...RuneSliceReduceOption) rune {
	o := &RuneSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice RuneSlice) Append(items ...rune) RuneSlice {
	if slice == nil {
		var empty RuneSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice RuneSlice) Any(pl ...func(rune) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereRuneAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice RuneSlice) AnyNot(pl ...func(rune) bool) bool {
	return !slice.Any(pl...)
}

func (slice RuneSlice) All(p func(rune) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice RuneSlice) AllNot(p func(rune) bool) bool {
	return !slice.All(p)
}

func (slice RuneSlice) Copy() RuneSlice {
	cp := make(RuneSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice RuneSlice) Empty() bool {
	return len(slice) == 0
}

func (slice RuneSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice RuneSlice) Count(p func(rune) bool) int {
	return len(slice.Filter(p))
}

func (slice RuneSlice) Max() rune {
	return slice.Reduce(RuneMax)
}

func RuneMax(c1 rune, c2 rune) rune {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice RuneSlice) Min() rune {
	return slice.Reduce(RuneMin)
}

func RuneMin(c1 rune, c2 rune) rune {
	if RuneMax(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of RuneSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice RuneSlice) MaxBy(less func(rune, rune) bool) (result rune, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of RuneSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice RuneSlice) MinBy(less func(rune, rune) bool) (result rune, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice RuneSlice) Average() (rune, error) {
	return RuneAverage(slice)
}

func RuneAverage(slice RuneSlice) (rune, error) {
	var result rune
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / rune(l)
	return result, nil
}

func (slice RuneSlice) AverageFloat64() (float64, error) {
	return RuneAverageFloat64(slice)
}

func RuneAverageFloat64(slice RuneSlice) (float64, error) {
	var result rune
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice RuneSlice) Distinct() RuneSlice {
	var result RuneSlice
	appended := make(map[rune]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice RuneSlice) DistinctBy(fn func(rune, rune) bool) (result RuneSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice RuneSlice) Each(f func(rune)) {
	for _, t := range slice {
		f(t)
	}
}

func WithRuneAsyncPoolSize(size int) RuneSliceAsyncOption {
	return func(options *RuneSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newRuneSliceAsyncOptions(opts ...RuneSliceAsyncOption) *RuneSliceAsyncOptions {
	o := &RuneSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice RuneSlice) AsyncEachIndex(f func(rune, int), options ...RuneSliceAsyncOption) {
	o := newRuneSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item rune, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice RuneSlice, f func(rune, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice RuneSlice) AsyncEach(f func(rune), options ...RuneSliceAsyncOption) {
	slice.AsyncEachIndex(func(t rune, _ int) {
		f(t)
	}, options...)
}

func (slice RuneSlice) EachIndex(f func(rune, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice RuneSlice) Equal(other []rune) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice RuneSlice) Len() int {
	return len(slice)
}

func (slice RuneSlice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice RuneSlice) Replace(fn func(t rune) rune) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice RuneSlice) AsyncReplace(fn func(t rune) rune, options ...RuneSliceAsyncOption) {
	slice.AsyncEachIndex(func(t rune, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice RuneSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice RuneSlice) Sum() (result rune) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of RuneSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice RuneSlice) Shuffled() RuneSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of RuneSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice RuneSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice RuneSlice) Sort() {
	sort.Sort(slice)
}

func (slice RuneSlice) Sorted() RuneSlice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice RuneSlice) SortDesc() {
	sort.Sort(__RuneSliceDesc(slice))
}

func (slice RuneSlice) SortedDesc() RuneSlice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice RuneSlice) SortedBy(less func(rune, rune) bool) RuneSlice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice RuneSlice) SortBy(less func(rune, rune) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortRuneSlice(slice, less, 0, n, maxDepth)
}

func (slice RuneSlice) IsSortedBy(less func(rune, rune) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice RuneSlice) SortDescBy(less func(rune, rune) bool) {
	slice.SortBy(func(a rune, b rune) bool { return !less(a, b) })
}

func (slice RuneSlice) SortedDescBy(less func(rune, rune) bool) RuneSlice {
	greater := func(a, b rune) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice RuneSlice) Split(fn func(n rune) bool) (RuneSlice, RuneSlice) {
	var a RuneSlice
	var b RuneSlice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice RuneSlice) IsSortedDescBy(less func(rune, rune) bool) bool {
	greater := func(a, b rune) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice RuneSlice) AnyGreater(n rune) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice RuneSlice) AnyLess(n rune) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice RuneSlice) AnyGreaterEqual(n rune) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice RuneSlice) AnyLessEqual(n rune) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice RuneSlice) AnyEqual(n rune) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice RuneSlice) ContainsAll(items ...rune) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice RuneSlice) ContainsAny(items ...rune) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice RuneSlice) Contains(n rune) bool {
	return slice.AnyEqual(n)
}

func (slice RuneSlice) SkipTake(skip, take int) RuneSlice {
	var out RuneSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapRuneSlice(slice RuneSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortRuneSlice(slice RuneSlice, less func(rune, rune) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapRuneSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownRuneSlice(slice RuneSlice, less func(rune, rune) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapRuneSlice(slice, first+root, first+child)
		root = child
	}
}
func heapSortRuneSlice(slice RuneSlice, less func(rune, rune) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownRuneSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapRuneSlice(slice, first, first+i)
		siftDownRuneSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeRuneSlice(slice RuneSlice, less func(rune, rune) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapRuneSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapRuneSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapRuneSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeRuneSlice(slice RuneSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapRuneSlice(slice, a+i, b+i)
	}
}
func doPivotRuneSlice(slice RuneSlice, less func(rune, rune) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeRuneSlice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeRuneSlice(slice, less, m, m-s, m+s)
		medianOfThreeRuneSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeRuneSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapRuneSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapRuneSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapRuneSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeRuneSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeRuneSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortRuneSlice(slice RuneSlice, less func(rune, rune) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortRuneSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotRuneSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortRuneSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortRuneSlice(slice, mhi, b)
		} else {
			quickSortRuneSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortRuneSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortRuneSlice(slice, less, a, b)
	}
}

type __RuneSliceDesc []rune

func (slice __RuneSliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __RuneSliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __RuneSliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type UintptrSlice []uintptr
type UintptrSliceReduceOption func(*UintptrSliceReduceOptions)
type UintptrSliceReduceOptions struct {
	initial uintptr
}

type UintptrSliceAsyncOption func(options *UintptrSliceAsyncOptions)
type UintptrSliceAsyncOptions struct {
	PoolSize int
}

func NewUintptrSlice(items ...uintptr) UintptrSlice {
	slice := make(UintptrSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUintptr(t uintptr) UintptrSliceReduceOption {
	return func(o *UintptrSliceReduceOptions) {
		o.initial = t
	}
}

func WhereUintptrAll(pl ...func(uintptr) bool) func(uintptr) bool {
	return func(t uintptr) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUintptrAny(pl ...func(uintptr) bool) func(uintptr) bool {
	return func(t uintptr) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUintptrNot(p func(uintptr) bool) func(uintptr) bool {
	return func(t uintptr) bool {
		return !p(t)
	}
}

func (slice UintptrSlice) Index(item uintptr) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice UintptrSlice) Map(fn func(uintptr) uintptr) UintptrSlice {
	mapped := make(UintptrSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintptrSlice) AsyncMap(fn func(uintptr) uintptr, options ...UintptrSliceAsyncOption) UintptrSlice {
	output := make(UintptrSlice, len(slice))
	eachFn := func(t uintptr, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintptrSlice) MapString(fn func(uintptr) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintptrSlice) AsyncMapString(fn func(uintptr) string, options ...UintptrSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uintptr, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintptrSlice) MapBool(fn func(uintptr) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintptrSlice) AsyncMapBool(fn func(uintptr) bool, options ...UintptrSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uintptr, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintptrSlice) Reversed() UintptrSlice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice UintptrSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice UintptrSlice) Item(index int) (item uintptr, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice UintptrSlice) ReverseSelect(where func(uintptr) bool, ands ...func(uintptr) bool) UintptrSlice {
	if len(ands) > 0 {
		where = WhereUintptrAll(append([]func(uintptr) bool{where}, ands...)...)
	}
	var selected UintptrSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintptrSlice) First(where ...func(uintptr) bool) uintptr {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUintptrAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uintptr
	return none
}

func (slice UintptrSlice) Last(where ...func(uintptr) bool) uintptr {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUintptrAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uintptr
	return none
}
func (slice UintptrSlice) FirstIndex(p func(uintptr) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice UintptrSlice) Filter(p func(uintptr) bool) UintptrSlice {
	var selected UintptrSlice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintptrSlice) IndexSelect(p func(uintptr) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice UintptrSlice) SelectAsync(p func(uintptr) bool) UintptrSlice {
	var selected UintptrSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintptrSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice UintptrSlice) Strings() []string {
	return slice.MapString(func(x uintptr) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice UintptrSlice) Reject(p func(uintptr) bool) UintptrSlice {
	return slice.Filter(func(n uintptr) bool { return !p(n) })
}

func (slice UintptrSlice) RejectAsync(p func(uintptr) bool) UintptrSlice {
	return slice.SelectAsync(func(n uintptr) bool { return !p(n) })
}

func (slice UintptrSlice) Reduce(operator func(uintptr, uintptr) uintptr, options ...UintptrSliceReduceOption) uintptr {
	o := &UintptrSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice UintptrSlice) Append(items ...uintptr) UintptrSlice {
	if slice == nil {
		var empty UintptrSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice UintptrSlice) Any(pl ...func(uintptr) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUintptrAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) AnyNot(pl ...func(uintptr) bool) bool {
	return !slice.Any(pl...)
}

func (slice UintptrSlice) All(p func(uintptr) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice UintptrSlice) AllNot(p func(uintptr) bool) bool {
	return !slice.All(p)
}

func (slice UintptrSlice) Copy() UintptrSlice {
	cp := make(UintptrSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice UintptrSlice) Empty() bool {
	return len(slice) == 0
}

func (slice UintptrSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice UintptrSlice) Count(p func(uintptr) bool) int {
	return len(slice.Filter(p))
}

func (slice UintptrSlice) Max() uintptr {
	return slice.Reduce(UintptrMax)
}

func UintptrMax(c1 uintptr, c2 uintptr) uintptr {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice UintptrSlice) Min() uintptr {
	return slice.Reduce(UintptrMin)
}

func UintptrMin(c1 uintptr, c2 uintptr) uintptr {
	if UintptrMax(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of UintptrSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice UintptrSlice) MaxBy(less func(uintptr, uintptr) bool) (result uintptr, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of UintptrSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice UintptrSlice) MinBy(less func(uintptr, uintptr) bool) (result uintptr, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice UintptrSlice) Average() (uintptr, error) {
	return UintptrAverage(slice)
}

func UintptrAverage(slice UintptrSlice) (uintptr, error) {
	var result uintptr
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uintptr(l)
	return result, nil
}

func (slice UintptrSlice) AverageFloat64() (float64, error) {
	return UintptrAverageFloat64(slice)
}

func UintptrAverageFloat64(slice UintptrSlice) (float64, error) {
	var result uintptr
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice UintptrSlice) Distinct() UintptrSlice {
	var result UintptrSlice
	appended := make(map[uintptr]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice UintptrSlice) DistinctBy(fn func(uintptr, uintptr) bool) (result UintptrSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice UintptrSlice) Each(f func(uintptr)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUintptrAsyncPoolSize(size int) UintptrSliceAsyncOption {
	return func(options *UintptrSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUintptrSliceAsyncOptions(opts ...UintptrSliceAsyncOption) *UintptrSliceAsyncOptions {
	o := &UintptrSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice UintptrSlice) AsyncEachIndex(f func(uintptr, int), options ...UintptrSliceAsyncOption) {
	o := newUintptrSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uintptr, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice UintptrSlice, f func(uintptr, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice UintptrSlice) AsyncEach(f func(uintptr), options ...UintptrSliceAsyncOption) {
	slice.AsyncEachIndex(func(t uintptr, _ int) {
		f(t)
	}, options...)
}

func (slice UintptrSlice) EachIndex(f func(uintptr, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice UintptrSlice) Equal(other []uintptr) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice UintptrSlice) Len() int {
	return len(slice)
}

func (slice UintptrSlice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice UintptrSlice) Replace(fn func(t uintptr) uintptr) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice UintptrSlice) AsyncReplace(fn func(t uintptr) uintptr, options ...UintptrSliceAsyncOption) {
	slice.AsyncEachIndex(func(t uintptr, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice UintptrSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice UintptrSlice) Sum() (result uintptr) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of UintptrSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice UintptrSlice) Shuffled() UintptrSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of UintptrSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice UintptrSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice UintptrSlice) Sort() {
	sort.Sort(slice)
}

func (slice UintptrSlice) Sorted() UintptrSlice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice UintptrSlice) SortDesc() {
	sort.Sort(__UintptrSliceDesc(slice))
}

func (slice UintptrSlice) SortedDesc() UintptrSlice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice UintptrSlice) SortedBy(less func(uintptr, uintptr) bool) UintptrSlice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice UintptrSlice) SortBy(less func(uintptr, uintptr) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUintptrSlice(slice, less, 0, n, maxDepth)
}

func (slice UintptrSlice) IsSortedBy(less func(uintptr, uintptr) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice UintptrSlice) SortDescBy(less func(uintptr, uintptr) bool) {
	slice.SortBy(func(a uintptr, b uintptr) bool { return !less(a, b) })
}

func (slice UintptrSlice) SortedDescBy(less func(uintptr, uintptr) bool) UintptrSlice {
	greater := func(a, b uintptr) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice UintptrSlice) Split(fn func(n uintptr) bool) (UintptrSlice, UintptrSlice) {
	var a UintptrSlice
	var b UintptrSlice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice UintptrSlice) IsSortedDescBy(less func(uintptr, uintptr) bool) bool {
	greater := func(a, b uintptr) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice UintptrSlice) AnyGreater(n uintptr) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) AnyLess(n uintptr) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) AnyGreaterEqual(n uintptr) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) AnyLessEqual(n uintptr) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) AnyEqual(n uintptr) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) ContainsAll(items ...uintptr) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice UintptrSlice) ContainsAny(items ...uintptr) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice UintptrSlice) Contains(n uintptr) bool {
	return slice.AnyEqual(n)
}

func (slice UintptrSlice) SkipTake(skip, take int) UintptrSlice {
	var out UintptrSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUintptrSlice(slice UintptrSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUintptrSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUintptrSlice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUintptrSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUintptrSlice(slice, first, first+i)
		siftDownUintptrSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUintptrSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUintptrSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUintptrSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUintptrSlice(slice UintptrSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUintptrSlice(slice, a+i, b+i)
	}
}
func doPivotUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUintptrSlice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUintptrSlice(slice, less, m, m-s, m+s)
		medianOfThreeUintptrSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUintptrSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUintptrSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUintptrSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUintptrSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUintptrSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUintptrSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUintptrSlice(slice UintptrSlice, less func(uintptr, uintptr) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUintptrSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUintptrSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUintptrSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUintptrSlice(slice, mhi, b)
		} else {
			quickSortUintptrSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUintptrSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUintptrSlice(slice, less, a, b)
	}
}

type __UintptrSliceDesc []uintptr

func (slice __UintptrSliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __UintptrSliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __UintptrSliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type UintSlice []uint
type UintSliceReduceOption func(*UintSliceReduceOptions)
type UintSliceReduceOptions struct {
	initial uint
}

type UintSliceAsyncOption func(options *UintSliceAsyncOptions)
type UintSliceAsyncOptions struct {
	PoolSize int
}

func NewUintSlice(items ...uint) UintSlice {
	slice := make(UintSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUint(t uint) UintSliceReduceOption {
	return func(o *UintSliceReduceOptions) {
		o.initial = t
	}
}

func WhereUintAll(pl ...func(uint) bool) func(uint) bool {
	return func(t uint) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUintAny(pl ...func(uint) bool) func(uint) bool {
	return func(t uint) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUintNot(p func(uint) bool) func(uint) bool {
	return func(t uint) bool {
		return !p(t)
	}
}

func (slice UintSlice) Index(item uint) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice UintSlice) Map(fn func(uint) uint) UintSlice {
	mapped := make(UintSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintSlice) AsyncMap(fn func(uint) uint, options ...UintSliceAsyncOption) UintSlice {
	output := make(UintSlice, len(slice))
	eachFn := func(t uint, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintSlice) MapString(fn func(uint) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintSlice) AsyncMapString(fn func(uint) string, options ...UintSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uint, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintSlice) MapBool(fn func(uint) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice UintSlice) AsyncMapBool(fn func(uint) bool, options ...UintSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uint, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice UintSlice) Reversed() UintSlice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice UintSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice UintSlice) Item(index int) (item uint, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice UintSlice) ReverseSelect(where func(uint) bool, ands ...func(uint) bool) UintSlice {
	if len(ands) > 0 {
		where = WhereUintAll(append([]func(uint) bool{where}, ands...)...)
	}
	var selected UintSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintSlice) First(where ...func(uint) bool) uint {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUintAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint
	return none
}

func (slice UintSlice) Last(where ...func(uint) bool) uint {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUintAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint
	return none
}
func (slice UintSlice) FirstIndex(p func(uint) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice UintSlice) Filter(p func(uint) bool) UintSlice {
	var selected UintSlice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintSlice) IndexSelect(p func(uint) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice UintSlice) SelectAsync(p func(uint) bool) UintSlice {
	var selected UintSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice UintSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice UintSlice) Strings() []string {
	return slice.MapString(func(x uint) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice UintSlice) Reject(p func(uint) bool) UintSlice {
	return slice.Filter(func(n uint) bool { return !p(n) })
}

func (slice UintSlice) RejectAsync(p func(uint) bool) UintSlice {
	return slice.SelectAsync(func(n uint) bool { return !p(n) })
}

func (slice UintSlice) Reduce(operator func(uint, uint) uint, options ...UintSliceReduceOption) uint {
	o := &UintSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice UintSlice) Append(items ...uint) UintSlice {
	if slice == nil {
		var empty UintSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice UintSlice) Any(pl ...func(uint) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUintAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice UintSlice) AnyNot(pl ...func(uint) bool) bool {
	return !slice.Any(pl...)
}

func (slice UintSlice) All(p func(uint) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice UintSlice) AllNot(p func(uint) bool) bool {
	return !slice.All(p)
}

func (slice UintSlice) Copy() UintSlice {
	cp := make(UintSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice UintSlice) Empty() bool {
	return len(slice) == 0
}

func (slice UintSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice UintSlice) Count(p func(uint) bool) int {
	return len(slice.Filter(p))
}

func (slice UintSlice) Max() uint {
	return slice.Reduce(UintMax)
}

func UintMax(c1 uint, c2 uint) uint {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice UintSlice) Min() uint {
	return slice.Reduce(UintMin)
}

func UintMin(c1 uint, c2 uint) uint {
	if UintMax(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of UintSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice UintSlice) MaxBy(less func(uint, uint) bool) (result uint, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of UintSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice UintSlice) MinBy(less func(uint, uint) bool) (result uint, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice UintSlice) Average() (uint, error) {
	return UintAverage(slice)
}

func UintAverage(slice UintSlice) (uint, error) {
	var result uint
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uint(l)
	return result, nil
}

func (slice UintSlice) AverageFloat64() (float64, error) {
	return UintAverageFloat64(slice)
}

func UintAverageFloat64(slice UintSlice) (float64, error) {
	var result uint
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice UintSlice) Distinct() UintSlice {
	var result UintSlice
	appended := make(map[uint]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice UintSlice) DistinctBy(fn func(uint, uint) bool) (result UintSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice UintSlice) Each(f func(uint)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUintAsyncPoolSize(size int) UintSliceAsyncOption {
	return func(options *UintSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUintSliceAsyncOptions(opts ...UintSliceAsyncOption) *UintSliceAsyncOptions {
	o := &UintSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice UintSlice) AsyncEachIndex(f func(uint, int), options ...UintSliceAsyncOption) {
	o := newUintSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uint, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice UintSlice, f func(uint, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice UintSlice) AsyncEach(f func(uint), options ...UintSliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint, _ int) {
		f(t)
	}, options...)
}

func (slice UintSlice) EachIndex(f func(uint, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice UintSlice) Equal(other []uint) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice UintSlice) Len() int {
	return len(slice)
}

func (slice UintSlice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice UintSlice) Replace(fn func(t uint) uint) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice UintSlice) AsyncReplace(fn func(t uint) uint, options ...UintSliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice UintSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice UintSlice) Sum() (result uint) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of UintSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice UintSlice) Shuffled() UintSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of UintSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice UintSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice UintSlice) Sort() {
	sort.Sort(slice)
}

func (slice UintSlice) Sorted() UintSlice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice UintSlice) SortDesc() {
	sort.Sort(__UintSliceDesc(slice))
}

func (slice UintSlice) SortedDesc() UintSlice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice UintSlice) SortedBy(less func(uint, uint) bool) UintSlice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice UintSlice) SortBy(less func(uint, uint) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUintSlice(slice, less, 0, n, maxDepth)
}

func (slice UintSlice) IsSortedBy(less func(uint, uint) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice UintSlice) SortDescBy(less func(uint, uint) bool) {
	slice.SortBy(func(a uint, b uint) bool { return !less(a, b) })
}

func (slice UintSlice) SortedDescBy(less func(uint, uint) bool) UintSlice {
	greater := func(a, b uint) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice UintSlice) Split(fn func(n uint) bool) (UintSlice, UintSlice) {
	var a UintSlice
	var b UintSlice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice UintSlice) IsSortedDescBy(less func(uint, uint) bool) bool {
	greater := func(a, b uint) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice UintSlice) AnyGreater(n uint) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice UintSlice) AnyLess(n uint) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice UintSlice) AnyGreaterEqual(n uint) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice UintSlice) AnyLessEqual(n uint) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice UintSlice) AnyEqual(n uint) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice UintSlice) ContainsAll(items ...uint) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice UintSlice) ContainsAny(items ...uint) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice UintSlice) Contains(n uint) bool {
	return slice.AnyEqual(n)
}

func (slice UintSlice) SkipTake(skip, take int) UintSlice {
	var out UintSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUintSlice(slice UintSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUintSlice(slice UintSlice, less func(uint, uint) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUintSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUintSlice(slice UintSlice, less func(uint, uint) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUintSlice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUintSlice(slice UintSlice, less func(uint, uint) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUintSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUintSlice(slice, first, first+i)
		siftDownUintSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUintSlice(slice UintSlice, less func(uint, uint) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUintSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUintSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUintSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUintSlice(slice UintSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUintSlice(slice, a+i, b+i)
	}
}
func doPivotUintSlice(slice UintSlice, less func(uint, uint) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUintSlice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUintSlice(slice, less, m, m-s, m+s)
		medianOfThreeUintSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUintSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUintSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUintSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUintSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUintSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUintSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUintSlice(slice UintSlice, less func(uint, uint) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUintSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUintSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUintSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUintSlice(slice, mhi, b)
		} else {
			quickSortUintSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUintSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUintSlice(slice, less, a, b)
	}
}

type __UintSliceDesc []uint

func (slice __UintSliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __UintSliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __UintSliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Uint8Slice []uint8
type Uint8SliceReduceOption func(*Uint8SliceReduceOptions)
type Uint8SliceReduceOptions struct {
	initial uint8
}

type Uint8SliceAsyncOption func(options *Uint8SliceAsyncOptions)
type Uint8SliceAsyncOptions struct {
	PoolSize int
}

func NewUint8Slice(items ...uint8) Uint8Slice {
	slice := make(Uint8Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUint8(t uint8) Uint8SliceReduceOption {
	return func(o *Uint8SliceReduceOptions) {
		o.initial = t
	}
}

func WhereUint8All(pl ...func(uint8) bool) func(uint8) bool {
	return func(t uint8) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUint8Any(pl ...func(uint8) bool) func(uint8) bool {
	return func(t uint8) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUint8Not(p func(uint8) bool) func(uint8) bool {
	return func(t uint8) bool {
		return !p(t)
	}
}

func (slice Uint8Slice) Index(item uint8) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Uint8Slice) Map(fn func(uint8) uint8) Uint8Slice {
	mapped := make(Uint8Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint8Slice) AsyncMap(fn func(uint8) uint8, options ...Uint8SliceAsyncOption) Uint8Slice {
	output := make(Uint8Slice, len(slice))
	eachFn := func(t uint8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint8Slice) MapString(fn func(uint8) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint8Slice) AsyncMapString(fn func(uint8) string, options ...Uint8SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uint8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint8Slice) MapBool(fn func(uint8) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint8Slice) AsyncMapBool(fn func(uint8) bool, options ...Uint8SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uint8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint8Slice) Reversed() Uint8Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Uint8Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Uint8Slice) Item(index int) (item uint8, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Uint8Slice) ReverseSelect(where func(uint8) bool, ands ...func(uint8) bool) Uint8Slice {
	if len(ands) > 0 {
		where = WhereUint8All(append([]func(uint8) bool{where}, ands...)...)
	}
	var selected Uint8Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint8Slice) First(where ...func(uint8) bool) uint8 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint8All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint8
	return none
}

func (slice Uint8Slice) Last(where ...func(uint8) bool) uint8 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint8All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint8
	return none
}
func (slice Uint8Slice) FirstIndex(p func(uint8) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Uint8Slice) Filter(p func(uint8) bool) Uint8Slice {
	var selected Uint8Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint8Slice) IndexSelect(p func(uint8) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Uint8Slice) SelectAsync(p func(uint8) bool) Uint8Slice {
	var selected Uint8Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint8Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Uint8Slice) Strings() []string {
	return slice.MapString(func(x uint8) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Uint8Slice) Reject(p func(uint8) bool) Uint8Slice {
	return slice.Filter(func(n uint8) bool { return !p(n) })
}

func (slice Uint8Slice) RejectAsync(p func(uint8) bool) Uint8Slice {
	return slice.SelectAsync(func(n uint8) bool { return !p(n) })
}

func (slice Uint8Slice) Reduce(operator func(uint8, uint8) uint8, options ...Uint8SliceReduceOption) uint8 {
	o := &Uint8SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Uint8Slice) Append(items ...uint8) Uint8Slice {
	if slice == nil {
		var empty Uint8Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Uint8Slice) Any(pl ...func(uint8) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUint8All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) AnyNot(pl ...func(uint8) bool) bool {
	return !slice.Any(pl...)
}

func (slice Uint8Slice) All(p func(uint8) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Uint8Slice) AllNot(p func(uint8) bool) bool {
	return !slice.All(p)
}

func (slice Uint8Slice) Copy() Uint8Slice {
	cp := make(Uint8Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Uint8Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Uint8Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Uint8Slice) Count(p func(uint8) bool) int {
	return len(slice.Filter(p))
}

func (slice Uint8Slice) Max() uint8 {
	return slice.Reduce(Uint8Max)
}

func Uint8Max(c1 uint8, c2 uint8) uint8 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Uint8Slice) Min() uint8 {
	return slice.Reduce(Uint8Min)
}

func Uint8Min(c1 uint8, c2 uint8) uint8 {
	if Uint8Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Uint8Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Uint8Slice) MaxBy(less func(uint8, uint8) bool) (result uint8, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Uint8Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Uint8Slice) MinBy(less func(uint8, uint8) bool) (result uint8, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Uint8Slice) Average() (uint8, error) {
	return Uint8Average(slice)
}

func Uint8Average(slice Uint8Slice) (uint8, error) {
	var result uint8
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uint8(l)
	return result, nil
}

func (slice Uint8Slice) AverageFloat64() (float64, error) {
	return Uint8AverageFloat64(slice)
}

func Uint8AverageFloat64(slice Uint8Slice) (float64, error) {
	var result uint8
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Uint8Slice) Distinct() Uint8Slice {
	var result Uint8Slice
	appended := make(map[uint8]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Uint8Slice) DistinctBy(fn func(uint8, uint8) bool) (result Uint8Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Uint8Slice) Each(f func(uint8)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUint8AsyncPoolSize(size int) Uint8SliceAsyncOption {
	return func(options *Uint8SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUint8SliceAsyncOptions(opts ...Uint8SliceAsyncOption) *Uint8SliceAsyncOptions {
	o := &Uint8SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Uint8Slice) AsyncEachIndex(f func(uint8, int), options ...Uint8SliceAsyncOption) {
	o := newUint8SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uint8, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Uint8Slice, f func(uint8, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Uint8Slice) AsyncEach(f func(uint8), options ...Uint8SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint8, _ int) {
		f(t)
	}, options...)
}

func (slice Uint8Slice) EachIndex(f func(uint8, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Uint8Slice) Equal(other []uint8) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Uint8Slice) Len() int {
	return len(slice)
}

func (slice Uint8Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Uint8Slice) Replace(fn func(t uint8) uint8) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Uint8Slice) AsyncReplace(fn func(t uint8) uint8, options ...Uint8SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint8, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Uint8Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Uint8Slice) Sum() (result uint8) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Uint8Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint8Slice) Shuffled() Uint8Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Uint8Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint8Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Uint8Slice) Sort() {
	sort.Sort(slice)
}

func (slice Uint8Slice) Sorted() Uint8Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Uint8Slice) SortDesc() {
	sort.Sort(__Uint8SliceDesc(slice))
}

func (slice Uint8Slice) SortedDesc() Uint8Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Uint8Slice) SortedBy(less func(uint8, uint8) bool) Uint8Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Uint8Slice) SortBy(less func(uint8, uint8) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUint8Slice(slice, less, 0, n, maxDepth)
}

func (slice Uint8Slice) IsSortedBy(less func(uint8, uint8) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Uint8Slice) SortDescBy(less func(uint8, uint8) bool) {
	slice.SortBy(func(a uint8, b uint8) bool { return !less(a, b) })
}

func (slice Uint8Slice) SortedDescBy(less func(uint8, uint8) bool) Uint8Slice {
	greater := func(a, b uint8) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Uint8Slice) Split(fn func(n uint8) bool) (Uint8Slice, Uint8Slice) {
	var a Uint8Slice
	var b Uint8Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Uint8Slice) IsSortedDescBy(less func(uint8, uint8) bool) bool {
	greater := func(a, b uint8) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Uint8Slice) AnyGreater(n uint8) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) AnyLess(n uint8) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) AnyGreaterEqual(n uint8) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) AnyLessEqual(n uint8) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) AnyEqual(n uint8) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) ContainsAll(items ...uint8) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Uint8Slice) ContainsAny(items ...uint8) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Uint8Slice) Contains(n uint8) bool {
	return slice.AnyEqual(n)
}

func (slice Uint8Slice) SkipTake(skip, take int) Uint8Slice {
	var out Uint8Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUint8Slice(slice Uint8Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUint8Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUint8Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUint8Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUint8Slice(slice, first, first+i)
		siftDownUint8Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUint8Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUint8Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUint8Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUint8Slice(slice Uint8Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUint8Slice(slice, a+i, b+i)
	}
}
func doPivotUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUint8Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUint8Slice(slice, less, m, m-s, m+s)
		medianOfThreeUint8Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUint8Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUint8Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUint8Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUint8Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUint8Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUint8Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUint8Slice(slice Uint8Slice, less func(uint8, uint8) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUint8Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUint8Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUint8Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUint8Slice(slice, mhi, b)
		} else {
			quickSortUint8Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUint8Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUint8Slice(slice, less, a, b)
	}
}

type __Uint8SliceDesc []uint8

func (slice __Uint8SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Uint8SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Uint8SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Uint16Slice []uint16
type Uint16SliceReduceOption func(*Uint16SliceReduceOptions)
type Uint16SliceReduceOptions struct {
	initial uint16
}

type Uint16SliceAsyncOption func(options *Uint16SliceAsyncOptions)
type Uint16SliceAsyncOptions struct {
	PoolSize int
}

func NewUint16Slice(items ...uint16) Uint16Slice {
	slice := make(Uint16Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUint16(t uint16) Uint16SliceReduceOption {
	return func(o *Uint16SliceReduceOptions) {
		o.initial = t
	}
}

func WhereUint16All(pl ...func(uint16) bool) func(uint16) bool {
	return func(t uint16) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUint16Any(pl ...func(uint16) bool) func(uint16) bool {
	return func(t uint16) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUint16Not(p func(uint16) bool) func(uint16) bool {
	return func(t uint16) bool {
		return !p(t)
	}
}

func (slice Uint16Slice) Index(item uint16) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Uint16Slice) Map(fn func(uint16) uint16) Uint16Slice {
	mapped := make(Uint16Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint16Slice) AsyncMap(fn func(uint16) uint16, options ...Uint16SliceAsyncOption) Uint16Slice {
	output := make(Uint16Slice, len(slice))
	eachFn := func(t uint16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint16Slice) MapString(fn func(uint16) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint16Slice) AsyncMapString(fn func(uint16) string, options ...Uint16SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uint16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint16Slice) MapBool(fn func(uint16) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint16Slice) AsyncMapBool(fn func(uint16) bool, options ...Uint16SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uint16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint16Slice) Reversed() Uint16Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Uint16Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Uint16Slice) Item(index int) (item uint16, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Uint16Slice) ReverseSelect(where func(uint16) bool, ands ...func(uint16) bool) Uint16Slice {
	if len(ands) > 0 {
		where = WhereUint16All(append([]func(uint16) bool{where}, ands...)...)
	}
	var selected Uint16Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint16Slice) First(where ...func(uint16) bool) uint16 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint16All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint16
	return none
}

func (slice Uint16Slice) Last(where ...func(uint16) bool) uint16 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint16All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint16
	return none
}
func (slice Uint16Slice) FirstIndex(p func(uint16) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Uint16Slice) Filter(p func(uint16) bool) Uint16Slice {
	var selected Uint16Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint16Slice) IndexSelect(p func(uint16) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Uint16Slice) SelectAsync(p func(uint16) bool) Uint16Slice {
	var selected Uint16Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint16Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Uint16Slice) Strings() []string {
	return slice.MapString(func(x uint16) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Uint16Slice) Reject(p func(uint16) bool) Uint16Slice {
	return slice.Filter(func(n uint16) bool { return !p(n) })
}

func (slice Uint16Slice) RejectAsync(p func(uint16) bool) Uint16Slice {
	return slice.SelectAsync(func(n uint16) bool { return !p(n) })
}

func (slice Uint16Slice) Reduce(operator func(uint16, uint16) uint16, options ...Uint16SliceReduceOption) uint16 {
	o := &Uint16SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Uint16Slice) Append(items ...uint16) Uint16Slice {
	if slice == nil {
		var empty Uint16Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Uint16Slice) Any(pl ...func(uint16) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUint16All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) AnyNot(pl ...func(uint16) bool) bool {
	return !slice.Any(pl...)
}

func (slice Uint16Slice) All(p func(uint16) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Uint16Slice) AllNot(p func(uint16) bool) bool {
	return !slice.All(p)
}

func (slice Uint16Slice) Copy() Uint16Slice {
	cp := make(Uint16Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Uint16Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Uint16Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Uint16Slice) Count(p func(uint16) bool) int {
	return len(slice.Filter(p))
}

func (slice Uint16Slice) Max() uint16 {
	return slice.Reduce(Uint16Max)
}

func Uint16Max(c1 uint16, c2 uint16) uint16 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Uint16Slice) Min() uint16 {
	return slice.Reduce(Uint16Min)
}

func Uint16Min(c1 uint16, c2 uint16) uint16 {
	if Uint16Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Uint16Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Uint16Slice) MaxBy(less func(uint16, uint16) bool) (result uint16, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Uint16Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Uint16Slice) MinBy(less func(uint16, uint16) bool) (result uint16, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Uint16Slice) Average() (uint16, error) {
	return Uint16Average(slice)
}

func Uint16Average(slice Uint16Slice) (uint16, error) {
	var result uint16
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uint16(l)
	return result, nil
}

func (slice Uint16Slice) AverageFloat64() (float64, error) {
	return Uint16AverageFloat64(slice)
}

func Uint16AverageFloat64(slice Uint16Slice) (float64, error) {
	var result uint16
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Uint16Slice) Distinct() Uint16Slice {
	var result Uint16Slice
	appended := make(map[uint16]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Uint16Slice) DistinctBy(fn func(uint16, uint16) bool) (result Uint16Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Uint16Slice) Each(f func(uint16)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUint16AsyncPoolSize(size int) Uint16SliceAsyncOption {
	return func(options *Uint16SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUint16SliceAsyncOptions(opts ...Uint16SliceAsyncOption) *Uint16SliceAsyncOptions {
	o := &Uint16SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Uint16Slice) AsyncEachIndex(f func(uint16, int), options ...Uint16SliceAsyncOption) {
	o := newUint16SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uint16, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Uint16Slice, f func(uint16, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Uint16Slice) AsyncEach(f func(uint16), options ...Uint16SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint16, _ int) {
		f(t)
	}, options...)
}

func (slice Uint16Slice) EachIndex(f func(uint16, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Uint16Slice) Equal(other []uint16) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Uint16Slice) Len() int {
	return len(slice)
}

func (slice Uint16Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Uint16Slice) Replace(fn func(t uint16) uint16) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Uint16Slice) AsyncReplace(fn func(t uint16) uint16, options ...Uint16SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint16, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Uint16Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Uint16Slice) Sum() (result uint16) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Uint16Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint16Slice) Shuffled() Uint16Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Uint16Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint16Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Uint16Slice) Sort() {
	sort.Sort(slice)
}

func (slice Uint16Slice) Sorted() Uint16Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Uint16Slice) SortDesc() {
	sort.Sort(__Uint16SliceDesc(slice))
}

func (slice Uint16Slice) SortedDesc() Uint16Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Uint16Slice) SortedBy(less func(uint16, uint16) bool) Uint16Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Uint16Slice) SortBy(less func(uint16, uint16) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUint16Slice(slice, less, 0, n, maxDepth)
}

func (slice Uint16Slice) IsSortedBy(less func(uint16, uint16) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Uint16Slice) SortDescBy(less func(uint16, uint16) bool) {
	slice.SortBy(func(a uint16, b uint16) bool { return !less(a, b) })
}

func (slice Uint16Slice) SortedDescBy(less func(uint16, uint16) bool) Uint16Slice {
	greater := func(a, b uint16) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Uint16Slice) Split(fn func(n uint16) bool) (Uint16Slice, Uint16Slice) {
	var a Uint16Slice
	var b Uint16Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Uint16Slice) IsSortedDescBy(less func(uint16, uint16) bool) bool {
	greater := func(a, b uint16) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Uint16Slice) AnyGreater(n uint16) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) AnyLess(n uint16) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) AnyGreaterEqual(n uint16) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) AnyLessEqual(n uint16) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) AnyEqual(n uint16) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) ContainsAll(items ...uint16) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Uint16Slice) ContainsAny(items ...uint16) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Uint16Slice) Contains(n uint16) bool {
	return slice.AnyEqual(n)
}

func (slice Uint16Slice) SkipTake(skip, take int) Uint16Slice {
	var out Uint16Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUint16Slice(slice Uint16Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUint16Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUint16Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUint16Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUint16Slice(slice, first, first+i)
		siftDownUint16Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUint16Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUint16Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUint16Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUint16Slice(slice Uint16Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUint16Slice(slice, a+i, b+i)
	}
}
func doPivotUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUint16Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUint16Slice(slice, less, m, m-s, m+s)
		medianOfThreeUint16Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUint16Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUint16Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUint16Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUint16Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUint16Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUint16Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUint16Slice(slice Uint16Slice, less func(uint16, uint16) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUint16Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUint16Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUint16Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUint16Slice(slice, mhi, b)
		} else {
			quickSortUint16Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUint16Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUint16Slice(slice, less, a, b)
	}
}

type __Uint16SliceDesc []uint16

func (slice __Uint16SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Uint16SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Uint16SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Uint32Slice []uint32
type Uint32SliceReduceOption func(*Uint32SliceReduceOptions)
type Uint32SliceReduceOptions struct {
	initial uint32
}

type Uint32SliceAsyncOption func(options *Uint32SliceAsyncOptions)
type Uint32SliceAsyncOptions struct {
	PoolSize int
}

func NewUint32Slice(items ...uint32) Uint32Slice {
	slice := make(Uint32Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUint32(t uint32) Uint32SliceReduceOption {
	return func(o *Uint32SliceReduceOptions) {
		o.initial = t
	}
}

func WhereUint32All(pl ...func(uint32) bool) func(uint32) bool {
	return func(t uint32) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUint32Any(pl ...func(uint32) bool) func(uint32) bool {
	return func(t uint32) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUint32Not(p func(uint32) bool) func(uint32) bool {
	return func(t uint32) bool {
		return !p(t)
	}
}

func (slice Uint32Slice) Index(item uint32) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Uint32Slice) Map(fn func(uint32) uint32) Uint32Slice {
	mapped := make(Uint32Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint32Slice) AsyncMap(fn func(uint32) uint32, options ...Uint32SliceAsyncOption) Uint32Slice {
	output := make(Uint32Slice, len(slice))
	eachFn := func(t uint32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint32Slice) MapString(fn func(uint32) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint32Slice) AsyncMapString(fn func(uint32) string, options ...Uint32SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uint32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint32Slice) MapBool(fn func(uint32) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint32Slice) AsyncMapBool(fn func(uint32) bool, options ...Uint32SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uint32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint32Slice) Reversed() Uint32Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Uint32Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Uint32Slice) Item(index int) (item uint32, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Uint32Slice) ReverseSelect(where func(uint32) bool, ands ...func(uint32) bool) Uint32Slice {
	if len(ands) > 0 {
		where = WhereUint32All(append([]func(uint32) bool{where}, ands...)...)
	}
	var selected Uint32Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint32Slice) First(where ...func(uint32) bool) uint32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint32All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint32
	return none
}

func (slice Uint32Slice) Last(where ...func(uint32) bool) uint32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint32All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint32
	return none
}
func (slice Uint32Slice) FirstIndex(p func(uint32) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Uint32Slice) Filter(p func(uint32) bool) Uint32Slice {
	var selected Uint32Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint32Slice) IndexSelect(p func(uint32) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Uint32Slice) SelectAsync(p func(uint32) bool) Uint32Slice {
	var selected Uint32Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint32Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Uint32Slice) Strings() []string {
	return slice.MapString(func(x uint32) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Uint32Slice) Reject(p func(uint32) bool) Uint32Slice {
	return slice.Filter(func(n uint32) bool { return !p(n) })
}

func (slice Uint32Slice) RejectAsync(p func(uint32) bool) Uint32Slice {
	return slice.SelectAsync(func(n uint32) bool { return !p(n) })
}

func (slice Uint32Slice) Reduce(operator func(uint32, uint32) uint32, options ...Uint32SliceReduceOption) uint32 {
	o := &Uint32SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Uint32Slice) Append(items ...uint32) Uint32Slice {
	if slice == nil {
		var empty Uint32Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Uint32Slice) Any(pl ...func(uint32) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUint32All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) AnyNot(pl ...func(uint32) bool) bool {
	return !slice.Any(pl...)
}

func (slice Uint32Slice) All(p func(uint32) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Uint32Slice) AllNot(p func(uint32) bool) bool {
	return !slice.All(p)
}

func (slice Uint32Slice) Copy() Uint32Slice {
	cp := make(Uint32Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Uint32Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Uint32Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Uint32Slice) Count(p func(uint32) bool) int {
	return len(slice.Filter(p))
}

func (slice Uint32Slice) Max() uint32 {
	return slice.Reduce(Uint32Max)
}

func Uint32Max(c1 uint32, c2 uint32) uint32 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Uint32Slice) Min() uint32 {
	return slice.Reduce(Uint32Min)
}

func Uint32Min(c1 uint32, c2 uint32) uint32 {
	if Uint32Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Uint32Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Uint32Slice) MaxBy(less func(uint32, uint32) bool) (result uint32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Uint32Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Uint32Slice) MinBy(less func(uint32, uint32) bool) (result uint32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Uint32Slice) Average() (uint32, error) {
	return Uint32Average(slice)
}

func Uint32Average(slice Uint32Slice) (uint32, error) {
	var result uint32
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uint32(l)
	return result, nil
}

func (slice Uint32Slice) AverageFloat64() (float64, error) {
	return Uint32AverageFloat64(slice)
}

func Uint32AverageFloat64(slice Uint32Slice) (float64, error) {
	var result uint32
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Uint32Slice) Distinct() Uint32Slice {
	var result Uint32Slice
	appended := make(map[uint32]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Uint32Slice) DistinctBy(fn func(uint32, uint32) bool) (result Uint32Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Uint32Slice) Each(f func(uint32)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUint32AsyncPoolSize(size int) Uint32SliceAsyncOption {
	return func(options *Uint32SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUint32SliceAsyncOptions(opts ...Uint32SliceAsyncOption) *Uint32SliceAsyncOptions {
	o := &Uint32SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Uint32Slice) AsyncEachIndex(f func(uint32, int), options ...Uint32SliceAsyncOption) {
	o := newUint32SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uint32, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Uint32Slice, f func(uint32, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Uint32Slice) AsyncEach(f func(uint32), options ...Uint32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint32, _ int) {
		f(t)
	}, options...)
}

func (slice Uint32Slice) EachIndex(f func(uint32, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Uint32Slice) Equal(other []uint32) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Uint32Slice) Len() int {
	return len(slice)
}

func (slice Uint32Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Uint32Slice) Replace(fn func(t uint32) uint32) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Uint32Slice) AsyncReplace(fn func(t uint32) uint32, options ...Uint32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint32, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Uint32Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Uint32Slice) Sum() (result uint32) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Uint32Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint32Slice) Shuffled() Uint32Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Uint32Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint32Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Uint32Slice) Sort() {
	sort.Sort(slice)
}

func (slice Uint32Slice) Sorted() Uint32Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Uint32Slice) SortDesc() {
	sort.Sort(__Uint32SliceDesc(slice))
}

func (slice Uint32Slice) SortedDesc() Uint32Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Uint32Slice) SortedBy(less func(uint32, uint32) bool) Uint32Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Uint32Slice) SortBy(less func(uint32, uint32) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUint32Slice(slice, less, 0, n, maxDepth)
}

func (slice Uint32Slice) IsSortedBy(less func(uint32, uint32) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Uint32Slice) SortDescBy(less func(uint32, uint32) bool) {
	slice.SortBy(func(a uint32, b uint32) bool { return !less(a, b) })
}

func (slice Uint32Slice) SortedDescBy(less func(uint32, uint32) bool) Uint32Slice {
	greater := func(a, b uint32) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Uint32Slice) Split(fn func(n uint32) bool) (Uint32Slice, Uint32Slice) {
	var a Uint32Slice
	var b Uint32Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Uint32Slice) IsSortedDescBy(less func(uint32, uint32) bool) bool {
	greater := func(a, b uint32) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Uint32Slice) AnyGreater(n uint32) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) AnyLess(n uint32) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) AnyGreaterEqual(n uint32) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) AnyLessEqual(n uint32) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) AnyEqual(n uint32) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) ContainsAll(items ...uint32) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Uint32Slice) ContainsAny(items ...uint32) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Uint32Slice) Contains(n uint32) bool {
	return slice.AnyEqual(n)
}

func (slice Uint32Slice) SkipTake(skip, take int) Uint32Slice {
	var out Uint32Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUint32Slice(slice Uint32Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUint32Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUint32Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUint32Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUint32Slice(slice, first, first+i)
		siftDownUint32Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUint32Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUint32Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUint32Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUint32Slice(slice Uint32Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUint32Slice(slice, a+i, b+i)
	}
}
func doPivotUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUint32Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUint32Slice(slice, less, m, m-s, m+s)
		medianOfThreeUint32Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUint32Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUint32Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUint32Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUint32Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUint32Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUint32Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUint32Slice(slice Uint32Slice, less func(uint32, uint32) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUint32Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUint32Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUint32Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUint32Slice(slice, mhi, b)
		} else {
			quickSortUint32Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUint32Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUint32Slice(slice, less, a, b)
	}
}

type __Uint32SliceDesc []uint32

func (slice __Uint32SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Uint32SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Uint32SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Uint64Slice []uint64
type Uint64SliceReduceOption func(*Uint64SliceReduceOptions)
type Uint64SliceReduceOptions struct {
	initial uint64
}

type Uint64SliceAsyncOption func(options *Uint64SliceAsyncOptions)
type Uint64SliceAsyncOptions struct {
	PoolSize int
}

func NewUint64Slice(items ...uint64) Uint64Slice {
	slice := make(Uint64Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialUint64(t uint64) Uint64SliceReduceOption {
	return func(o *Uint64SliceReduceOptions) {
		o.initial = t
	}
}

func WhereUint64All(pl ...func(uint64) bool) func(uint64) bool {
	return func(t uint64) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereUint64Any(pl ...func(uint64) bool) func(uint64) bool {
	return func(t uint64) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereUint64Not(p func(uint64) bool) func(uint64) bool {
	return func(t uint64) bool {
		return !p(t)
	}
}

func (slice Uint64Slice) Index(item uint64) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Uint64Slice) Map(fn func(uint64) uint64) Uint64Slice {
	mapped := make(Uint64Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint64Slice) AsyncMap(fn func(uint64) uint64, options ...Uint64SliceAsyncOption) Uint64Slice {
	output := make(Uint64Slice, len(slice))
	eachFn := func(t uint64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint64Slice) MapString(fn func(uint64) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint64Slice) AsyncMapString(fn func(uint64) string, options ...Uint64SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t uint64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint64Slice) MapBool(fn func(uint64) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Uint64Slice) AsyncMapBool(fn func(uint64) bool, options ...Uint64SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t uint64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Uint64Slice) Reversed() Uint64Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Uint64Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Uint64Slice) Item(index int) (item uint64, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Uint64Slice) ReverseSelect(where func(uint64) bool, ands ...func(uint64) bool) Uint64Slice {
	if len(ands) > 0 {
		where = WhereUint64All(append([]func(uint64) bool{where}, ands...)...)
	}
	var selected Uint64Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint64Slice) First(where ...func(uint64) bool) uint64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint64All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint64
	return none
}

func (slice Uint64Slice) Last(where ...func(uint64) bool) uint64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereUint64All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none uint64
	return none
}
func (slice Uint64Slice) FirstIndex(p func(uint64) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Uint64Slice) Filter(p func(uint64) bool) Uint64Slice {
	var selected Uint64Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint64Slice) IndexSelect(p func(uint64) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Uint64Slice) SelectAsync(p func(uint64) bool) Uint64Slice {
	var selected Uint64Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Uint64Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Uint64Slice) Strings() []string {
	return slice.MapString(func(x uint64) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Uint64Slice) Reject(p func(uint64) bool) Uint64Slice {
	return slice.Filter(func(n uint64) bool { return !p(n) })
}

func (slice Uint64Slice) RejectAsync(p func(uint64) bool) Uint64Slice {
	return slice.SelectAsync(func(n uint64) bool { return !p(n) })
}

func (slice Uint64Slice) Reduce(operator func(uint64, uint64) uint64, options ...Uint64SliceReduceOption) uint64 {
	o := &Uint64SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Uint64Slice) Append(items ...uint64) Uint64Slice {
	if slice == nil {
		var empty Uint64Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Uint64Slice) Any(pl ...func(uint64) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereUint64All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) AnyNot(pl ...func(uint64) bool) bool {
	return !slice.Any(pl...)
}

func (slice Uint64Slice) All(p func(uint64) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Uint64Slice) AllNot(p func(uint64) bool) bool {
	return !slice.All(p)
}

func (slice Uint64Slice) Copy() Uint64Slice {
	cp := make(Uint64Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Uint64Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Uint64Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Uint64Slice) Count(p func(uint64) bool) int {
	return len(slice.Filter(p))
}

func (slice Uint64Slice) Max() uint64 {
	return slice.Reduce(Uint64Max)
}

func Uint64Max(c1 uint64, c2 uint64) uint64 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Uint64Slice) Min() uint64 {
	return slice.Reduce(Uint64Min)
}

func Uint64Min(c1 uint64, c2 uint64) uint64 {
	if Uint64Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Uint64Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Uint64Slice) MaxBy(less func(uint64, uint64) bool) (result uint64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Uint64Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Uint64Slice) MinBy(less func(uint64, uint64) bool) (result uint64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Uint64Slice) Average() (uint64, error) {
	return Uint64Average(slice)
}

func Uint64Average(slice Uint64Slice) (uint64, error) {
	var result uint64
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / uint64(l)
	return result, nil
}

func (slice Uint64Slice) AverageFloat64() (float64, error) {
	return Uint64AverageFloat64(slice)
}

func Uint64AverageFloat64(slice Uint64Slice) (float64, error) {
	var result uint64
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Uint64Slice) Distinct() Uint64Slice {
	var result Uint64Slice
	appended := make(map[uint64]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Uint64Slice) DistinctBy(fn func(uint64, uint64) bool) (result Uint64Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Uint64Slice) Each(f func(uint64)) {
	for _, t := range slice {
		f(t)
	}
}

func WithUint64AsyncPoolSize(size int) Uint64SliceAsyncOption {
	return func(options *Uint64SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newUint64SliceAsyncOptions(opts ...Uint64SliceAsyncOption) *Uint64SliceAsyncOptions {
	o := &Uint64SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Uint64Slice) AsyncEachIndex(f func(uint64, int), options ...Uint64SliceAsyncOption) {
	o := newUint64SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item uint64, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Uint64Slice, f func(uint64, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Uint64Slice) AsyncEach(f func(uint64), options ...Uint64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint64, _ int) {
		f(t)
	}, options...)
}

func (slice Uint64Slice) EachIndex(f func(uint64, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Uint64Slice) Equal(other []uint64) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Uint64Slice) Len() int {
	return len(slice)
}

func (slice Uint64Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Uint64Slice) Replace(fn func(t uint64) uint64) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Uint64Slice) AsyncReplace(fn func(t uint64) uint64, options ...Uint64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t uint64, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Uint64Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Uint64Slice) Sum() (result uint64) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Uint64Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint64Slice) Shuffled() Uint64Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Uint64Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Uint64Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Uint64Slice) Sort() {
	sort.Sort(slice)
}

func (slice Uint64Slice) Sorted() Uint64Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Uint64Slice) SortDesc() {
	sort.Sort(__Uint64SliceDesc(slice))
}

func (slice Uint64Slice) SortedDesc() Uint64Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Uint64Slice) SortedBy(less func(uint64, uint64) bool) Uint64Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Uint64Slice) SortBy(less func(uint64, uint64) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortUint64Slice(slice, less, 0, n, maxDepth)
}

func (slice Uint64Slice) IsSortedBy(less func(uint64, uint64) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Uint64Slice) SortDescBy(less func(uint64, uint64) bool) {
	slice.SortBy(func(a uint64, b uint64) bool { return !less(a, b) })
}

func (slice Uint64Slice) SortedDescBy(less func(uint64, uint64) bool) Uint64Slice {
	greater := func(a, b uint64) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Uint64Slice) Split(fn func(n uint64) bool) (Uint64Slice, Uint64Slice) {
	var a Uint64Slice
	var b Uint64Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Uint64Slice) IsSortedDescBy(less func(uint64, uint64) bool) bool {
	greater := func(a, b uint64) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Uint64Slice) AnyGreater(n uint64) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) AnyLess(n uint64) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) AnyGreaterEqual(n uint64) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) AnyLessEqual(n uint64) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) AnyEqual(n uint64) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) ContainsAll(items ...uint64) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Uint64Slice) ContainsAny(items ...uint64) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Uint64Slice) Contains(n uint64) bool {
	return slice.AnyEqual(n)
}

func (slice Uint64Slice) SkipTake(skip, take int) Uint64Slice {
	var out Uint64Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapUint64Slice(slice Uint64Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapUint64Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapUint64Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownUint64Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapUint64Slice(slice, first, first+i)
		siftDownUint64Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapUint64Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapUint64Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapUint64Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeUint64Slice(slice Uint64Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapUint64Slice(slice, a+i, b+i)
	}
}
func doPivotUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeUint64Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeUint64Slice(slice, less, m, m-s, m+s)
		medianOfThreeUint64Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeUint64Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapUint64Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapUint64Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapUint64Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeUint64Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeUint64Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortUint64Slice(slice Uint64Slice, less func(uint64, uint64) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortUint64Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotUint64Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortUint64Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortUint64Slice(slice, mhi, b)
		} else {
			quickSortUint64Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortUint64Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortUint64Slice(slice, less, a, b)
	}
}

type __Uint64SliceDesc []uint64

func (slice __Uint64SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Uint64SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Uint64SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type IntSlice []int
type IntSliceReduceOption func(*IntSliceReduceOptions)
type IntSliceReduceOptions struct {
	initial int
}

type IntSliceAsyncOption func(options *IntSliceAsyncOptions)
type IntSliceAsyncOptions struct {
	PoolSize int
}

func NewIntSlice(items ...int) IntSlice {
	slice := make(IntSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInt(t int) IntSliceReduceOption {
	return func(o *IntSliceReduceOptions) {
		o.initial = t
	}
}

func WhereIntAll(pl ...func(int) bool) func(int) bool {
	return func(t int) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereIntAny(pl ...func(int) bool) func(int) bool {
	return func(t int) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereIntNot(p func(int) bool) func(int) bool {
	return func(t int) bool {
		return !p(t)
	}
}

func (slice IntSlice) Index(item int) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice IntSlice) Map(fn func(int) int) IntSlice {
	mapped := make(IntSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice IntSlice) AsyncMap(fn func(int) int, options ...IntSliceAsyncOption) IntSlice {
	output := make(IntSlice, len(slice))
	eachFn := func(t int, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice IntSlice) MapString(fn func(int) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice IntSlice) AsyncMapString(fn func(int) string, options ...IntSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t int, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice IntSlice) MapBool(fn func(int) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice IntSlice) AsyncMapBool(fn func(int) bool, options ...IntSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t int, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice IntSlice) Reversed() IntSlice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice IntSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice IntSlice) Item(index int) (item int, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice IntSlice) ReverseSelect(where func(int) bool, ands ...func(int) bool) IntSlice {
	if len(ands) > 0 {
		where = WhereIntAll(append([]func(int) bool{where}, ands...)...)
	}
	var selected IntSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice IntSlice) First(where ...func(int) bool) int {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereIntAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int
	return none
}

func (slice IntSlice) Last(where ...func(int) bool) int {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereIntAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int
	return none
}
func (slice IntSlice) FirstIndex(p func(int) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice IntSlice) Filter(p func(int) bool) IntSlice {
	var selected IntSlice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice IntSlice) IndexSelect(p func(int) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice IntSlice) SelectAsync(p func(int) bool) IntSlice {
	var selected IntSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice IntSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice IntSlice) Strings() []string {
	return slice.MapString(func(x int) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice IntSlice) Reject(p func(int) bool) IntSlice {
	return slice.Filter(func(n int) bool { return !p(n) })
}

func (slice IntSlice) RejectAsync(p func(int) bool) IntSlice {
	return slice.SelectAsync(func(n int) bool { return !p(n) })
}

func (slice IntSlice) Reduce(operator func(int, int) int, options ...IntSliceReduceOption) int {
	o := &IntSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice IntSlice) Append(items ...int) IntSlice {
	if slice == nil {
		var empty IntSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice IntSlice) Any(pl ...func(int) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereIntAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice IntSlice) AnyNot(pl ...func(int) bool) bool {
	return !slice.Any(pl...)
}

func (slice IntSlice) All(p func(int) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice IntSlice) AllNot(p func(int) bool) bool {
	return !slice.All(p)
}

func (slice IntSlice) Copy() IntSlice {
	cp := make(IntSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice IntSlice) Empty() bool {
	return len(slice) == 0
}

func (slice IntSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice IntSlice) Count(p func(int) bool) int {
	return len(slice.Filter(p))
}

func (slice IntSlice) Max() int {
	return slice.Reduce(IntMax)
}

func IntMax(c1 int, c2 int) int {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice IntSlice) Min() int {
	return slice.Reduce(IntMin)
}

func IntMin(c1 int, c2 int) int {
	if IntMax(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of IntSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice IntSlice) MaxBy(less func(int, int) bool) (result int, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of IntSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice IntSlice) MinBy(less func(int, int) bool) (result int, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice IntSlice) Average() (int, error) {
	return IntAverage(slice)
}

func IntAverage(slice IntSlice) (int, error) {
	var result int
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / int(l)
	return result, nil
}

func (slice IntSlice) AverageFloat64() (float64, error) {
	return IntAverageFloat64(slice)
}

func IntAverageFloat64(slice IntSlice) (float64, error) {
	var result int
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice IntSlice) Distinct() IntSlice {
	var result IntSlice
	appended := make(map[int]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice IntSlice) DistinctBy(fn func(int, int) bool) (result IntSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice IntSlice) Each(f func(int)) {
	for _, t := range slice {
		f(t)
	}
}

func WithIntAsyncPoolSize(size int) IntSliceAsyncOption {
	return func(options *IntSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newIntSliceAsyncOptions(opts ...IntSliceAsyncOption) *IntSliceAsyncOptions {
	o := &IntSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice IntSlice) AsyncEachIndex(f func(int, int), options ...IntSliceAsyncOption) {
	o := newIntSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item int, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice IntSlice, f func(int, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice IntSlice) AsyncEach(f func(int), options ...IntSliceAsyncOption) {
	slice.AsyncEachIndex(func(t int, _ int) {
		f(t)
	}, options...)
}

func (slice IntSlice) EachIndex(f func(int, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice IntSlice) Equal(other []int) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice IntSlice) Len() int {
	return len(slice)
}

func (slice IntSlice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice IntSlice) Replace(fn func(t int) int) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice IntSlice) AsyncReplace(fn func(t int) int, options ...IntSliceAsyncOption) {
	slice.AsyncEachIndex(func(t int, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice IntSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice IntSlice) Sum() (result int) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of IntSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice IntSlice) Shuffled() IntSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of IntSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice IntSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice IntSlice) Sort() {
	sort.Sort(slice)
}

func (slice IntSlice) Sorted() IntSlice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice IntSlice) SortDesc() {
	sort.Sort(__IntSliceDesc(slice))
}

func (slice IntSlice) SortedDesc() IntSlice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice IntSlice) SortedBy(less func(int, int) bool) IntSlice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice IntSlice) SortBy(less func(int, int) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortIntSlice(slice, less, 0, n, maxDepth)
}

func (slice IntSlice) IsSortedBy(less func(int, int) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice IntSlice) SortDescBy(less func(int, int) bool) {
	slice.SortBy(func(a int, b int) bool { return !less(a, b) })
}

func (slice IntSlice) SortedDescBy(less func(int, int) bool) IntSlice {
	greater := func(a, b int) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice IntSlice) Split(fn func(n int) bool) (IntSlice, IntSlice) {
	var a IntSlice
	var b IntSlice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice IntSlice) IsSortedDescBy(less func(int, int) bool) bool {
	greater := func(a, b int) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice IntSlice) AnyGreater(n int) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice IntSlice) AnyLess(n int) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice IntSlice) AnyGreaterEqual(n int) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice IntSlice) AnyLessEqual(n int) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice IntSlice) AnyEqual(n int) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice IntSlice) ContainsAll(items ...int) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice IntSlice) ContainsAny(items ...int) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice IntSlice) Contains(n int) bool {
	return slice.AnyEqual(n)
}

func (slice IntSlice) SkipTake(skip, take int) IntSlice {
	var out IntSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapIntSlice(slice IntSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortIntSlice(slice IntSlice, less func(int, int) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapIntSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownIntSlice(slice IntSlice, less func(int, int) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapIntSlice(slice, first+root, first+child)
		root = child
	}
}
func heapSortIntSlice(slice IntSlice, less func(int, int) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownIntSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapIntSlice(slice, first, first+i)
		siftDownIntSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeIntSlice(slice IntSlice, less func(int, int) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapIntSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapIntSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapIntSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeIntSlice(slice IntSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapIntSlice(slice, a+i, b+i)
	}
}
func doPivotIntSlice(slice IntSlice, less func(int, int) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeIntSlice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeIntSlice(slice, less, m, m-s, m+s)
		medianOfThreeIntSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeIntSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapIntSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapIntSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapIntSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeIntSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeIntSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortIntSlice(slice IntSlice, less func(int, int) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortIntSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotIntSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortIntSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortIntSlice(slice, mhi, b)
		} else {
			quickSortIntSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortIntSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortIntSlice(slice, less, a, b)
	}
}

type __IntSliceDesc []int

func (slice __IntSliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __IntSliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __IntSliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Int8Slice []int8
type Int8SliceReduceOption func(*Int8SliceReduceOptions)
type Int8SliceReduceOptions struct {
	initial int8
}

type Int8SliceAsyncOption func(options *Int8SliceAsyncOptions)
type Int8SliceAsyncOptions struct {
	PoolSize int
}

func NewInt8Slice(items ...int8) Int8Slice {
	slice := make(Int8Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInt8(t int8) Int8SliceReduceOption {
	return func(o *Int8SliceReduceOptions) {
		o.initial = t
	}
}

func WhereInt8All(pl ...func(int8) bool) func(int8) bool {
	return func(t int8) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereInt8Any(pl ...func(int8) bool) func(int8) bool {
	return func(t int8) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereInt8Not(p func(int8) bool) func(int8) bool {
	return func(t int8) bool {
		return !p(t)
	}
}

func (slice Int8Slice) Index(item int8) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Int8Slice) Map(fn func(int8) int8) Int8Slice {
	mapped := make(Int8Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int8Slice) AsyncMap(fn func(int8) int8, options ...Int8SliceAsyncOption) Int8Slice {
	output := make(Int8Slice, len(slice))
	eachFn := func(t int8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int8Slice) MapString(fn func(int8) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int8Slice) AsyncMapString(fn func(int8) string, options ...Int8SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t int8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int8Slice) MapBool(fn func(int8) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int8Slice) AsyncMapBool(fn func(int8) bool, options ...Int8SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t int8, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int8Slice) Reversed() Int8Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Int8Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Int8Slice) Item(index int) (item int8, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Int8Slice) ReverseSelect(where func(int8) bool, ands ...func(int8) bool) Int8Slice {
	if len(ands) > 0 {
		where = WhereInt8All(append([]func(int8) bool{where}, ands...)...)
	}
	var selected Int8Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int8Slice) First(where ...func(int8) bool) int8 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt8All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int8
	return none
}

func (slice Int8Slice) Last(where ...func(int8) bool) int8 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt8All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int8
	return none
}
func (slice Int8Slice) FirstIndex(p func(int8) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Int8Slice) Filter(p func(int8) bool) Int8Slice {
	var selected Int8Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int8Slice) IndexSelect(p func(int8) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Int8Slice) SelectAsync(p func(int8) bool) Int8Slice {
	var selected Int8Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int8Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Int8Slice) Strings() []string {
	return slice.MapString(func(x int8) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Int8Slice) Reject(p func(int8) bool) Int8Slice {
	return slice.Filter(func(n int8) bool { return !p(n) })
}

func (slice Int8Slice) RejectAsync(p func(int8) bool) Int8Slice {
	return slice.SelectAsync(func(n int8) bool { return !p(n) })
}

func (slice Int8Slice) Reduce(operator func(int8, int8) int8, options ...Int8SliceReduceOption) int8 {
	o := &Int8SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Int8Slice) Append(items ...int8) Int8Slice {
	if slice == nil {
		var empty Int8Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Int8Slice) Any(pl ...func(int8) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereInt8All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Int8Slice) AnyNot(pl ...func(int8) bool) bool {
	return !slice.Any(pl...)
}

func (slice Int8Slice) All(p func(int8) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Int8Slice) AllNot(p func(int8) bool) bool {
	return !slice.All(p)
}

func (slice Int8Slice) Copy() Int8Slice {
	cp := make(Int8Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Int8Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Int8Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Int8Slice) Count(p func(int8) bool) int {
	return len(slice.Filter(p))
}

func (slice Int8Slice) Max() int8 {
	return slice.Reduce(Int8Max)
}

func Int8Max(c1 int8, c2 int8) int8 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Int8Slice) Min() int8 {
	return slice.Reduce(Int8Min)
}

func Int8Min(c1 int8, c2 int8) int8 {
	if Int8Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Int8Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Int8Slice) MaxBy(less func(int8, int8) bool) (result int8, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Int8Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Int8Slice) MinBy(less func(int8, int8) bool) (result int8, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Int8Slice) Average() (int8, error) {
	return Int8Average(slice)
}

func Int8Average(slice Int8Slice) (int8, error) {
	var result int8
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / int8(l)
	return result, nil
}

func (slice Int8Slice) AverageFloat64() (float64, error) {
	return Int8AverageFloat64(slice)
}

func Int8AverageFloat64(slice Int8Slice) (float64, error) {
	var result int8
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Int8Slice) Distinct() Int8Slice {
	var result Int8Slice
	appended := make(map[int8]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Int8Slice) DistinctBy(fn func(int8, int8) bool) (result Int8Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Int8Slice) Each(f func(int8)) {
	for _, t := range slice {
		f(t)
	}
}

func WithInt8AsyncPoolSize(size int) Int8SliceAsyncOption {
	return func(options *Int8SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newInt8SliceAsyncOptions(opts ...Int8SliceAsyncOption) *Int8SliceAsyncOptions {
	o := &Int8SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Int8Slice) AsyncEachIndex(f func(int8, int), options ...Int8SliceAsyncOption) {
	o := newInt8SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item int8, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Int8Slice, f func(int8, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Int8Slice) AsyncEach(f func(int8), options ...Int8SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int8, _ int) {
		f(t)
	}, options...)
}

func (slice Int8Slice) EachIndex(f func(int8, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Int8Slice) Equal(other []int8) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Int8Slice) Len() int {
	return len(slice)
}

func (slice Int8Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Int8Slice) Replace(fn func(t int8) int8) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Int8Slice) AsyncReplace(fn func(t int8) int8, options ...Int8SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int8, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Int8Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Int8Slice) Sum() (result int8) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Int8Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int8Slice) Shuffled() Int8Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Int8Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int8Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Int8Slice) Sort() {
	sort.Sort(slice)
}

func (slice Int8Slice) Sorted() Int8Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Int8Slice) SortDesc() {
	sort.Sort(__Int8SliceDesc(slice))
}

func (slice Int8Slice) SortedDesc() Int8Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Int8Slice) SortedBy(less func(int8, int8) bool) Int8Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Int8Slice) SortBy(less func(int8, int8) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortInt8Slice(slice, less, 0, n, maxDepth)
}

func (slice Int8Slice) IsSortedBy(less func(int8, int8) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Int8Slice) SortDescBy(less func(int8, int8) bool) {
	slice.SortBy(func(a int8, b int8) bool { return !less(a, b) })
}

func (slice Int8Slice) SortedDescBy(less func(int8, int8) bool) Int8Slice {
	greater := func(a, b int8) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Int8Slice) Split(fn func(n int8) bool) (Int8Slice, Int8Slice) {
	var a Int8Slice
	var b Int8Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Int8Slice) IsSortedDescBy(less func(int8, int8) bool) bool {
	greater := func(a, b int8) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Int8Slice) AnyGreater(n int8) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Int8Slice) AnyLess(n int8) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Int8Slice) AnyGreaterEqual(n int8) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Int8Slice) AnyLessEqual(n int8) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Int8Slice) AnyEqual(n int8) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Int8Slice) ContainsAll(items ...int8) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Int8Slice) ContainsAny(items ...int8) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Int8Slice) Contains(n int8) bool {
	return slice.AnyEqual(n)
}

func (slice Int8Slice) SkipTake(skip, take int) Int8Slice {
	var out Int8Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapInt8Slice(slice Int8Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortInt8Slice(slice Int8Slice, less func(int8, int8) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapInt8Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownInt8Slice(slice Int8Slice, less func(int8, int8) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapInt8Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortInt8Slice(slice Int8Slice, less func(int8, int8) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownInt8Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapInt8Slice(slice, first, first+i)
		siftDownInt8Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeInt8Slice(slice Int8Slice, less func(int8, int8) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapInt8Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapInt8Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapInt8Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeInt8Slice(slice Int8Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapInt8Slice(slice, a+i, b+i)
	}
}
func doPivotInt8Slice(slice Int8Slice, less func(int8, int8) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeInt8Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeInt8Slice(slice, less, m, m-s, m+s)
		medianOfThreeInt8Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeInt8Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapInt8Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapInt8Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapInt8Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeInt8Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeInt8Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortInt8Slice(slice Int8Slice, less func(int8, int8) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortInt8Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotInt8Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortInt8Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortInt8Slice(slice, mhi, b)
		} else {
			quickSortInt8Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortInt8Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortInt8Slice(slice, less, a, b)
	}
}

type __Int8SliceDesc []int8

func (slice __Int8SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Int8SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Int8SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Int16Slice []int16
type Int16SliceReduceOption func(*Int16SliceReduceOptions)
type Int16SliceReduceOptions struct {
	initial int16
}

type Int16SliceAsyncOption func(options *Int16SliceAsyncOptions)
type Int16SliceAsyncOptions struct {
	PoolSize int
}

func NewInt16Slice(items ...int16) Int16Slice {
	slice := make(Int16Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInt16(t int16) Int16SliceReduceOption {
	return func(o *Int16SliceReduceOptions) {
		o.initial = t
	}
}

func WhereInt16All(pl ...func(int16) bool) func(int16) bool {
	return func(t int16) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereInt16Any(pl ...func(int16) bool) func(int16) bool {
	return func(t int16) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereInt16Not(p func(int16) bool) func(int16) bool {
	return func(t int16) bool {
		return !p(t)
	}
}

func (slice Int16Slice) Index(item int16) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Int16Slice) Map(fn func(int16) int16) Int16Slice {
	mapped := make(Int16Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int16Slice) AsyncMap(fn func(int16) int16, options ...Int16SliceAsyncOption) Int16Slice {
	output := make(Int16Slice, len(slice))
	eachFn := func(t int16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int16Slice) MapString(fn func(int16) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int16Slice) AsyncMapString(fn func(int16) string, options ...Int16SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t int16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int16Slice) MapBool(fn func(int16) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int16Slice) AsyncMapBool(fn func(int16) bool, options ...Int16SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t int16, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int16Slice) Reversed() Int16Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Int16Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Int16Slice) Item(index int) (item int16, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Int16Slice) ReverseSelect(where func(int16) bool, ands ...func(int16) bool) Int16Slice {
	if len(ands) > 0 {
		where = WhereInt16All(append([]func(int16) bool{where}, ands...)...)
	}
	var selected Int16Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int16Slice) First(where ...func(int16) bool) int16 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt16All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int16
	return none
}

func (slice Int16Slice) Last(where ...func(int16) bool) int16 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt16All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int16
	return none
}
func (slice Int16Slice) FirstIndex(p func(int16) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Int16Slice) Filter(p func(int16) bool) Int16Slice {
	var selected Int16Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int16Slice) IndexSelect(p func(int16) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Int16Slice) SelectAsync(p func(int16) bool) Int16Slice {
	var selected Int16Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int16Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Int16Slice) Strings() []string {
	return slice.MapString(func(x int16) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Int16Slice) Reject(p func(int16) bool) Int16Slice {
	return slice.Filter(func(n int16) bool { return !p(n) })
}

func (slice Int16Slice) RejectAsync(p func(int16) bool) Int16Slice {
	return slice.SelectAsync(func(n int16) bool { return !p(n) })
}

func (slice Int16Slice) Reduce(operator func(int16, int16) int16, options ...Int16SliceReduceOption) int16 {
	o := &Int16SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Int16Slice) Append(items ...int16) Int16Slice {
	if slice == nil {
		var empty Int16Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Int16Slice) Any(pl ...func(int16) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereInt16All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Int16Slice) AnyNot(pl ...func(int16) bool) bool {
	return !slice.Any(pl...)
}

func (slice Int16Slice) All(p func(int16) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Int16Slice) AllNot(p func(int16) bool) bool {
	return !slice.All(p)
}

func (slice Int16Slice) Copy() Int16Slice {
	cp := make(Int16Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Int16Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Int16Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Int16Slice) Count(p func(int16) bool) int {
	return len(slice.Filter(p))
}

func (slice Int16Slice) Max() int16 {
	return slice.Reduce(Int16Max)
}

func Int16Max(c1 int16, c2 int16) int16 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Int16Slice) Min() int16 {
	return slice.Reduce(Int16Min)
}

func Int16Min(c1 int16, c2 int16) int16 {
	if Int16Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Int16Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Int16Slice) MaxBy(less func(int16, int16) bool) (result int16, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Int16Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Int16Slice) MinBy(less func(int16, int16) bool) (result int16, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Int16Slice) Average() (int16, error) {
	return Int16Average(slice)
}

func Int16Average(slice Int16Slice) (int16, error) {
	var result int16
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / int16(l)
	return result, nil
}

func (slice Int16Slice) AverageFloat64() (float64, error) {
	return Int16AverageFloat64(slice)
}

func Int16AverageFloat64(slice Int16Slice) (float64, error) {
	var result int16
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Int16Slice) Distinct() Int16Slice {
	var result Int16Slice
	appended := make(map[int16]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Int16Slice) DistinctBy(fn func(int16, int16) bool) (result Int16Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Int16Slice) Each(f func(int16)) {
	for _, t := range slice {
		f(t)
	}
}

func WithInt16AsyncPoolSize(size int) Int16SliceAsyncOption {
	return func(options *Int16SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newInt16SliceAsyncOptions(opts ...Int16SliceAsyncOption) *Int16SliceAsyncOptions {
	o := &Int16SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Int16Slice) AsyncEachIndex(f func(int16, int), options ...Int16SliceAsyncOption) {
	o := newInt16SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item int16, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Int16Slice, f func(int16, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Int16Slice) AsyncEach(f func(int16), options ...Int16SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int16, _ int) {
		f(t)
	}, options...)
}

func (slice Int16Slice) EachIndex(f func(int16, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Int16Slice) Equal(other []int16) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Int16Slice) Len() int {
	return len(slice)
}

func (slice Int16Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Int16Slice) Replace(fn func(t int16) int16) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Int16Slice) AsyncReplace(fn func(t int16) int16, options ...Int16SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int16, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Int16Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Int16Slice) Sum() (result int16) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Int16Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int16Slice) Shuffled() Int16Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Int16Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int16Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Int16Slice) Sort() {
	sort.Sort(slice)
}

func (slice Int16Slice) Sorted() Int16Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Int16Slice) SortDesc() {
	sort.Sort(__Int16SliceDesc(slice))
}

func (slice Int16Slice) SortedDesc() Int16Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Int16Slice) SortedBy(less func(int16, int16) bool) Int16Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Int16Slice) SortBy(less func(int16, int16) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortInt16Slice(slice, less, 0, n, maxDepth)
}

func (slice Int16Slice) IsSortedBy(less func(int16, int16) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Int16Slice) SortDescBy(less func(int16, int16) bool) {
	slice.SortBy(func(a int16, b int16) bool { return !less(a, b) })
}

func (slice Int16Slice) SortedDescBy(less func(int16, int16) bool) Int16Slice {
	greater := func(a, b int16) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Int16Slice) Split(fn func(n int16) bool) (Int16Slice, Int16Slice) {
	var a Int16Slice
	var b Int16Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Int16Slice) IsSortedDescBy(less func(int16, int16) bool) bool {
	greater := func(a, b int16) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Int16Slice) AnyGreater(n int16) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Int16Slice) AnyLess(n int16) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Int16Slice) AnyGreaterEqual(n int16) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Int16Slice) AnyLessEqual(n int16) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Int16Slice) AnyEqual(n int16) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Int16Slice) ContainsAll(items ...int16) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Int16Slice) ContainsAny(items ...int16) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Int16Slice) Contains(n int16) bool {
	return slice.AnyEqual(n)
}

func (slice Int16Slice) SkipTake(skip, take int) Int16Slice {
	var out Int16Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapInt16Slice(slice Int16Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortInt16Slice(slice Int16Slice, less func(int16, int16) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapInt16Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownInt16Slice(slice Int16Slice, less func(int16, int16) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapInt16Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortInt16Slice(slice Int16Slice, less func(int16, int16) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownInt16Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapInt16Slice(slice, first, first+i)
		siftDownInt16Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeInt16Slice(slice Int16Slice, less func(int16, int16) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapInt16Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapInt16Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapInt16Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeInt16Slice(slice Int16Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapInt16Slice(slice, a+i, b+i)
	}
}
func doPivotInt16Slice(slice Int16Slice, less func(int16, int16) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeInt16Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeInt16Slice(slice, less, m, m-s, m+s)
		medianOfThreeInt16Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeInt16Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapInt16Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapInt16Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapInt16Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeInt16Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeInt16Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortInt16Slice(slice Int16Slice, less func(int16, int16) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortInt16Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotInt16Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortInt16Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortInt16Slice(slice, mhi, b)
		} else {
			quickSortInt16Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortInt16Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortInt16Slice(slice, less, a, b)
	}
}

type __Int16SliceDesc []int16

func (slice __Int16SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Int16SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Int16SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Int32Slice []int32
type Int32SliceReduceOption func(*Int32SliceReduceOptions)
type Int32SliceReduceOptions struct {
	initial int32
}

type Int32SliceAsyncOption func(options *Int32SliceAsyncOptions)
type Int32SliceAsyncOptions struct {
	PoolSize int
}

func NewInt32Slice(items ...int32) Int32Slice {
	slice := make(Int32Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInt32(t int32) Int32SliceReduceOption {
	return func(o *Int32SliceReduceOptions) {
		o.initial = t
	}
}

func WhereInt32All(pl ...func(int32) bool) func(int32) bool {
	return func(t int32) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereInt32Any(pl ...func(int32) bool) func(int32) bool {
	return func(t int32) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereInt32Not(p func(int32) bool) func(int32) bool {
	return func(t int32) bool {
		return !p(t)
	}
}

func (slice Int32Slice) Index(item int32) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Int32Slice) Map(fn func(int32) int32) Int32Slice {
	mapped := make(Int32Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int32Slice) AsyncMap(fn func(int32) int32, options ...Int32SliceAsyncOption) Int32Slice {
	output := make(Int32Slice, len(slice))
	eachFn := func(t int32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int32Slice) MapString(fn func(int32) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int32Slice) AsyncMapString(fn func(int32) string, options ...Int32SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t int32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int32Slice) MapBool(fn func(int32) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int32Slice) AsyncMapBool(fn func(int32) bool, options ...Int32SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t int32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int32Slice) Reversed() Int32Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Int32Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Int32Slice) Item(index int) (item int32, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Int32Slice) ReverseSelect(where func(int32) bool, ands ...func(int32) bool) Int32Slice {
	if len(ands) > 0 {
		where = WhereInt32All(append([]func(int32) bool{where}, ands...)...)
	}
	var selected Int32Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int32Slice) First(where ...func(int32) bool) int32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt32All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int32
	return none
}

func (slice Int32Slice) Last(where ...func(int32) bool) int32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt32All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int32
	return none
}
func (slice Int32Slice) FirstIndex(p func(int32) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Int32Slice) Filter(p func(int32) bool) Int32Slice {
	var selected Int32Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int32Slice) IndexSelect(p func(int32) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Int32Slice) SelectAsync(p func(int32) bool) Int32Slice {
	var selected Int32Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int32Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Int32Slice) Strings() []string {
	return slice.MapString(func(x int32) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Int32Slice) Reject(p func(int32) bool) Int32Slice {
	return slice.Filter(func(n int32) bool { return !p(n) })
}

func (slice Int32Slice) RejectAsync(p func(int32) bool) Int32Slice {
	return slice.SelectAsync(func(n int32) bool { return !p(n) })
}

func (slice Int32Slice) Reduce(operator func(int32, int32) int32, options ...Int32SliceReduceOption) int32 {
	o := &Int32SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Int32Slice) Append(items ...int32) Int32Slice {
	if slice == nil {
		var empty Int32Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Int32Slice) Any(pl ...func(int32) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereInt32All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Int32Slice) AnyNot(pl ...func(int32) bool) bool {
	return !slice.Any(pl...)
}

func (slice Int32Slice) All(p func(int32) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Int32Slice) AllNot(p func(int32) bool) bool {
	return !slice.All(p)
}

func (slice Int32Slice) Copy() Int32Slice {
	cp := make(Int32Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Int32Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Int32Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Int32Slice) Count(p func(int32) bool) int {
	return len(slice.Filter(p))
}

func (slice Int32Slice) Max() int32 {
	return slice.Reduce(Int32Max)
}

func Int32Max(c1 int32, c2 int32) int32 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Int32Slice) Min() int32 {
	return slice.Reduce(Int32Min)
}

func Int32Min(c1 int32, c2 int32) int32 {
	if Int32Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Int32Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Int32Slice) MaxBy(less func(int32, int32) bool) (result int32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Int32Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Int32Slice) MinBy(less func(int32, int32) bool) (result int32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Int32Slice) Average() (int32, error) {
	return Int32Average(slice)
}

func Int32Average(slice Int32Slice) (int32, error) {
	var result int32
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / int32(l)
	return result, nil
}

func (slice Int32Slice) AverageFloat64() (float64, error) {
	return Int32AverageFloat64(slice)
}

func Int32AverageFloat64(slice Int32Slice) (float64, error) {
	var result int32
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Int32Slice) Distinct() Int32Slice {
	var result Int32Slice
	appended := make(map[int32]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Int32Slice) DistinctBy(fn func(int32, int32) bool) (result Int32Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Int32Slice) Each(f func(int32)) {
	for _, t := range slice {
		f(t)
	}
}

func WithInt32AsyncPoolSize(size int) Int32SliceAsyncOption {
	return func(options *Int32SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newInt32SliceAsyncOptions(opts ...Int32SliceAsyncOption) *Int32SliceAsyncOptions {
	o := &Int32SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Int32Slice) AsyncEachIndex(f func(int32, int), options ...Int32SliceAsyncOption) {
	o := newInt32SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item int32, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Int32Slice, f func(int32, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Int32Slice) AsyncEach(f func(int32), options ...Int32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int32, _ int) {
		f(t)
	}, options...)
}

func (slice Int32Slice) EachIndex(f func(int32, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Int32Slice) Equal(other []int32) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Int32Slice) Len() int {
	return len(slice)
}

func (slice Int32Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Int32Slice) Replace(fn func(t int32) int32) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Int32Slice) AsyncReplace(fn func(t int32) int32, options ...Int32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int32, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Int32Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Int32Slice) Sum() (result int32) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Int32Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int32Slice) Shuffled() Int32Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Int32Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int32Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Int32Slice) Sort() {
	sort.Sort(slice)
}

func (slice Int32Slice) Sorted() Int32Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Int32Slice) SortDesc() {
	sort.Sort(__Int32SliceDesc(slice))
}

func (slice Int32Slice) SortedDesc() Int32Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Int32Slice) SortedBy(less func(int32, int32) bool) Int32Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Int32Slice) SortBy(less func(int32, int32) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortInt32Slice(slice, less, 0, n, maxDepth)
}

func (slice Int32Slice) IsSortedBy(less func(int32, int32) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Int32Slice) SortDescBy(less func(int32, int32) bool) {
	slice.SortBy(func(a int32, b int32) bool { return !less(a, b) })
}

func (slice Int32Slice) SortedDescBy(less func(int32, int32) bool) Int32Slice {
	greater := func(a, b int32) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Int32Slice) Split(fn func(n int32) bool) (Int32Slice, Int32Slice) {
	var a Int32Slice
	var b Int32Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Int32Slice) IsSortedDescBy(less func(int32, int32) bool) bool {
	greater := func(a, b int32) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Int32Slice) AnyGreater(n int32) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Int32Slice) AnyLess(n int32) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Int32Slice) AnyGreaterEqual(n int32) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Int32Slice) AnyLessEqual(n int32) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Int32Slice) AnyEqual(n int32) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Int32Slice) ContainsAll(items ...int32) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Int32Slice) ContainsAny(items ...int32) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Int32Slice) Contains(n int32) bool {
	return slice.AnyEqual(n)
}

func (slice Int32Slice) SkipTake(skip, take int) Int32Slice {
	var out Int32Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapInt32Slice(slice Int32Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortInt32Slice(slice Int32Slice, less func(int32, int32) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapInt32Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownInt32Slice(slice Int32Slice, less func(int32, int32) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapInt32Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortInt32Slice(slice Int32Slice, less func(int32, int32) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownInt32Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapInt32Slice(slice, first, first+i)
		siftDownInt32Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeInt32Slice(slice Int32Slice, less func(int32, int32) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapInt32Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapInt32Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapInt32Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeInt32Slice(slice Int32Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapInt32Slice(slice, a+i, b+i)
	}
}
func doPivotInt32Slice(slice Int32Slice, less func(int32, int32) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeInt32Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeInt32Slice(slice, less, m, m-s, m+s)
		medianOfThreeInt32Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeInt32Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapInt32Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapInt32Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapInt32Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeInt32Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeInt32Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortInt32Slice(slice Int32Slice, less func(int32, int32) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortInt32Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotInt32Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortInt32Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortInt32Slice(slice, mhi, b)
		} else {
			quickSortInt32Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortInt32Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortInt32Slice(slice, less, a, b)
	}
}

type __Int32SliceDesc []int32

func (slice __Int32SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Int32SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Int32SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Int64Slice []int64
type Int64SliceReduceOption func(*Int64SliceReduceOptions)
type Int64SliceReduceOptions struct {
	initial int64
}

type Int64SliceAsyncOption func(options *Int64SliceAsyncOptions)
type Int64SliceAsyncOptions struct {
	PoolSize int
}

func NewInt64Slice(items ...int64) Int64Slice {
	slice := make(Int64Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInt64(t int64) Int64SliceReduceOption {
	return func(o *Int64SliceReduceOptions) {
		o.initial = t
	}
}

func WhereInt64All(pl ...func(int64) bool) func(int64) bool {
	return func(t int64) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereInt64Any(pl ...func(int64) bool) func(int64) bool {
	return func(t int64) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereInt64Not(p func(int64) bool) func(int64) bool {
	return func(t int64) bool {
		return !p(t)
	}
}

func (slice Int64Slice) Index(item int64) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Int64Slice) Map(fn func(int64) int64) Int64Slice {
	mapped := make(Int64Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int64Slice) AsyncMap(fn func(int64) int64, options ...Int64SliceAsyncOption) Int64Slice {
	output := make(Int64Slice, len(slice))
	eachFn := func(t int64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int64Slice) MapString(fn func(int64) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int64Slice) AsyncMapString(fn func(int64) string, options ...Int64SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t int64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int64Slice) MapBool(fn func(int64) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Int64Slice) AsyncMapBool(fn func(int64) bool, options ...Int64SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t int64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Int64Slice) Reversed() Int64Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Int64Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Int64Slice) Item(index int) (item int64, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Int64Slice) ReverseSelect(where func(int64) bool, ands ...func(int64) bool) Int64Slice {
	if len(ands) > 0 {
		where = WhereInt64All(append([]func(int64) bool{where}, ands...)...)
	}
	var selected Int64Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int64Slice) First(where ...func(int64) bool) int64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt64All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int64
	return none
}

func (slice Int64Slice) Last(where ...func(int64) bool) int64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInt64All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none int64
	return none
}
func (slice Int64Slice) FirstIndex(p func(int64) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Int64Slice) Filter(p func(int64) bool) Int64Slice {
	var selected Int64Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int64Slice) IndexSelect(p func(int64) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Int64Slice) SelectAsync(p func(int64) bool) Int64Slice {
	var selected Int64Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Int64Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Int64Slice) Strings() []string {
	return slice.MapString(func(x int64) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Int64Slice) Reject(p func(int64) bool) Int64Slice {
	return slice.Filter(func(n int64) bool { return !p(n) })
}

func (slice Int64Slice) RejectAsync(p func(int64) bool) Int64Slice {
	return slice.SelectAsync(func(n int64) bool { return !p(n) })
}

func (slice Int64Slice) Reduce(operator func(int64, int64) int64, options ...Int64SliceReduceOption) int64 {
	o := &Int64SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Int64Slice) Append(items ...int64) Int64Slice {
	if slice == nil {
		var empty Int64Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Int64Slice) Any(pl ...func(int64) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereInt64All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Int64Slice) AnyNot(pl ...func(int64) bool) bool {
	return !slice.Any(pl...)
}

func (slice Int64Slice) All(p func(int64) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Int64Slice) AllNot(p func(int64) bool) bool {
	return !slice.All(p)
}

func (slice Int64Slice) Copy() Int64Slice {
	cp := make(Int64Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Int64Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Int64Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Int64Slice) Count(p func(int64) bool) int {
	return len(slice.Filter(p))
}

func (slice Int64Slice) Max() int64 {
	return slice.Reduce(Int64Max)
}

func Int64Max(c1 int64, c2 int64) int64 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Int64Slice) Min() int64 {
	return slice.Reduce(Int64Min)
}

func Int64Min(c1 int64, c2 int64) int64 {
	if Int64Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Int64Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Int64Slice) MaxBy(less func(int64, int64) bool) (result int64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Int64Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Int64Slice) MinBy(less func(int64, int64) bool) (result int64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Int64Slice) Average() (int64, error) {
	return Int64Average(slice)
}

func Int64Average(slice Int64Slice) (int64, error) {
	var result int64
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / int64(l)
	return result, nil
}

func (slice Int64Slice) AverageFloat64() (float64, error) {
	return Int64AverageFloat64(slice)
}

func Int64AverageFloat64(slice Int64Slice) (float64, error) {
	var result int64
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Int64Slice) Distinct() Int64Slice {
	var result Int64Slice
	appended := make(map[int64]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Int64Slice) DistinctBy(fn func(int64, int64) bool) (result Int64Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Int64Slice) Each(f func(int64)) {
	for _, t := range slice {
		f(t)
	}
}

func WithInt64AsyncPoolSize(size int) Int64SliceAsyncOption {
	return func(options *Int64SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newInt64SliceAsyncOptions(opts ...Int64SliceAsyncOption) *Int64SliceAsyncOptions {
	o := &Int64SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Int64Slice) AsyncEachIndex(f func(int64, int), options ...Int64SliceAsyncOption) {
	o := newInt64SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item int64, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Int64Slice, f func(int64, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Int64Slice) AsyncEach(f func(int64), options ...Int64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int64, _ int) {
		f(t)
	}, options...)
}

func (slice Int64Slice) EachIndex(f func(int64, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Int64Slice) Equal(other []int64) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Int64Slice) Len() int {
	return len(slice)
}

func (slice Int64Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Int64Slice) Replace(fn func(t int64) int64) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Int64Slice) AsyncReplace(fn func(t int64) int64, options ...Int64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t int64, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Int64Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Int64Slice) Sum() (result int64) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Int64Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int64Slice) Shuffled() Int64Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Int64Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Int64Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Int64Slice) Sort() {
	sort.Sort(slice)
}

func (slice Int64Slice) Sorted() Int64Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Int64Slice) SortDesc() {
	sort.Sort(__Int64SliceDesc(slice))
}

func (slice Int64Slice) SortedDesc() Int64Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Int64Slice) SortedBy(less func(int64, int64) bool) Int64Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Int64Slice) SortBy(less func(int64, int64) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortInt64Slice(slice, less, 0, n, maxDepth)
}

func (slice Int64Slice) IsSortedBy(less func(int64, int64) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Int64Slice) SortDescBy(less func(int64, int64) bool) {
	slice.SortBy(func(a int64, b int64) bool { return !less(a, b) })
}

func (slice Int64Slice) SortedDescBy(less func(int64, int64) bool) Int64Slice {
	greater := func(a, b int64) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Int64Slice) Split(fn func(n int64) bool) (Int64Slice, Int64Slice) {
	var a Int64Slice
	var b Int64Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Int64Slice) IsSortedDescBy(less func(int64, int64) bool) bool {
	greater := func(a, b int64) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Int64Slice) AnyGreater(n int64) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Int64Slice) AnyLess(n int64) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Int64Slice) AnyGreaterEqual(n int64) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Int64Slice) AnyLessEqual(n int64) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Int64Slice) AnyEqual(n int64) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Int64Slice) ContainsAll(items ...int64) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Int64Slice) ContainsAny(items ...int64) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Int64Slice) Contains(n int64) bool {
	return slice.AnyEqual(n)
}

func (slice Int64Slice) SkipTake(skip, take int) Int64Slice {
	var out Int64Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapInt64Slice(slice Int64Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortInt64Slice(slice Int64Slice, less func(int64, int64) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapInt64Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownInt64Slice(slice Int64Slice, less func(int64, int64) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapInt64Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortInt64Slice(slice Int64Slice, less func(int64, int64) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownInt64Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapInt64Slice(slice, first, first+i)
		siftDownInt64Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeInt64Slice(slice Int64Slice, less func(int64, int64) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapInt64Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapInt64Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapInt64Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeInt64Slice(slice Int64Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapInt64Slice(slice, a+i, b+i)
	}
}
func doPivotInt64Slice(slice Int64Slice, less func(int64, int64) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeInt64Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeInt64Slice(slice, less, m, m-s, m+s)
		medianOfThreeInt64Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeInt64Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapInt64Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapInt64Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapInt64Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeInt64Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeInt64Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortInt64Slice(slice Int64Slice, less func(int64, int64) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortInt64Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotInt64Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortInt64Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortInt64Slice(slice, mhi, b)
		} else {
			quickSortInt64Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortInt64Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortInt64Slice(slice, less, a, b)
	}
}

type __Int64SliceDesc []int64

func (slice __Int64SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Int64SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Int64SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Float32Slice []float32
type Float32SliceReduceOption func(*Float32SliceReduceOptions)
type Float32SliceReduceOptions struct {
	initial float32
}

type Float32SliceAsyncOption func(options *Float32SliceAsyncOptions)
type Float32SliceAsyncOptions struct {
	PoolSize int
}

func NewFloat32Slice(items ...float32) Float32Slice {
	slice := make(Float32Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialFloat32(t float32) Float32SliceReduceOption {
	return func(o *Float32SliceReduceOptions) {
		o.initial = t
	}
}

func WhereFloat32All(pl ...func(float32) bool) func(float32) bool {
	return func(t float32) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereFloat32Any(pl ...func(float32) bool) func(float32) bool {
	return func(t float32) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereFloat32Not(p func(float32) bool) func(float32) bool {
	return func(t float32) bool {
		return !p(t)
	}
}

func (slice Float32Slice) Index(item float32) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Float32Slice) Map(fn func(float32) float32) Float32Slice {
	mapped := make(Float32Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float32Slice) AsyncMap(fn func(float32) float32, options ...Float32SliceAsyncOption) Float32Slice {
	output := make(Float32Slice, len(slice))
	eachFn := func(t float32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float32Slice) MapString(fn func(float32) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float32Slice) AsyncMapString(fn func(float32) string, options ...Float32SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t float32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float32Slice) MapBool(fn func(float32) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float32Slice) AsyncMapBool(fn func(float32) bool, options ...Float32SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t float32, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float32Slice) Reversed() Float32Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Float32Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Float32Slice) Item(index int) (item float32, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Float32Slice) ReverseSelect(where func(float32) bool, ands ...func(float32) bool) Float32Slice {
	if len(ands) > 0 {
		where = WhereFloat32All(append([]func(float32) bool{where}, ands...)...)
	}
	var selected Float32Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float32Slice) First(where ...func(float32) bool) float32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereFloat32All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none float32
	return none
}

func (slice Float32Slice) Last(where ...func(float32) bool) float32 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereFloat32All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none float32
	return none
}
func (slice Float32Slice) FirstIndex(p func(float32) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Float32Slice) Filter(p func(float32) bool) Float32Slice {
	var selected Float32Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float32Slice) IndexSelect(p func(float32) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Float32Slice) SelectAsync(p func(float32) bool) Float32Slice {
	var selected Float32Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float32Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Float32Slice) Strings() []string {
	return slice.MapString(func(x float32) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Float32Slice) Reject(p func(float32) bool) Float32Slice {
	return slice.Filter(func(n float32) bool { return !p(n) })
}

func (slice Float32Slice) RejectAsync(p func(float32) bool) Float32Slice {
	return slice.SelectAsync(func(n float32) bool { return !p(n) })
}

func (slice Float32Slice) Reduce(operator func(float32, float32) float32, options ...Float32SliceReduceOption) float32 {
	o := &Float32SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Float32Slice) Append(items ...float32) Float32Slice {
	if slice == nil {
		var empty Float32Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Float32Slice) Any(pl ...func(float32) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereFloat32All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Float32Slice) AnyNot(pl ...func(float32) bool) bool {
	return !slice.Any(pl...)
}

func (slice Float32Slice) All(p func(float32) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Float32Slice) AllNot(p func(float32) bool) bool {
	return !slice.All(p)
}

func (slice Float32Slice) Copy() Float32Slice {
	cp := make(Float32Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Float32Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Float32Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Float32Slice) Count(p func(float32) bool) int {
	return len(slice.Filter(p))
}

func (slice Float32Slice) Max() float32 {
	return slice.Reduce(Float32Max)
}

func Float32Max(c1 float32, c2 float32) float32 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Float32Slice) Min() float32 {
	return slice.Reduce(Float32Min)
}

func Float32Min(c1 float32, c2 float32) float32 {
	if Float32Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Float32Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Float32Slice) MaxBy(less func(float32, float32) bool) (result float32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Float32Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Float32Slice) MinBy(less func(float32, float32) bool) (result float32, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Float32Slice) Average() (float32, error) {
	return Float32Average(slice)
}

func Float32Average(slice Float32Slice) (float32, error) {
	var result float32
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / float32(l)
	return result, nil
}

func (slice Float32Slice) AverageFloat64() (float64, error) {
	return Float32AverageFloat64(slice)
}

func Float32AverageFloat64(slice Float32Slice) (float64, error) {
	var result float32
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Float32Slice) Distinct() Float32Slice {
	var result Float32Slice
	appended := make(map[float32]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Float32Slice) DistinctBy(fn func(float32, float32) bool) (result Float32Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Float32Slice) Each(f func(float32)) {
	for _, t := range slice {
		f(t)
	}
}

func WithFloat32AsyncPoolSize(size int) Float32SliceAsyncOption {
	return func(options *Float32SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newFloat32SliceAsyncOptions(opts ...Float32SliceAsyncOption) *Float32SliceAsyncOptions {
	o := &Float32SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Float32Slice) AsyncEachIndex(f func(float32, int), options ...Float32SliceAsyncOption) {
	o := newFloat32SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item float32, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Float32Slice, f func(float32, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Float32Slice) AsyncEach(f func(float32), options ...Float32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t float32, _ int) {
		f(t)
	}, options...)
}

func (slice Float32Slice) EachIndex(f func(float32, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Float32Slice) Equal(other []float32) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Float32Slice) Len() int {
	return len(slice)
}

func (slice Float32Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Float32Slice) Replace(fn func(t float32) float32) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Float32Slice) AsyncReplace(fn func(t float32) float32, options ...Float32SliceAsyncOption) {
	slice.AsyncEachIndex(func(t float32, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Float32Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Float32Slice) Sum() (result float32) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Float32Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Float32Slice) Shuffled() Float32Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Float32Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Float32Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Float32Slice) Sort() {
	sort.Sort(slice)
}

func (slice Float32Slice) Sorted() Float32Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Float32Slice) SortDesc() {
	sort.Sort(__Float32SliceDesc(slice))
}

func (slice Float32Slice) SortedDesc() Float32Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Float32Slice) SortedBy(less func(float32, float32) bool) Float32Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Float32Slice) SortBy(less func(float32, float32) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortFloat32Slice(slice, less, 0, n, maxDepth)
}

func (slice Float32Slice) IsSortedBy(less func(float32, float32) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Float32Slice) SortDescBy(less func(float32, float32) bool) {
	slice.SortBy(func(a float32, b float32) bool { return !less(a, b) })
}

func (slice Float32Slice) SortedDescBy(less func(float32, float32) bool) Float32Slice {
	greater := func(a, b float32) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Float32Slice) Split(fn func(n float32) bool) (Float32Slice, Float32Slice) {
	var a Float32Slice
	var b Float32Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Float32Slice) IsSortedDescBy(less func(float32, float32) bool) bool {
	greater := func(a, b float32) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Float32Slice) AnyGreater(n float32) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Float32Slice) AnyLess(n float32) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Float32Slice) AnyGreaterEqual(n float32) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Float32Slice) AnyLessEqual(n float32) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Float32Slice) AnyEqual(n float32) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Float32Slice) ContainsAll(items ...float32) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Float32Slice) ContainsAny(items ...float32) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Float32Slice) Contains(n float32) bool {
	return slice.AnyEqual(n)
}

func (slice Float32Slice) SkipTake(skip, take int) Float32Slice {
	var out Float32Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapFloat32Slice(slice Float32Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortFloat32Slice(slice Float32Slice, less func(float32, float32) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapFloat32Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownFloat32Slice(slice Float32Slice, less func(float32, float32) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapFloat32Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortFloat32Slice(slice Float32Slice, less func(float32, float32) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownFloat32Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapFloat32Slice(slice, first, first+i)
		siftDownFloat32Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeFloat32Slice(slice Float32Slice, less func(float32, float32) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapFloat32Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapFloat32Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapFloat32Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeFloat32Slice(slice Float32Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapFloat32Slice(slice, a+i, b+i)
	}
}
func doPivotFloat32Slice(slice Float32Slice, less func(float32, float32) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeFloat32Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeFloat32Slice(slice, less, m, m-s, m+s)
		medianOfThreeFloat32Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeFloat32Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapFloat32Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapFloat32Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapFloat32Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeFloat32Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeFloat32Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortFloat32Slice(slice Float32Slice, less func(float32, float32) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortFloat32Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotFloat32Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortFloat32Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortFloat32Slice(slice, mhi, b)
		} else {
			quickSortFloat32Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortFloat32Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortFloat32Slice(slice, less, a, b)
	}
}

type __Float32SliceDesc []float32

func (slice __Float32SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Float32SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Float32SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

type Float64Slice []float64
type Float64SliceReduceOption func(*Float64SliceReduceOptions)
type Float64SliceReduceOptions struct {
	initial float64
}

type Float64SliceAsyncOption func(options *Float64SliceAsyncOptions)
type Float64SliceAsyncOptions struct {
	PoolSize int
}

func NewFloat64Slice(items ...float64) Float64Slice {
	slice := make(Float64Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialFloat64(t float64) Float64SliceReduceOption {
	return func(o *Float64SliceReduceOptions) {
		o.initial = t
	}
}

func WhereFloat64All(pl ...func(float64) bool) func(float64) bool {
	return func(t float64) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereFloat64Any(pl ...func(float64) bool) func(float64) bool {
	return func(t float64) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereFloat64Not(p func(float64) bool) func(float64) bool {
	return func(t float64) bool {
		return !p(t)
	}
}

func (slice Float64Slice) Index(item float64) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

func (slice Float64Slice) Map(fn func(float64) float64) Float64Slice {
	mapped := make(Float64Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float64Slice) AsyncMap(fn func(float64) float64, options ...Float64SliceAsyncOption) Float64Slice {
	output := make(Float64Slice, len(slice))
	eachFn := func(t float64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float64Slice) MapString(fn func(float64) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float64Slice) AsyncMapString(fn func(float64) string, options ...Float64SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t float64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float64Slice) MapBool(fn func(float64) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Float64Slice) AsyncMapBool(fn func(float64) bool, options ...Float64SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t float64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Float64Slice) Reversed() Float64Slice {
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Float64Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

// safe index access allows negative indexing, but if past bounds will error
func (slice Float64Slice) Item(index int) (item float64, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Float64Slice) ReverseSelect(where func(float64) bool, ands ...func(float64) bool) Float64Slice {
	if len(ands) > 0 {
		where = WhereFloat64All(append([]func(float64) bool{where}, ands...)...)
	}
	var selected Float64Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float64Slice) First(where ...func(float64) bool) float64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereFloat64All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none float64
	return none
}

func (slice Float64Slice) Last(where ...func(float64) bool) float64 {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereFloat64All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			return t
		}
	}
	var none float64
	return none
}
func (slice Float64Slice) FirstIndex(p func(float64) bool) int {
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Float64Slice) Filter(p func(float64) bool) Float64Slice {
	var selected Float64Slice
	for _, t := range slice {
		if p(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float64Slice) IndexSelect(p func(float64) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

func (slice Float64Slice) SelectAsync(p func(float64) bool) Float64Slice {
	var selected Float64Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Float64Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Float64Slice) Strings() []string {
	return slice.MapString(func(x float64) string {
		return fmt.Sprintf("%v", x)
	})
}

func (slice Float64Slice) Reject(p func(float64) bool) Float64Slice {
	return slice.Filter(func(n float64) bool { return !p(n) })
}

func (slice Float64Slice) RejectAsync(p func(float64) bool) Float64Slice {
	return slice.SelectAsync(func(n float64) bool { return !p(n) })
}

func (slice Float64Slice) Reduce(operator func(float64, float64) float64, options ...Float64SliceReduceOption) float64 {
	o := &Float64SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	if len(slice) == 0 {
		return o.initial
	}
	result := o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

func (slice Float64Slice) Append(items ...float64) Float64Slice {
	if slice == nil {
		var empty Float64Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Float64Slice) Any(pl ...func(float64) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereFloat64All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Float64Slice) AnyNot(pl ...func(float64) bool) bool {
	return !slice.Any(pl...)
}

func (slice Float64Slice) All(p func(float64) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Float64Slice) AllNot(p func(float64) bool) bool {
	return !slice.All(p)
}

func (slice Float64Slice) Copy() Float64Slice {
	cp := make(Float64Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Float64Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Float64Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Float64Slice) Count(p func(float64) bool) int {
	return len(slice.Filter(p))
}

func (slice Float64Slice) Max() float64 {
	return slice.Reduce(Float64Max)
}

func Float64Max(c1 float64, c2 float64) float64 {
	if c1 < c2 {
		return c2
	}
	return c1
}

func (slice Float64Slice) Min() float64 {
	return slice.Reduce(Float64Min)
}

func Float64Min(c1 float64, c2 float64) float64 {
	if Float64Max(c1, c2) == c1 {
		return c2
	}
	return c1
}

// MaxBy returns an element of Float64Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Float64Slice) MaxBy(less func(float64, float64) bool) (result float64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if slice[i] != slice[m] && !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Float64Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Float64Slice) MinBy(less func(float64, float64) bool) (result float64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Float64Slice) Average() (float64, error) {
	return Float64Average(slice)
}

func Float64Average(slice Float64Slice) (float64, error) {
	var result float64
	l := len(slice)
	if l == 0 {
		return result, errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	result = result / float64(l)
	return result, nil
}

func (slice Float64Slice) AverageFloat64() (float64, error) {
	return Float64AverageFloat64(slice)
}

func Float64AverageFloat64(slice Float64Slice) (float64, error) {
	var result float64
	l := len(slice)
	if l == 0 {
		return float64(result), errors.New("cannot determine Average of zero-length numeric slice")
	}
	for _, v := range slice {
		result += v
	}
	return float64(result) / float64(l), nil
}

func (slice Float64Slice) Distinct() Float64Slice {
	var result Float64Slice
	appended := make(map[float64]bool)
	for _, v := range slice {
		_, ok := appended[v]
		if !ok {
			result = append(result, v)
			appended[v] = true
		}
	}
	return result
}

func (slice Float64Slice) DistinctBy(fn func(float64, float64) bool) (result Float64Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if fn(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Float64Slice) Each(f func(float64)) {
	for _, t := range slice {
		f(t)
	}
}

func WithFloat64AsyncPoolSize(size int) Float64SliceAsyncOption {
	return func(options *Float64SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newFloat64SliceAsyncOptions(opts ...Float64SliceAsyncOption) *Float64SliceAsyncOptions {
	o := &Float64SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Float64Slice) AsyncEachIndex(f func(float64, int), options ...Float64SliceAsyncOption) {
	o := newFloat64SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item float64, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Float64Slice, f func(float64, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
	return
}

func (slice Float64Slice) AsyncEach(f func(float64), options ...Float64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t float64, _ int) {
		f(t)
	}, options...)
}

func (slice Float64Slice) EachIndex(f func(float64, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Float64Slice) Equal(other []float64) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}
func (slice Float64Slice) Len() int {
	return len(slice)
}

func (slice Float64Slice) Less(i, j int) bool {
	return slice[i] < slice[j]
}

func (slice Float64Slice) Replace(fn func(t float64) float64) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Float64Slice) AsyncReplace(fn func(t float64) float64, options ...Float64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t float64, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Float64Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Float64Slice) Sum() (result float64) {
	for _, v := range slice {
		result += v
	}
	return
}

// Shuffled returns a copy of Float64Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Float64Slice) Shuffled() Float64Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Float64Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Float64Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

func (slice Float64Slice) Sort() {
	sort.Sort(slice)
}

func (slice Float64Slice) Sorted() Float64Slice {
	cp := slice.Copy()
	cp.Sort()
	return cp
}

func (slice Float64Slice) SortDesc() {
	sort.Sort(__Float64SliceDesc(slice))
}

func (slice Float64Slice) SortedDesc() Float64Slice {
	s := slice.Copy()
	s.SortDesc()
	return s
}

func (slice Float64Slice) SortedBy(less func(float64, float64) bool) Float64Slice {
	s := slice.Copy()
	s.SortBy(less)
	return s
}

func (slice Float64Slice) SortBy(less func(float64, float64) bool) {
	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	quickSortFloat64Slice(slice, less, 0, n, maxDepth)
}

func (slice Float64Slice) IsSortedBy(less func(float64, float64) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Float64Slice) SortDescBy(less func(float64, float64) bool) {
	slice.SortBy(func(a float64, b float64) bool { return !less(a, b) })
}

func (slice Float64Slice) SortedDescBy(less func(float64, float64) bool) Float64Slice {
	greater := func(a, b float64) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Float64Slice) Split(fn func(n float64) bool) (Float64Slice, Float64Slice) {
	var a Float64Slice
	var b Float64Slice
	for _, n := range slice {
		if fn(n) {
			a = append(a, n)
		} else {
			b = append(b, n)
		}
	}
	return a, b
}

func (slice Float64Slice) IsSortedDescBy(less func(float64, float64) bool) bool {
	greater := func(a, b float64) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

func (slice Float64Slice) AnyGreater(n float64) bool {
	for _, sn := range slice {
		if sn > n {
			return true
		}
	}
	return false
}

func (slice Float64Slice) AnyLess(n float64) bool {
	for _, sn := range slice {
		if sn < n {
			return true
		}
	}
	return false
}

func (slice Float64Slice) AnyGreaterEqual(n float64) bool {
	for _, sn := range slice {
		if sn >= n {
			return true
		}
	}
	return false
}

func (slice Float64Slice) AnyLessEqual(n float64) bool {
	for _, sn := range slice {
		if sn <= n {
			return true
		}
	}
	return false
}

func (slice Float64Slice) AnyEqual(n float64) bool {
	for _, sn := range slice {
		if sn == n {
			return true
		}
	}
	return false
}

func (slice Float64Slice) ContainsAll(items ...float64) bool {
	for _, item := range items {
		if !slice.AnyEqual(item) {
			return false
		}
	}
	return true
}

func (slice Float64Slice) ContainsAny(items ...float64) bool {
	for _, item := range items {
		if slice.AnyEqual(item) {
			return true
		}
	}
	return false
}

func (slice Float64Slice) Contains(n float64) bool {
	return slice.AnyEqual(n)
}

func (slice Float64Slice) SkipTake(skip, take int) Float64Slice {
	var out Float64Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func swapFloat64Slice(slice Float64Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func insertionSortFloat64Slice(slice Float64Slice, less func(float64, float64) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			swapFloat64Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDownFloat64Slice(slice Float64Slice, less func(float64, float64) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		swapFloat64Slice(slice, first+root, first+child)
		root = child
	}
}
func heapSortFloat64Slice(slice Float64Slice, less func(float64, float64) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownFloat64Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		swapFloat64Slice(slice, first, first+i)
		siftDownFloat64Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func medianOfThreeFloat64Slice(slice Float64Slice, less func(float64, float64) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		swapFloat64Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		swapFloat64Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		swapFloat64Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}
func swapRangeFloat64Slice(slice Float64Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		swapFloat64Slice(slice, a+i, b+i)
	}
}
func doPivotFloat64Slice(slice Float64Slice, less func(float64, float64) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		medianOfThreeFloat64Slice(slice, less, lo, lo+s, lo+2*s)
		medianOfThreeFloat64Slice(slice, less, m, m-s, m+s)
		medianOfThreeFloat64Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThreeFloat64Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				swapFloat64Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				swapFloat64Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		swapFloat64Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	swapRangeFloat64Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	swapRangeFloat64Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func quickSortFloat64Slice(slice Float64Slice, less func(float64, float64) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			heapSortFloat64Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivotFloat64Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSortFloat64Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortFloat64Slice(slice, mhi, b)
		} else {
			quickSortFloat64Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortFloat64Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		insertionSortFloat64Slice(slice, less, a, b)
	}
}

type __Float64SliceDesc []float64

func (slice __Float64SliceDesc) Len() int {
	return len(slice)
}

//actually greater!
func (slice __Float64SliceDesc) Less(i, j int) bool {
	return slice[i] > slice[j]
}

func (slice __Float64SliceDesc) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}
