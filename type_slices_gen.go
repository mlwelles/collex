// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/noho-digital/genny

package collex

import (
	"errors"
	"fmt"
	"math/rand"
	"strings"
	"sync"
)

type InterfaceSlice []Interface
type InterfaceSliceReduceOption func(*InterfaceSliceReduceOptions)
type InterfaceSliceReduceOptions struct {
	initial Interface
}

type InterfaceSliceAsyncOption func(options *InterfaceSliceAsyncOptions)
type InterfaceSliceAsyncOptions struct {
	PoolSize int
}

func NewInterfaceSlice(items ...Interface) InterfaceSlice {
	slice := make(InterfaceSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialInterface(t Interface) InterfaceSliceReduceOption {
	return func(o *InterfaceSliceReduceOptions) {
		o.initial = t
	}
}

func WhereInterfaceAll(pl ...func(Interface) bool) func(Interface) bool {
	return func(t Interface) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereInterfaceAny(pl ...func(Interface) bool) func(Interface) bool {
	return func(t Interface) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereInterfaceNot(p func(Interface) bool) func(Interface) bool {
	return func(t Interface) bool {
		return !p(t)
	}
}

func (slice InterfaceSlice) Index(item Interface) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

// Returns copy of slice with only items that have non-default values
// (e.g. for pointer types all non-nil items)
func (slice InterfaceSlice) Compact() InterfaceSlice {
	var dfl Interface
	s := NewInterfaceSlice()
	for _, t := range slice {
		if t == dfl {
			continue
		}
		s = append(s, t)
	}
	return s
}

func (slice InterfaceSlice) Map(fn func(Interface) Interface) InterfaceSlice {
	mapped := make(InterfaceSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice InterfaceSlice) AsyncMap(fn func(Interface) Interface, options ...InterfaceSliceAsyncOption) InterfaceSlice {
	output := make(InterfaceSlice, len(slice))
	eachFn := func(t Interface, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice InterfaceSlice) MapString(fn func(Interface) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice InterfaceSlice) AsyncMapString(fn func(Interface) string, options ...InterfaceSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t Interface, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice InterfaceSlice) MapBool(fn func(Interface) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice InterfaceSlice) AsyncMapBool(fn func(Interface) bool, options ...InterfaceSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t Interface, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice InterfaceSlice) Filter(where func(Interface) bool, ands ...func(Interface) bool) InterfaceSlice {
	if len(ands) > 0 {
		where = WhereInterfaceAll(append([]func(Interface) bool{where}, ands...)...)
	}
	var selected InterfaceSlice
	for _, t := range slice {
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice InterfaceSlice) Reversed() InterfaceSlice {
	s2 := make(InterfaceSlice, len(slice))
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		s2[i] = slice[j]
	}
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice InterfaceSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

func (slice InterfaceSlice) ReverseSelect(where func(Interface) bool, ands ...func(Interface) bool) InterfaceSlice {
	if len(ands) > 0 {
		where = WhereInterfaceAll(append([]func(Interface) bool{where}, ands...)...)
	}
	var selected InterfaceSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice InterfaceSlice) IndexSelect(p func(Interface) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

// safe index access -- allows negative indexing, and will error instead of panic if out of bounds
func (slice InterfaceSlice) Item(index int) (item Interface, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice InterfaceSlice) SelectAsync(p func(Interface) bool) InterfaceSlice {
	var selected InterfaceSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice InterfaceSlice) Reject(p func(Interface) bool) InterfaceSlice {
	return slice.Filter(func(t Interface) bool { return !p(t) })
}

func (slice InterfaceSlice) Reduce(operator func(Interface, Interface) Interface, options ...InterfaceSliceReduceOption) (result Interface) {
	o := &InterfaceSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	result = o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will walk the slice backwards and return true for the first item where all the predicates
// return true
func (slice InterfaceSlice) ReverseAny(criteria ...func(Interface) bool) bool {
	if len(criteria) == 0 {
		return len(slice) > 0
	}
	p := WhereInterfaceAll(criteria...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if p(t) {
			return true
		}
	}
	return false
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice InterfaceSlice) Any(pl ...func(Interface) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereInterfaceAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice InterfaceSlice) ContainsAll(items ...Interface) bool {
	for _, item := range items {
		itemMatch := false
		for _, t := range slice {
			if item == t {
				itemMatch = true
				break
			}
		}
		if !itemMatch {
			return false
		}
	}
	return true
}

func (slice InterfaceSlice) ContainsAny(items ...Interface) bool {
	for _, t := range slice {
		for _, item := range items {
			if item == t {
				return true
			}
		}
	}
	return false
}

func (slice InterfaceSlice) PopLast() (last Interface, rest InterfaceSlice) {
	l := len(slice)
	if l > 0 {
		last = slice[len(slice)-1]
	}
	if l > 1 {
		rest = slice[0 : len(slice)-1]
	}
	return last, rest
}

func (slice InterfaceSlice) PopFirst() (first Interface, rest InterfaceSlice) {
	l := len(slice)
	if l > 0 {
		first = slice[0]
	}
	if l > 1 {
		rest = slice[1:]
	}
	return first, rest
}

func (slice InterfaceSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice InterfaceSlice) Strings() []string {
	return slice.MapString(func(x Interface) string {
		return fmt.Sprintf("%v", x)
	})
}
func (slice InterfaceSlice) Pop(index int) (popped Interface, rest InterfaceSlice) {
	if index < 0 {
		index = len(slice) - index
	}
	if index <= 0 {
		return slice.PopFirst()
	}
	if index >= len(slice)-1 {
		return slice.PopLast()
	}
	for i, item := range slice {
		if i == index {
			popped = item
		} else {
			rest = append(rest, item)
		}
	}
	return popped, rest
}

func (slice InterfaceSlice) Contains(item Interface) bool {
	for _, t := range slice {
		if item == t {
			return true
		}
	}
	return false
}

func (slice InterfaceSlice) AnyNot(pl ...func(Interface) bool) bool {
	return !slice.Any(pl...)
}

func (slice InterfaceSlice) All(p func(Interface) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice InterfaceSlice) AllNot(p func(Interface) bool) bool {
	return !slice.All(p)
}

func (slice InterfaceSlice) Append(items ...Interface) InterfaceSlice {
	if slice == nil {
		var empty InterfaceSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

func (slice InterfaceSlice) Count(p func(Interface) bool) int {
	return len(slice.Filter(p))
}

func (slice InterfaceSlice) Equal(other []Interface) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}

func (slice InterfaceSlice) Last(where ...func(Interface) bool) (last Interface) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInterfaceAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			last = t
			break
		}
	}
	return last
}

func (slice InterfaceSlice) First(where ...func(Interface) bool) (first Interface) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereInterfaceAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			first = t
			break
		}
	}
	return first
}

func (slice InterfaceSlice) FirstIndex(where ...func(Interface) bool) int {
	if len(slice) == 0 {
		return -1
	}
	p := WhereInterfaceAll(where...)
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice InterfaceSlice) DistinctBy(match func(Interface, Interface) bool) (result InterfaceSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if match(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice InterfaceSlice) Len() int {
	return len(slice)
}

func (slice InterfaceSlice) Each(f func(Interface)) {
	for _, t := range slice {
		f(t)
	}
}

func (slice InterfaceSlice) AsyncEach(f func(Interface), options ...InterfaceSliceAsyncOption) {
	slice.AsyncEachIndex(func(t Interface, _ int) {
		f(t)
	}, options...)
}

func WithInterfaceAsyncPoolSize(size int) InterfaceSliceAsyncOption {
	return func(options *InterfaceSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newInterfaceSliceAsyncOptions(opts ...InterfaceSliceAsyncOption) *InterfaceSliceAsyncOptions {
	o := &InterfaceSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice InterfaceSlice) AsyncEachIndex(f func(Interface, int), options ...InterfaceSliceAsyncOption) {
	o := newInterfaceSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item Interface, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice InterfaceSlice, f func(Interface, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
}

func (slice InterfaceSlice) EachIndex(f func(Interface, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice InterfaceSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice InterfaceSlice) Empty() bool {
	return len(slice) == 0
}

func (slice InterfaceSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice InterfaceSlice) AsyncCopy() InterfaceSlice {
	cp := make(InterfaceSlice, len(slice))
	slice.AsyncEachIndex(func(_ Interface, i int) {
		cp[i] = slice[i]
	})
	return cp
}

func (slice InterfaceSlice) Copy() InterfaceSlice {
	cp := make(InterfaceSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice InterfaceSlice) SortBy(less func(Interface, Interface) bool) {

	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	__quickSortInterfaceSlice(slice, less, 0, n, maxDepth)
}

func (slice InterfaceSlice) SortedBy(less func(Interface, Interface) bool) InterfaceSlice {
	cp := slice.Copy()
	cp.SortBy(less)
	return cp
}

func (slice InterfaceSlice) IsSortedBy(less func(Interface, Interface) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice InterfaceSlice) SortDescBy(less func(Interface, Interface) bool) {
	greater := func(a, b Interface) bool {
		return less(b, a)
	}
	slice.SortBy(greater)
}

func (slice InterfaceSlice) SortedDescBy(less func(Interface, Interface) bool) InterfaceSlice {
	greater := func(a, b Interface) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice InterfaceSlice) IsSortedDescBy(less func(Interface, Interface) bool) bool {
	greater := func(a, b Interface) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

// Shuffled returns a copy of InterfaceSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice InterfaceSlice) Shuffled() InterfaceSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of InterfaceSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice InterfaceSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

// MaxBy returns an element of InterfaceSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice InterfaceSlice) MaxBy(less func(Interface, Interface) bool) (result Interface, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of InterfaceSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice InterfaceSlice) MinBy(less func(Interface, Interface) bool) (result Interface, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice InterfaceSlice) AsyncReplaced(fn func(t Interface) Interface) InterfaceSlice {
	s := slice.Copy()
	s.AsyncReplace(fn)
	return s
}

func (slice InterfaceSlice) Replaced(fn func(t Interface) Interface) InterfaceSlice {
	s := slice.Copy()
	s.Replace(fn)
	return s
}

func (slice InterfaceSlice) Replace(fn func(t Interface) Interface) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice InterfaceSlice) AsyncReplace(fn func(t Interface) Interface, options ...InterfaceSliceAsyncOption) {
	slice.AsyncEachIndex(func(t Interface, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice InterfaceSlice) SkipTake(skip, take int) InterfaceSlice {
	var out InterfaceSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func (slice InterfaceSlice) Split(fn func(t Interface) bool) (InterfaceSlice, InterfaceSlice) {
	var a InterfaceSlice
	var b InterfaceSlice
	for _, t := range slice {
		if fn(t) {
			a = append(a, t)
		} else {
			b = append(b, t)
		}
	}
	return a, b
}

func __swapInterfaceSlice(slice InterfaceSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func __insertionSortInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			__swapInterfaceSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func __siftDownInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		__swapInterfaceSlice(slice, first+root, first+child)
		root = child
	}
}
func __heapSortInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		__siftDownInterfaceSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		__swapInterfaceSlice(slice, first, first+i)
		__siftDownInterfaceSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func __medianOfThreeInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		__swapInterfaceSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		__swapInterfaceSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		__swapInterfaceSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}

func __swapRangeInterfaceSlice(slice InterfaceSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		__swapInterfaceSlice(slice, a+i, b+i)
	}
}
func __doPivotInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		__medianOfThreeInterfaceSlice(slice, less, lo, lo+s, lo+2*s)
		__medianOfThreeInterfaceSlice(slice, less, m, m-s, m+s)
		__medianOfThreeInterfaceSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	__medianOfThreeInterfaceSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				__swapInterfaceSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				__swapInterfaceSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		__swapInterfaceSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	__swapRangeInterfaceSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	__swapRangeInterfaceSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func __quickSortInterfaceSlice(slice InterfaceSlice, less func(Interface, Interface) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			__heapSortInterfaceSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := __doPivotInterfaceSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			__quickSortInterfaceSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortInterfaceSlice(slice, mhi, b)
		} else {
			__quickSortInterfaceSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortInterfaceSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		__insertionSortInterfaceSlice(slice, less, a, b)
	}
}

type BoolSlice []bool
type BoolSliceReduceOption func(*BoolSliceReduceOptions)
type BoolSliceReduceOptions struct {
	initial bool
}

type BoolSliceAsyncOption func(options *BoolSliceAsyncOptions)
type BoolSliceAsyncOptions struct {
	PoolSize int
}

func NewBoolSlice(items ...bool) BoolSlice {
	slice := make(BoolSlice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialBool(t bool) BoolSliceReduceOption {
	return func(o *BoolSliceReduceOptions) {
		o.initial = t
	}
}

func WhereBoolAll(pl ...func(bool) bool) func(bool) bool {
	return func(t bool) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereBoolAny(pl ...func(bool) bool) func(bool) bool {
	return func(t bool) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereBoolNot(p func(bool) bool) func(bool) bool {
	return func(t bool) bool {
		return !p(t)
	}
}

func (slice BoolSlice) Index(item bool) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

// Returns copy of slice with only items that have non-default values
// (e.g. for pointer types all non-nil items)
func (slice BoolSlice) Compact() BoolSlice {
	var dfl bool
	s := NewBoolSlice()
	for _, t := range slice {
		if t == dfl {
			continue
		}
		s = append(s, t)
	}
	return s
}

func (slice BoolSlice) Map(fn func(bool) bool) BoolSlice {
	mapped := make(BoolSlice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice BoolSlice) AsyncMap(fn func(bool) bool, options ...BoolSliceAsyncOption) BoolSlice {
	output := make(BoolSlice, len(slice))
	eachFn := func(t bool, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice BoolSlice) MapString(fn func(bool) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice BoolSlice) AsyncMapString(fn func(bool) string, options ...BoolSliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t bool, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice BoolSlice) MapBool(fn func(bool) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice BoolSlice) AsyncMapBool(fn func(bool) bool, options ...BoolSliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t bool, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice BoolSlice) Filter(where func(bool) bool, ands ...func(bool) bool) BoolSlice {
	if len(ands) > 0 {
		where = WhereBoolAll(append([]func(bool) bool{where}, ands...)...)
	}
	var selected BoolSlice
	for _, t := range slice {
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice BoolSlice) Reversed() BoolSlice {
	s2 := make(BoolSlice, len(slice))
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		s2[i] = slice[j]
	}
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice BoolSlice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

func (slice BoolSlice) ReverseSelect(where func(bool) bool, ands ...func(bool) bool) BoolSlice {
	if len(ands) > 0 {
		where = WhereBoolAll(append([]func(bool) bool{where}, ands...)...)
	}
	var selected BoolSlice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice BoolSlice) IndexSelect(p func(bool) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

// safe index access -- allows negative indexing, and will error instead of panic if out of bounds
func (slice BoolSlice) Item(index int) (item bool, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice BoolSlice) SelectAsync(p func(bool) bool) BoolSlice {
	var selected BoolSlice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice BoolSlice) Reject(p func(bool) bool) BoolSlice {
	return slice.Filter(func(t bool) bool { return !p(t) })
}

func (slice BoolSlice) Reduce(operator func(bool, bool) bool, options ...BoolSliceReduceOption) (result bool) {
	o := &BoolSliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	result = o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will walk the slice backwards and return true for the first item where all the predicates
// return true
func (slice BoolSlice) ReverseAny(criteria ...func(bool) bool) bool {
	if len(criteria) == 0 {
		return len(slice) > 0
	}
	p := WhereBoolAll(criteria...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if p(t) {
			return true
		}
	}
	return false
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice BoolSlice) Any(pl ...func(bool) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereBoolAll(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice BoolSlice) ContainsAll(items ...bool) bool {
	for _, item := range items {
		itemMatch := false
		for _, t := range slice {
			if item == t {
				itemMatch = true
				break
			}
		}
		if !itemMatch {
			return false
		}
	}
	return true
}

func (slice BoolSlice) ContainsAny(items ...bool) bool {
	for _, t := range slice {
		for _, item := range items {
			if item == t {
				return true
			}
		}
	}
	return false
}

func (slice BoolSlice) PopLast() (last bool, rest BoolSlice) {
	l := len(slice)
	if l > 0 {
		last = slice[len(slice)-1]
	}
	if l > 1 {
		rest = slice[0 : len(slice)-1]
	}
	return last, rest
}

func (slice BoolSlice) PopFirst() (first bool, rest BoolSlice) {
	l := len(slice)
	if l > 0 {
		first = slice[0]
	}
	if l > 1 {
		rest = slice[1:]
	}
	return first, rest
}

func (slice BoolSlice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice BoolSlice) Strings() []string {
	return slice.MapString(func(x bool) string {
		return fmt.Sprintf("%v", x)
	})
}
func (slice BoolSlice) Pop(index int) (popped bool, rest BoolSlice) {
	if index < 0 {
		index = len(slice) - index
	}
	if index <= 0 {
		return slice.PopFirst()
	}
	if index >= len(slice)-1 {
		return slice.PopLast()
	}
	for i, item := range slice {
		if i == index {
			popped = item
		} else {
			rest = append(rest, item)
		}
	}
	return popped, rest
}

func (slice BoolSlice) Contains(item bool) bool {
	for _, t := range slice {
		if item == t {
			return true
		}
	}
	return false
}

func (slice BoolSlice) AnyNot(pl ...func(bool) bool) bool {
	return !slice.Any(pl...)
}

func (slice BoolSlice) All(p func(bool) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice BoolSlice) AllNot(p func(bool) bool) bool {
	return !slice.All(p)
}

func (slice BoolSlice) Append(items ...bool) BoolSlice {
	if slice == nil {
		var empty BoolSlice
		return append(empty, items...)
	}
	return append(slice, items...)
}

func (slice BoolSlice) Count(p func(bool) bool) int {
	return len(slice.Filter(p))
}

func (slice BoolSlice) Equal(other []bool) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}

func (slice BoolSlice) Last(where ...func(bool) bool) (last bool) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereBoolAll(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			last = t
			break
		}
	}
	return last
}

func (slice BoolSlice) First(where ...func(bool) bool) (first bool) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereBoolAll(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			first = t
			break
		}
	}
	return first
}

func (slice BoolSlice) FirstIndex(where ...func(bool) bool) int {
	if len(slice) == 0 {
		return -1
	}
	p := WhereBoolAll(where...)
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice BoolSlice) DistinctBy(match func(bool, bool) bool) (result BoolSlice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if match(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice BoolSlice) Len() int {
	return len(slice)
}

func (slice BoolSlice) Each(f func(bool)) {
	for _, t := range slice {
		f(t)
	}
}

func (slice BoolSlice) AsyncEach(f func(bool), options ...BoolSliceAsyncOption) {
	slice.AsyncEachIndex(func(t bool, _ int) {
		f(t)
	}, options...)
}

func WithBoolAsyncPoolSize(size int) BoolSliceAsyncOption {
	return func(options *BoolSliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newBoolSliceAsyncOptions(opts ...BoolSliceAsyncOption) *BoolSliceAsyncOptions {
	o := &BoolSliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice BoolSlice) AsyncEachIndex(f func(bool, int), options ...BoolSliceAsyncOption) {
	o := newBoolSliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item bool, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice BoolSlice, f func(bool, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
}

func (slice BoolSlice) EachIndex(f func(bool, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice BoolSlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice BoolSlice) Empty() bool {
	return len(slice) == 0
}

func (slice BoolSlice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice BoolSlice) AsyncCopy() BoolSlice {
	cp := make(BoolSlice, len(slice))
	slice.AsyncEachIndex(func(_ bool, i int) {
		cp[i] = slice[i]
	})
	return cp
}

func (slice BoolSlice) Copy() BoolSlice {
	cp := make(BoolSlice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice BoolSlice) SortBy(less func(bool, bool) bool) {

	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	__quickSortBoolSlice(slice, less, 0, n, maxDepth)
}

func (slice BoolSlice) SortedBy(less func(bool, bool) bool) BoolSlice {
	cp := slice.Copy()
	cp.SortBy(less)
	return cp
}

func (slice BoolSlice) IsSortedBy(less func(bool, bool) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice BoolSlice) SortDescBy(less func(bool, bool) bool) {
	greater := func(a, b bool) bool {
		return less(b, a)
	}
	slice.SortBy(greater)
}

func (slice BoolSlice) SortedDescBy(less func(bool, bool) bool) BoolSlice {
	greater := func(a, b bool) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice BoolSlice) IsSortedDescBy(less func(bool, bool) bool) bool {
	greater := func(a, b bool) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

// Shuffled returns a copy of BoolSlice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice BoolSlice) Shuffled() BoolSlice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of BoolSlice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice BoolSlice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

// MaxBy returns an element of BoolSlice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice BoolSlice) MaxBy(less func(bool, bool) bool) (result bool, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of BoolSlice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice BoolSlice) MinBy(less func(bool, bool) bool) (result bool, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice BoolSlice) AsyncReplaced(fn func(t bool) bool) BoolSlice {
	s := slice.Copy()
	s.AsyncReplace(fn)
	return s
}

func (slice BoolSlice) Replaced(fn func(t bool) bool) BoolSlice {
	s := slice.Copy()
	s.Replace(fn)
	return s
}

func (slice BoolSlice) Replace(fn func(t bool) bool) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice BoolSlice) AsyncReplace(fn func(t bool) bool, options ...BoolSliceAsyncOption) {
	slice.AsyncEachIndex(func(t bool, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice BoolSlice) SkipTake(skip, take int) BoolSlice {
	var out BoolSlice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func (slice BoolSlice) Split(fn func(t bool) bool) (BoolSlice, BoolSlice) {
	var a BoolSlice
	var b BoolSlice
	for _, t := range slice {
		if fn(t) {
			a = append(a, t)
		} else {
			b = append(b, t)
		}
	}
	return a, b
}

func __swapBoolSlice(slice BoolSlice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func __insertionSortBoolSlice(slice BoolSlice, less func(bool, bool) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			__swapBoolSlice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func __siftDownBoolSlice(slice BoolSlice, less func(bool, bool) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		__swapBoolSlice(slice, first+root, first+child)
		root = child
	}
}
func __heapSortBoolSlice(slice BoolSlice, less func(bool, bool) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		__siftDownBoolSlice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		__swapBoolSlice(slice, first, first+i)
		__siftDownBoolSlice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func __medianOfThreeBoolSlice(slice BoolSlice, less func(bool, bool) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		__swapBoolSlice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		__swapBoolSlice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		__swapBoolSlice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}

func __swapRangeBoolSlice(slice BoolSlice, a, b, n int) {
	for i := 0; i < n; i++ {
		__swapBoolSlice(slice, a+i, b+i)
	}
}
func __doPivotBoolSlice(slice BoolSlice, less func(bool, bool) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		__medianOfThreeBoolSlice(slice, less, lo, lo+s, lo+2*s)
		__medianOfThreeBoolSlice(slice, less, m, m-s, m+s)
		__medianOfThreeBoolSlice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	__medianOfThreeBoolSlice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				__swapBoolSlice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				__swapBoolSlice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		__swapBoolSlice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	__swapRangeBoolSlice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	__swapRangeBoolSlice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func __quickSortBoolSlice(slice BoolSlice, less func(bool, bool) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			__heapSortBoolSlice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := __doPivotBoolSlice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			__quickSortBoolSlice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortBoolSlice(slice, mhi, b)
		} else {
			__quickSortBoolSlice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortBoolSlice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		__insertionSortBoolSlice(slice, less, a, b)
	}
}

type Complex64Slice []complex64
type Complex64SliceReduceOption func(*Complex64SliceReduceOptions)
type Complex64SliceReduceOptions struct {
	initial complex64
}

type Complex64SliceAsyncOption func(options *Complex64SliceAsyncOptions)
type Complex64SliceAsyncOptions struct {
	PoolSize int
}

func NewComplex64Slice(items ...complex64) Complex64Slice {
	slice := make(Complex64Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialComplex64(t complex64) Complex64SliceReduceOption {
	return func(o *Complex64SliceReduceOptions) {
		o.initial = t
	}
}

func WhereComplex64All(pl ...func(complex64) bool) func(complex64) bool {
	return func(t complex64) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereComplex64Any(pl ...func(complex64) bool) func(complex64) bool {
	return func(t complex64) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereComplex64Not(p func(complex64) bool) func(complex64) bool {
	return func(t complex64) bool {
		return !p(t)
	}
}

func (slice Complex64Slice) Index(item complex64) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

// Returns copy of slice with only items that have non-default values
// (e.g. for pointer types all non-nil items)
func (slice Complex64Slice) Compact() Complex64Slice {
	var dfl complex64
	s := NewComplex64Slice()
	for _, t := range slice {
		if t == dfl {
			continue
		}
		s = append(s, t)
	}
	return s
}

func (slice Complex64Slice) Map(fn func(complex64) complex64) Complex64Slice {
	mapped := make(Complex64Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex64Slice) AsyncMap(fn func(complex64) complex64, options ...Complex64SliceAsyncOption) Complex64Slice {
	output := make(Complex64Slice, len(slice))
	eachFn := func(t complex64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex64Slice) MapString(fn func(complex64) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex64Slice) AsyncMapString(fn func(complex64) string, options ...Complex64SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t complex64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex64Slice) MapBool(fn func(complex64) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex64Slice) AsyncMapBool(fn func(complex64) bool, options ...Complex64SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t complex64, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex64Slice) Filter(where func(complex64) bool, ands ...func(complex64) bool) Complex64Slice {
	if len(ands) > 0 {
		where = WhereComplex64All(append([]func(complex64) bool{where}, ands...)...)
	}
	var selected Complex64Slice
	for _, t := range slice {
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex64Slice) Reversed() Complex64Slice {
	s2 := make(Complex64Slice, len(slice))
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		s2[i] = slice[j]
	}
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Complex64Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

func (slice Complex64Slice) ReverseSelect(where func(complex64) bool, ands ...func(complex64) bool) Complex64Slice {
	if len(ands) > 0 {
		where = WhereComplex64All(append([]func(complex64) bool{where}, ands...)...)
	}
	var selected Complex64Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex64Slice) IndexSelect(p func(complex64) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

// safe index access -- allows negative indexing, and will error instead of panic if out of bounds
func (slice Complex64Slice) Item(index int) (item complex64, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Complex64Slice) SelectAsync(p func(complex64) bool) Complex64Slice {
	var selected Complex64Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex64Slice) Reject(p func(complex64) bool) Complex64Slice {
	return slice.Filter(func(t complex64) bool { return !p(t) })
}

func (slice Complex64Slice) Reduce(operator func(complex64, complex64) complex64, options ...Complex64SliceReduceOption) (result complex64) {
	o := &Complex64SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	result = o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will walk the slice backwards and return true for the first item where all the predicates
// return true
func (slice Complex64Slice) ReverseAny(criteria ...func(complex64) bool) bool {
	if len(criteria) == 0 {
		return len(slice) > 0
	}
	p := WhereComplex64All(criteria...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if p(t) {
			return true
		}
	}
	return false
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Complex64Slice) Any(pl ...func(complex64) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereComplex64All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Complex64Slice) ContainsAll(items ...complex64) bool {
	for _, item := range items {
		itemMatch := false
		for _, t := range slice {
			if item == t {
				itemMatch = true
				break
			}
		}
		if !itemMatch {
			return false
		}
	}
	return true
}

func (slice Complex64Slice) ContainsAny(items ...complex64) bool {
	for _, t := range slice {
		for _, item := range items {
			if item == t {
				return true
			}
		}
	}
	return false
}

func (slice Complex64Slice) PopLast() (last complex64, rest Complex64Slice) {
	l := len(slice)
	if l > 0 {
		last = slice[len(slice)-1]
	}
	if l > 1 {
		rest = slice[0 : len(slice)-1]
	}
	return last, rest
}

func (slice Complex64Slice) PopFirst() (first complex64, rest Complex64Slice) {
	l := len(slice)
	if l > 0 {
		first = slice[0]
	}
	if l > 1 {
		rest = slice[1:]
	}
	return first, rest
}

func (slice Complex64Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Complex64Slice) Strings() []string {
	return slice.MapString(func(x complex64) string {
		return fmt.Sprintf("%v", x)
	})
}
func (slice Complex64Slice) Pop(index int) (popped complex64, rest Complex64Slice) {
	if index < 0 {
		index = len(slice) - index
	}
	if index <= 0 {
		return slice.PopFirst()
	}
	if index >= len(slice)-1 {
		return slice.PopLast()
	}
	for i, item := range slice {
		if i == index {
			popped = item
		} else {
			rest = append(rest, item)
		}
	}
	return popped, rest
}

func (slice Complex64Slice) Contains(item complex64) bool {
	for _, t := range slice {
		if item == t {
			return true
		}
	}
	return false
}

func (slice Complex64Slice) AnyNot(pl ...func(complex64) bool) bool {
	return !slice.Any(pl...)
}

func (slice Complex64Slice) All(p func(complex64) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Complex64Slice) AllNot(p func(complex64) bool) bool {
	return !slice.All(p)
}

func (slice Complex64Slice) Append(items ...complex64) Complex64Slice {
	if slice == nil {
		var empty Complex64Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

func (slice Complex64Slice) Count(p func(complex64) bool) int {
	return len(slice.Filter(p))
}

func (slice Complex64Slice) Equal(other []complex64) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}

func (slice Complex64Slice) Last(where ...func(complex64) bool) (last complex64) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereComplex64All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			last = t
			break
		}
	}
	return last
}

func (slice Complex64Slice) First(where ...func(complex64) bool) (first complex64) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereComplex64All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			first = t
			break
		}
	}
	return first
}

func (slice Complex64Slice) FirstIndex(where ...func(complex64) bool) int {
	if len(slice) == 0 {
		return -1
	}
	p := WhereComplex64All(where...)
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Complex64Slice) DistinctBy(match func(complex64, complex64) bool) (result Complex64Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if match(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Complex64Slice) Len() int {
	return len(slice)
}

func (slice Complex64Slice) Each(f func(complex64)) {
	for _, t := range slice {
		f(t)
	}
}

func (slice Complex64Slice) AsyncEach(f func(complex64), options ...Complex64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t complex64, _ int) {
		f(t)
	}, options...)
}

func WithComplex64AsyncPoolSize(size int) Complex64SliceAsyncOption {
	return func(options *Complex64SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newComplex64SliceAsyncOptions(opts ...Complex64SliceAsyncOption) *Complex64SliceAsyncOptions {
	o := &Complex64SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Complex64Slice) AsyncEachIndex(f func(complex64, int), options ...Complex64SliceAsyncOption) {
	o := newComplex64SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item complex64, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Complex64Slice, f func(complex64, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
}

func (slice Complex64Slice) EachIndex(f func(complex64, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Complex64Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Complex64Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Complex64Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Complex64Slice) AsyncCopy() Complex64Slice {
	cp := make(Complex64Slice, len(slice))
	slice.AsyncEachIndex(func(_ complex64, i int) {
		cp[i] = slice[i]
	})
	return cp
}

func (slice Complex64Slice) Copy() Complex64Slice {
	cp := make(Complex64Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Complex64Slice) SortBy(less func(complex64, complex64) bool) {

	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	__quickSortComplex64Slice(slice, less, 0, n, maxDepth)
}

func (slice Complex64Slice) SortedBy(less func(complex64, complex64) bool) Complex64Slice {
	cp := slice.Copy()
	cp.SortBy(less)
	return cp
}

func (slice Complex64Slice) IsSortedBy(less func(complex64, complex64) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Complex64Slice) SortDescBy(less func(complex64, complex64) bool) {
	greater := func(a, b complex64) bool {
		return less(b, a)
	}
	slice.SortBy(greater)
}

func (slice Complex64Slice) SortedDescBy(less func(complex64, complex64) bool) Complex64Slice {
	greater := func(a, b complex64) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Complex64Slice) IsSortedDescBy(less func(complex64, complex64) bool) bool {
	greater := func(a, b complex64) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

// Shuffled returns a copy of Complex64Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Complex64Slice) Shuffled() Complex64Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Complex64Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Complex64Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

// MaxBy returns an element of Complex64Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Complex64Slice) MaxBy(less func(complex64, complex64) bool) (result complex64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Complex64Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Complex64Slice) MinBy(less func(complex64, complex64) bool) (result complex64, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Complex64Slice) AsyncReplaced(fn func(t complex64) complex64) Complex64Slice {
	s := slice.Copy()
	s.AsyncReplace(fn)
	return s
}

func (slice Complex64Slice) Replaced(fn func(t complex64) complex64) Complex64Slice {
	s := slice.Copy()
	s.Replace(fn)
	return s
}

func (slice Complex64Slice) Replace(fn func(t complex64) complex64) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Complex64Slice) AsyncReplace(fn func(t complex64) complex64, options ...Complex64SliceAsyncOption) {
	slice.AsyncEachIndex(func(t complex64, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Complex64Slice) SkipTake(skip, take int) Complex64Slice {
	var out Complex64Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func (slice Complex64Slice) Split(fn func(t complex64) bool) (Complex64Slice, Complex64Slice) {
	var a Complex64Slice
	var b Complex64Slice
	for _, t := range slice {
		if fn(t) {
			a = append(a, t)
		} else {
			b = append(b, t)
		}
	}
	return a, b
}

func __swapComplex64Slice(slice Complex64Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func __insertionSortComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			__swapComplex64Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func __siftDownComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		__swapComplex64Slice(slice, first+root, first+child)
		root = child
	}
}
func __heapSortComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		__siftDownComplex64Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		__swapComplex64Slice(slice, first, first+i)
		__siftDownComplex64Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func __medianOfThreeComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		__swapComplex64Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		__swapComplex64Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		__swapComplex64Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}

func __swapRangeComplex64Slice(slice Complex64Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		__swapComplex64Slice(slice, a+i, b+i)
	}
}
func __doPivotComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		__medianOfThreeComplex64Slice(slice, less, lo, lo+s, lo+2*s)
		__medianOfThreeComplex64Slice(slice, less, m, m-s, m+s)
		__medianOfThreeComplex64Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	__medianOfThreeComplex64Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				__swapComplex64Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				__swapComplex64Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		__swapComplex64Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	__swapRangeComplex64Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	__swapRangeComplex64Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func __quickSortComplex64Slice(slice Complex64Slice, less func(complex64, complex64) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			__heapSortComplex64Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := __doPivotComplex64Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			__quickSortComplex64Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortComplex64Slice(slice, mhi, b)
		} else {
			__quickSortComplex64Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortComplex64Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		__insertionSortComplex64Slice(slice, less, a, b)
	}
}

type Complex128Slice []complex128
type Complex128SliceReduceOption func(*Complex128SliceReduceOptions)
type Complex128SliceReduceOptions struct {
	initial complex128
}

type Complex128SliceAsyncOption func(options *Complex128SliceAsyncOptions)
type Complex128SliceAsyncOptions struct {
	PoolSize int
}

func NewComplex128Slice(items ...complex128) Complex128Slice {
	slice := make(Complex128Slice, len(items))
	for i, item := range items {
		slice[i] = item
	}
	return slice
}

func WithInitialComplex128(t complex128) Complex128SliceReduceOption {
	return func(o *Complex128SliceReduceOptions) {
		o.initial = t
	}
}

func WhereComplex128All(pl ...func(complex128) bool) func(complex128) bool {
	return func(t complex128) bool {
		for _, p := range pl {
			if !p(t) {
				return false
			}
		}
		return true
	}
}

func WhereComplex128Any(pl ...func(complex128) bool) func(complex128) bool {
	return func(t complex128) bool {
		for _, p := range pl {
			if p(t) {
				return true
			}
		}
		return false
	}
}

func WhereComplex128Not(p func(complex128) bool) func(complex128) bool {
	return func(t complex128) bool {
		return !p(t)
	}
}

func (slice Complex128Slice) Index(item complex128) int {
	for i, t := range slice {
		if item == t {
			return i
		}
	}
	return -1
}

// Returns copy of slice with only items that have non-default values
// (e.g. for pointer types all non-nil items)
func (slice Complex128Slice) Compact() Complex128Slice {
	var dfl complex128
	s := NewComplex128Slice()
	for _, t := range slice {
		if t == dfl {
			continue
		}
		s = append(s, t)
	}
	return s
}

func (slice Complex128Slice) Map(fn func(complex128) complex128) Complex128Slice {
	mapped := make(Complex128Slice, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex128Slice) AsyncMap(fn func(complex128) complex128, options ...Complex128SliceAsyncOption) Complex128Slice {
	output := make(Complex128Slice, len(slice))
	eachFn := func(t complex128, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex128Slice) MapString(fn func(complex128) string) []string {
	mapped := make([]string, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex128Slice) AsyncMapString(fn func(complex128) string, options ...Complex128SliceAsyncOption) []string {
	output := make([]string, len(slice))
	eachFn := func(t complex128, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex128Slice) MapBool(fn func(complex128) bool) []bool {
	mapped := make([]bool, len(slice))
	for i, t := range slice {
		mapped[i] = fn(t)
	}
	return mapped
}

func (slice Complex128Slice) AsyncMapBool(fn func(complex128) bool, options ...Complex128SliceAsyncOption) []bool {
	output := make([]bool, len(slice))
	eachFn := func(t complex128, i int) {
		v := fn(t)
		output[i] = v
	}
	slice.AsyncEachIndex(eachFn, options...)
	return output
}

func (slice Complex128Slice) Filter(where func(complex128) bool, ands ...func(complex128) bool) Complex128Slice {
	if len(ands) > 0 {
		where = WhereComplex128All(append([]func(complex128) bool{where}, ands...)...)
	}
	var selected Complex128Slice
	for _, t := range slice {
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex128Slice) Reversed() Complex128Slice {
	s2 := make(Complex128Slice, len(slice))
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		s2[i] = slice[j]
	}
	r := slice.Copy()
	r.Reverse()
	return r
}

func (slice Complex128Slice) Reverse() {
	for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
		slice[i], slice[j] = slice[j], slice[i]
	}
}

func (slice Complex128Slice) ReverseSelect(where func(complex128) bool, ands ...func(complex128) bool) Complex128Slice {
	if len(ands) > 0 {
		where = WhereComplex128All(append([]func(complex128) bool{where}, ands...)...)
	}
	var selected Complex128Slice
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if where(t) {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex128Slice) IndexSelect(p func(complex128) bool) []int {
	var indexes []int
	for i, t := range slice {
		if p(t) {
			indexes = append(indexes, i)
		}
	}
	return indexes
}

// safe index access -- allows negative indexing, and will error instead of panic if out of bounds
func (slice Complex128Slice) Item(index int) (item complex128, err error) {
	if index < 0 {
		index = len(slice) - index
	}
	if index < 0 || index > len(slice)+1 {
		err = fmt.Errorf("index out of range")
	} else {
		item = slice[index]
	}
	return item, err
}

func (slice Complex128Slice) SelectAsync(p func(complex128) bool) Complex128Slice {
	var selected Complex128Slice
	hits := slice.AsyncMapBool(p)
	for i, t := range slice {
		if hits[i] {
			selected = append(selected, t)
		}
	}
	return selected
}

func (slice Complex128Slice) Reject(p func(complex128) bool) Complex128Slice {
	return slice.Filter(func(t complex128) bool { return !p(t) })
}

func (slice Complex128Slice) Reduce(operator func(complex128, complex128) complex128, options ...Complex128SliceReduceOption) (result complex128) {
	o := &Complex128SliceReduceOptions{}
	for _, opt := range options {
		opt(o)
	}
	result = o.initial
	for _, next := range slice {
		result = operator(result, next)
	}
	return result
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will walk the slice backwards and return true for the first item where all the predicates
// return true
func (slice Complex128Slice) ReverseAny(criteria ...func(complex128) bool) bool {
	if len(criteria) == 0 {
		return len(slice) > 0
	}
	p := WhereComplex128All(criteria...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if p(t) {
			return true
		}
	}
	return false
}

// If no predicate function parameters given returns true if slice is not empty.
// Otherwise, will return true if all predicate function parameters return true for any item in the slice
func (slice Complex128Slice) Any(pl ...func(complex128) bool) bool {
	if len(pl) == 0 {
		return len(slice) > 0
	}
	p := WhereComplex128All(pl...)
	for _, t := range slice {
		if p(t) {
			return true
		}
	}
	return false
}

func (slice Complex128Slice) ContainsAll(items ...complex128) bool {
	for _, item := range items {
		itemMatch := false
		for _, t := range slice {
			if item == t {
				itemMatch = true
				break
			}
		}
		if !itemMatch {
			return false
		}
	}
	return true
}

func (slice Complex128Slice) ContainsAny(items ...complex128) bool {
	for _, t := range slice {
		for _, item := range items {
			if item == t {
				return true
			}
		}
	}
	return false
}

func (slice Complex128Slice) PopLast() (last complex128, rest Complex128Slice) {
	l := len(slice)
	if l > 0 {
		last = slice[len(slice)-1]
	}
	if l > 1 {
		rest = slice[0 : len(slice)-1]
	}
	return last, rest
}

func (slice Complex128Slice) PopFirst() (first complex128, rest Complex128Slice) {
	l := len(slice)
	if l > 0 {
		first = slice[0]
	}
	if l > 1 {
		rest = slice[1:]
	}
	return first, rest
}

func (slice Complex128Slice) String() string {
	if slice == nil {
		return fmt.Sprint(nil)
	}
	return fmt.Sprintf("[%v]", strings.Join(slice.Strings(), ", "))
}

func (slice Complex128Slice) Strings() []string {
	return slice.MapString(func(x complex128) string {
		return fmt.Sprintf("%v", x)
	})
}
func (slice Complex128Slice) Pop(index int) (popped complex128, rest Complex128Slice) {
	if index < 0 {
		index = len(slice) - index
	}
	if index <= 0 {
		return slice.PopFirst()
	}
	if index >= len(slice)-1 {
		return slice.PopLast()
	}
	for i, item := range slice {
		if i == index {
			popped = item
		} else {
			rest = append(rest, item)
		}
	}
	return popped, rest
}

func (slice Complex128Slice) Contains(item complex128) bool {
	for _, t := range slice {
		if item == t {
			return true
		}
	}
	return false
}

func (slice Complex128Slice) AnyNot(pl ...func(complex128) bool) bool {
	return !slice.Any(pl...)
}

func (slice Complex128Slice) All(p func(complex128) bool) bool {
	for _, t := range slice {
		if !p(t) {
			return false
		}
	}
	return true
}

func (slice Complex128Slice) AllNot(p func(complex128) bool) bool {
	return !slice.All(p)
}

func (slice Complex128Slice) Append(items ...complex128) Complex128Slice {
	if slice == nil {
		var empty Complex128Slice
		return append(empty, items...)
	}
	return append(slice, items...)
}

func (slice Complex128Slice) Count(p func(complex128) bool) int {
	return len(slice.Filter(p))
}

func (slice Complex128Slice) Equal(other []complex128) bool {
	if len(slice) != len(other) {
		return false
	}
	for n := range slice {
		if slice[n] != other[n] {
			return false
		}
	}
	return true
}

func (slice Complex128Slice) Last(where ...func(complex128) bool) (last complex128) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereComplex128All(where...)
	for i := len(slice) - 1; i >= 0; i-- {
		t := slice[i]
		if !hasCriteria || matchesCriteria(t) {
			last = t
			break
		}
	}
	return last
}

func (slice Complex128Slice) First(where ...func(complex128) bool) (first complex128) {
	hasCriteria := len(where) > 0
	matchesCriteria := WhereComplex128All(where...)
	for _, t := range slice {
		if !hasCriteria || matchesCriteria(t) {
			first = t
			break
		}
	}
	return first
}

func (slice Complex128Slice) FirstIndex(where ...func(complex128) bool) int {
	if len(slice) == 0 {
		return -1
	}
	p := WhereComplex128All(where...)
	for i, t := range slice {
		if p(t) {
			return i
		}
	}
	return -1
}

func (slice Complex128Slice) DistinctBy(match func(complex128, complex128) bool) (result Complex128Slice) {
Outer:
	for _, v := range slice {
		for _, r := range result {
			if match(v, r) {
				continue Outer
			}
		}
		result = append(result, v)
	}
	return result
}

func (slice Complex128Slice) Len() int {
	return len(slice)
}

func (slice Complex128Slice) Each(f func(complex128)) {
	for _, t := range slice {
		f(t)
	}
}

func (slice Complex128Slice) AsyncEach(f func(complex128), options ...Complex128SliceAsyncOption) {
	slice.AsyncEachIndex(func(t complex128, _ int) {
		f(t)
	}, options...)
}

func WithComplex128AsyncPoolSize(size int) Complex128SliceAsyncOption {
	return func(options *Complex128SliceAsyncOptions) {
		options.PoolSize = size
	}
}

func newComplex128SliceAsyncOptions(opts ...Complex128SliceAsyncOption) *Complex128SliceAsyncOptions {
	o := &Complex128SliceAsyncOptions{PoolSize: -1}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

func (slice Complex128Slice) AsyncEachIndex(f func(complex128, int), options ...Complex128SliceAsyncOption) {
	o := newComplex128SliceAsyncOptions(options...)
	if o.PoolSize <= 0 {
		wg := &sync.WaitGroup{}
		for index, item := range slice {
			wg.Add(1)
			go func(item complex128, index int) {
				f(item, index)
				wg.Done()
			}(item, index)
		}
		wg.Wait()
		return
	}
	pending := make(chan int, len(slice))
	completed := make(chan int, len(slice))
	for w := 0; w < o.PoolSize; w++ {
		go func(slice Complex128Slice, f func(complex128, int), pending <-chan int, completed chan<- int) {
			for index := range pending {
				item := slice[index]
				f(item, index)
				completed <- index
			}
		}(slice, f, pending, completed)
	}
	for index := range slice {
		pending <- index
	}
	close(pending)
	for range slice {
		<-completed
	}
}

func (slice Complex128Slice) EachIndex(f func(complex128, int)) {
	for i, t := range slice {
		f(t, i)
	}
}

func (slice Complex128Slice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

func (slice Complex128Slice) Empty() bool {
	return len(slice) == 0
}

func (slice Complex128Slice) NotEmpty() bool {
	return len(slice) > 0
}

func (slice Complex128Slice) AsyncCopy() Complex128Slice {
	cp := make(Complex128Slice, len(slice))
	slice.AsyncEachIndex(func(_ complex128, i int) {
		cp[i] = slice[i]
	})
	return cp
}

func (slice Complex128Slice) Copy() Complex128Slice {
	cp := make(Complex128Slice, len(slice))
	for i := range slice {
		cp[i] = slice[i]
	}
	return cp
}

func (slice Complex128Slice) SortBy(less func(complex128, complex128) bool) {

	// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
	n := len(slice)
	maxDepth := 0
	for i := n; i > 0; i >>= 1 {
		maxDepth++
	}
	maxDepth *= 2
	__quickSortComplex128Slice(slice, less, 0, n, maxDepth)
}

func (slice Complex128Slice) SortedBy(less func(complex128, complex128) bool) Complex128Slice {
	cp := slice.Copy()
	cp.SortBy(less)
	return cp
}

func (slice Complex128Slice) IsSortedBy(less func(complex128, complex128) bool) bool {
	n := len(slice)
	for i := n - 1; i > 0; i-- {
		if less(slice[i], slice[i-1]) {
			return false
		}
	}
	return true
}

func (slice Complex128Slice) SortDescBy(less func(complex128, complex128) bool) {
	greater := func(a, b complex128) bool {
		return less(b, a)
	}
	slice.SortBy(greater)
}

func (slice Complex128Slice) SortedDescBy(less func(complex128, complex128) bool) Complex128Slice {
	greater := func(a, b complex128) bool {
		return less(b, a)
	}
	return slice.SortedBy(greater)
}

func (slice Complex128Slice) IsSortedDescBy(less func(complex128, complex128) bool) bool {
	greater := func(a, b complex128) bool {
		return less(b, a)
	}
	return slice.IsSortedBy(greater)
}

// Shuffled returns a copy of Complex128Slice with the contents shuffles using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Complex128Slice) Shuffled() Complex128Slice {
	s := slice.Copy()
	s.Shuffle()
	return s
}

// Shuffle shuffles the contents of Complex128Slice in place using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (slice Complex128Slice) Shuffle() {
	total := len(slice)
	for i := 0; i < total; i++ {
		r := i + rand.Intn(total-i)
		slice[r], slice[i] = slice[i], slice[r]
	}
}

// MaxBy returns an element of Complex128Slice containing the maximum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally maximal, the last such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MaxBy
func (slice Complex128Slice) MaxBy(less func(complex128, complex128) bool) (result complex128, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the MaxBy of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if !less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

// MinBy returns an element of Complex128Slice containing the minimum value, when compared to other elements using a passed func defining ‘less’. In the case of multiple items being equally minimal, the first such element is returned. Returns error if no elements. See: http://clipperhouse.github.io/gen/#MinBy
func (slice Complex128Slice) MinBy(less func(complex128, complex128) bool) (result complex128, err error) {
	l := len(slice)
	if l == 0 {
		err = errors.New("cannot determine the Min of an empty slice")
		return
	}
	m := 0
	for i := 1; i < l; i++ {
		if less(slice[i], slice[m]) {
			m = i
		}
	}
	result = slice[m]
	return
}

func (slice Complex128Slice) AsyncReplaced(fn func(t complex128) complex128) Complex128Slice {
	s := slice.Copy()
	s.AsyncReplace(fn)
	return s
}

func (slice Complex128Slice) Replaced(fn func(t complex128) complex128) Complex128Slice {
	s := slice.Copy()
	s.Replace(fn)
	return s
}

func (slice Complex128Slice) Replace(fn func(t complex128) complex128) {
	for i, t := range slice {
		slice[i] = fn(t)
	}
}

func (slice Complex128Slice) AsyncReplace(fn func(t complex128) complex128, options ...Complex128SliceAsyncOption) {
	slice.AsyncEachIndex(func(t complex128, i int) {
		slice[i] = fn(t)
	}, options...)
}

func (slice Complex128Slice) SkipTake(skip, take int) Complex128Slice {
	var out Complex128Slice
	skipped := 0
	taken := 0
	for _, item := range slice {
		if skip > skipped {
			skipped++
			continue
		}
		out = append(out, item)
		taken++
		if take > 0 && taken >= take {
			break
		}
	}
	return out

}
func (slice Complex128Slice) Split(fn func(t complex128) bool) (Complex128Slice, Complex128Slice) {
	var a Complex128Slice
	var b Complex128Slice
	for _, t := range slice {
		if fn(t) {
			a = append(a, t)
		} else {
			b = append(b, t)
		}
	}
	return a, b
}

func __swapComplex128Slice(slice Complex128Slice, a, b int) {
	slice[a], slice[b] = slice[b], slice[a]
}

// Insertion sort
func __insertionSortComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && less(slice[j], slice[j-1]); j-- {
			__swapComplex128Slice(slice, j, j-1)
		}
	}
}

// siftDown implements the heap property on slice[lo, hi).
// first is an offset into the array where the root of the heap lies.
func __siftDownComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && less(slice[first+child], slice[first+child+1]) {
			child++
		}
		if !less(slice[first+root], slice[first+child]) {
			return
		}
		__swapComplex128Slice(slice, first+root, first+child)
		root = child
	}
}
func __heapSortComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, a, b int) {
	first := a
	lo := 0
	hi := b - a
	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		__siftDownComplex128Slice(slice, less, i, hi, first)
	}
	// Pop elements, largest first, into end of slice.
	for i := hi - 1; i >= 0; i-- {
		__swapComplex128Slice(slice, first, first+i)
		__siftDownComplex128Slice(slice, less, lo, i, first)
	}
}

// Quicksort, following Bentley and McIlroy,
// Engineering a Sort Function, SP&E November 1993.
// medianOfThree moves the median of the three values slice[a], slice[b], slice[c] into slice[a].
func __medianOfThreeComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, a, b, c int) {
	m0 := b
	m1 := a
	m2 := c
	// bubble sort on 3 elements
	if less(slice[m1], slice[m0]) {
		__swapComplex128Slice(slice, m1, m0)
	}
	if less(slice[m2], slice[m1]) {
		__swapComplex128Slice(slice, m2, m1)
	}
	if less(slice[m1], slice[m0]) {
		__swapComplex128Slice(slice, m1, m0)
	}
	// now slice[m0] <= slice[m1] <= slice[m2]
}

func __swapRangeComplex128Slice(slice Complex128Slice, a, b, n int) {
	for i := 0; i < n; i++ {
		__swapComplex128Slice(slice, a+i, b+i)
	}
}
func __doPivotComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, lo, hi int) (midlo, midhi int) {
	m := lo + (hi-lo)/2 // Written like this to avoid integer overflow.
	if hi-lo > 40 {
		// Tukey's Ninther, median of three medians of three.
		s := (hi - lo) / 8
		__medianOfThreeComplex128Slice(slice, less, lo, lo+s, lo+2*s)
		__medianOfThreeComplex128Slice(slice, less, m, m-s, m+s)
		__medianOfThreeComplex128Slice(slice, less, hi-1, hi-1-s, hi-1-2*s)
	}
	__medianOfThreeComplex128Slice(slice, less, lo, m, hi-1)
	// Invariants are:
	//	slice[lo] = pivot (set up by ChoosePivot)
	//	slice[lo <= i < a] = pivot
	//	slice[a <= i < b] < pivot
	//	slice[b <= i < c] is unexamined
	//	slice[c <= i < d] > pivot
	//	slice[d <= i < hi] = pivot
	//
	// Once b meets c, can swap the "= pivot" sections
	// into the middle of the slice.
	pivot := lo
	a, b, c, d := lo+1, lo+1, hi, hi
	for {
		for b < c {
			if less(slice[b], slice[pivot]) { // slice[b] < pivot
				b++
			} else if !less(slice[pivot], slice[b]) { // slice[b] = pivot
				__swapComplex128Slice(slice, a, b)
				a++
				b++
			} else {
				break
			}
		}
		for b < c {
			if less(slice[pivot], slice[c-1]) { // slice[c-1] > pivot
				c--
			} else if !less(slice[c-1], slice[pivot]) { // slice[c-1] = pivot
				__swapComplex128Slice(slice, c-1, d-1)
				c--
				d--
			} else {
				break
			}
		}
		if b >= c {
			break
		}
		// slice[b] > pivot; slice[c-1] < pivot
		__swapComplex128Slice(slice, b, c-1)
		b++
		c--
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	n := min(b-a, a-lo)
	__swapRangeComplex128Slice(slice, lo, b-n, n)
	n = min(hi-d, d-c)
	__swapRangeComplex128Slice(slice, c, hi-n, n)
	return lo + b - a, hi - (d - c)
}

func __quickSortComplex128Slice(slice Complex128Slice, less func(complex128, complex128) bool, a, b, maxDepth int) {
	for b-a > 7 {
		if maxDepth == 0 {
			__heapSortComplex128Slice(slice, less, a, b)
			return
		}
		maxDepth--
		mlo, mhi := __doPivotComplex128Slice(slice, less, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			__quickSortComplex128Slice(slice, less, a, mlo, maxDepth)
			a = mhi // i.e., quickSortComplex128Slice(slice, mhi, b)
		} else {
			__quickSortComplex128Slice(slice, less, mhi, b, maxDepth)
			b = mlo // i.e., quickSortComplex128Slice(slice, a, mlo)
		}
	}
	if b-a > 1 {
		__insertionSortComplex128Slice(slice, less, a, b)
	}
}
